# 计算机网络

## 复习指南

**应用层** 

（1）另一个最最最常问的问题，在浏览器中输入 URL 地址到浏览器显示网页这个过程中计算机网络做了什么。

这个问题无论是考研还是找工作都是常见的，建议把 JavaGuide 中这个问题的总结熟读并全文背诵。

（2）HTTP 1.0 和 HTTP 1.1 的主要区别这个也要了解一下。

（3）HTTP 和 HTTPS 的区别这个也是面试常考问题，这个问题展开以后能问的就比较多了。

在回答这个问题时你首先分别介绍一下**HTTP 和 HTTPS 的原理以及区别**。大致就是 HTTP 是通过明文在网络上传输的，HTTPS 是加密的。有的面试官问到这也就可以了，有的面试官不讲武德，想搞偷袭，会继续让你讲 **HTTPS 建立连接的流程**、然后会继续追着你问**SSL 的工作流程**。建议把这里好好准备一下，面试官一问你就可以展开讲，你就能消耗很多面试时间，这样面试官问其它问题的时间就少了，嘿嘿。

（4）HTTP请求常见的状态码背几个常用的就好。

（5）DNS域名系统这里你要可以描述清楚工作原理，也是面试常问问题。

**传输层**

面试中计算机网络的问题最常出现在这一章中。

1. 记清楚 TCP 和 UDP 的区别。
2. TCP三次握手和UDP四次挥手。

这是面试计算机网络最最最常问的问题！！！你计算机网络就算其它的什么也不会，这个问题你必须要记清楚，如果面试官问出你这个问题你都答不上，面试官估计觉得你连敷衍都不想敷衍他了。

当面试官问你三次握手和四次挥手时，你要答出这三个点来：

（1）为什么要三次挥手和四次挥手，如果不这样做会有什么影响。

（2）三次握手四次挥手的整个流程。

（3）有的面试官只要你答出三次握手和四次挥手的大体流程就好了，但是有的面试官会要求你答出三次握手和四次挥手时发送端和接收端分别发了哪些标记。

3. TCP协议如何保证可靠传输

把 ARQ 协议、滑动窗口、流量控制、拥塞控制等回答清楚就算到位了。

**网络层**

网络层面试问的也相对较少，主要就是问IPV4，偶尔问一下ARP地址解析协议的的工作原理。

1. 首先要记清楚 IPV4 地址是怎么分类的、以及地址的格式。这里经常结合代码题一起问你，我和很多同学都在面试中被面试官要求写一个程序判断给定的字符串是否是 IPV4 地址。
2. IPV4 子网划分面试中不怎么问，笔试题时经常有这个问题。
3. 了解 IP 地址和 Mac 地址的区别，了解 ARP 地址解析协议并了解其工作原理。

**网络接口层**

把网卡、网桥、交换机的概念、用途简单了解下就好，一般面试官不会问。

## 键入网址到网页显示，期间发生了什么？

1. 浏览器解析`url`；
2. 生成一个`http`请求协议包，把协议包的发送委托给操作系统；
3. 操作系统在发送协议包之前先要获取服务器的IP地址。如果在本地的浏览器缓存、操作系统缓存或者hosts文件中存在对应的IP地址，就不需要再访问本地的DNS服务器了。如果不存在，访问本地的DNS服务器，由本地DNS服务器对进行递归访问，即按照层级向下访问，最后得到IP地址；
4. 得到ip地址后。进行TCP连接，三次握手；
5. 握手之后，把请求层层封装，通过网卡将数据发送到交换机。交换机会进行校验以及查找交换表转发，到达路由器。路由器把MAC层扒皮，查看目的ip，然后根据路由表选择下一跳，再进行MAC层封装。重复这个过程，最后到达服务器；
6. 到达服务器后，会对数据包进行扒皮并且校验。使用FCS校验码校验二进制序列的正确性。在MAC层看目的MAC是不是自己，在网络层看目的ip是不是自己，同时知道上层协议是TCP还是UDP协议。在TCP中知道这是一个什么保文，请求保文、响应报文还是结束连接的报文。通过端口号知道这是交给那么应用进程的；
7. 应用进程知道你访问的是什么资源，那么就给客户端返回一个Http响应协议包，把资源封装在其中。通过同样的流程把数据返回给客户端；
8. 浏览器拿到数据后，对数据进行渲染，解码，变成了一个页面显示在浏览器上。

## HTTP状态码

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101656585.png" alt=" 五大类 HTTP 状态码 " style="zoom:50%;" /></div>

`1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

`2xx` 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。

- 「**200 OK**」是最常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。
- 「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

`3xx` 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
- 「**302 Found**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。

`4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。
- 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。
- 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

`5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
- 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
- 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。

## GET和POST的区别

GET和POST是HTTP协议中的两种发送请求的方法。GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器处理数据能力的限制，导致他们在应用过程中体现出一些不同。

首先，HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求：GET把参数包含在**URL**中，POST通过**消息体**传递参数。GET主要是用来获取新的网页；POST用作向服务器传递用户的表单数据，如用户名、密码、留言等等。

其次，GET和POST参数大小的限制不同：GET请求在URL中传送的参数是有长度限制的，而POST通过**消息体**传递的参数没有长度限制。

此外，GET和POST还有一个**重大区别**：GET产生一个TCP数据包，而POST产生两个TCP数据包。

对于GET请求，浏览器会把请求头和消息体一并发送出去，服务器响应200 ok（返回数据）；而对于POST请求，浏览器先发送请求头，服务器响应100 continue后，浏览器再发送消息体，服务器响应200 ok（返回数据）。

其他的区别：GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留；对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

------

POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效，因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？

1. GET与POST都有自己的语义，不能随便混用。
2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。
3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

[GET和POST两种基本请求方法的区别 - 在途中# - 博客园 (cnblogs.com)](https://www.cnblogs.com/logsharing/p/8448446.html)

## HTTP（1.1）特性

### 优缺点

- **优点**

1. **简单**

HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，很简单。

2. **灵活和易于扩展**

HTTP协议里的各类请求方法、状态码、头字段等都是可以自定义扩展的；同时 HTTP 工作在应用层，下层可以随意变化。

3. **应用广泛和跨平台**

- **缺点**

1. **无状态**

服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，但是会导致它在完成有关联性的操作时会非常麻烦。例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。 但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。

无状态的问题解决方法有`cookie/session/token`，`Cookie` 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。

2. **明文传输**

明文意味着在传输过程中的信息是可阅读的， 通过F12 控制台或 Wireshark 抓包都可以直接查看， 方便调试，但是也导致了信息泄露。明文传输的问题在`https`协议中得到了解决。

3. **不安全**

HTTP 比较严重的缺点就是不安全：通信使用明文传输，内容可能会被窃听；不验证通信方的身份，因此有可能遭遇伪装； 无法证明报文的完整性，所以有可能已遭篡改。

HTTP 的安全问题，可以用 `HTTPS`的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。

### 性能

1. **长连接**

> `HTTP/1.0` 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。 TCP连接的建立需要三次握手，通信开销比较大。所以，HTTP/1.0版本的性能比较差。

为了解决上述 TCP 连接问题，`HTTP/1.1`提出了**长连接**的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器的负载。

持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。当然，如果某个 HTTP 长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。

- **管道网络传输**

HTTP/1.1 采用了长连接的方式，这使得**管道网络传输**成为了可能。即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间**。

但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应，如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞，造成「**队头阻塞**」。所以，**HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞**。

- **队头阻塞**

当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「**队头阻塞**」。

##  HTTPS特性

### HTTP 与 HTTPS 有哪些区别？

1. HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 `SSL/TLS` 安全协议，使得报文能够加密传输。
2. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 `SSL/TLS` 的握手过程，才可进入加密报文传输。
3. HTTP 的端口号是 80，HTTPS 的端口号是 443。
4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

### HTTPS 如何解决HHTP的三个安全风险？

1. **混合加密**的方式实现信息的**机密性**，解决了**窃听**的风险；
2. 将服务器公钥放入到**数字证书**中，解决了**冒充**的风险；
3. **摘要算法**的方式来实现**完整性**，它能够为数据生成独一无二的「**指纹**」，指纹用于校验数据的完整性，解决了**篡改**的风险。

### HTTPS 的优缺点

- 优点

1. HTTPS传输数据过程中使用密钥进行加密，所以安全性更高；

2. HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器。

- 缺点

1. HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加；

2. HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高。

### HTTPS连接建立过程及SSL工作流程

SSL/TLS 协议基本流程：

- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产「会话秘钥」。
- 双方采用「会话秘钥」进行加密通信。

前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段，SSL/TLS 的「握手阶段」涉及**四次**通信。SSL/TLS 协议建立的详细流程：

1. **ClientHello**

首先，由客户端向服务器发起加密通信请求，也就是 `ClientHello` 请求。

在这一步，客户端主要向服务器发送以下信息：

（1）客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。

（2）客户端生产的随机数（`Client Random`），后面用于生成「会话秘钥」条件之一。

（3）客户端支持的密码套件列表，如 RSA 加密算法。

2. **SeverHello**

服务器收到客户端请求后，向客户端发出响应，也就是 `SeverHello`。服务器回应的内容有如下内容：

（1）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。

（2）服务器生产的随机数（`Server Random`），也是后面用于生产「会话秘钥」条件之一。

（3）确认的密码套件列表，如 RSA 加密算法。

（4）服务器的数字证书。

3. **客户端回应**

客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。

如果证书没有问题，客户端会**从数字证书中取出服务器的公钥**，然后使用它加密报文，向服务器发送如下信息：

（1）一个随机数（`pre-master key`）。该随机数会被服务器公钥加密。

（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。

**服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」**。

4. **服务器的最后回应**

服务器收到客户端的第三个随机数（`pre-master key`）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。

然后，向客户端发送最后的信息：

（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。

## HTTP/1.1、HTTP/2、HTTP/3的演变

### HTTP/1.1 相比 HTTP/1.0 提高了什么性能？

- 使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
- 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

### HTTP/2 做了什么优化？

HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

那 HTTP/2 相比 HTTP/1.1 性能上的改进：

1. **头部压缩**

HTTP/2 会**压缩头**，如果同时发出多个请求，如果请求头是一样的或是相似的，那么会消除重复的部分。

这就是所谓的 `HPACK` 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

2. **二进制格式**

HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是采用了**二进制格式**，头信息和数据体都是二进制（统称为**帧**：头信息帧和数据帧）。收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，增加了数据传输的效率。

3. **数据流**

HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。

在 HTTP/2 中每个请求或相应的所有数据包，称为一个数据流（`Stream`）。每个数据流都标记着一个独一无二的编号（Stream ID），**不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）**，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息。

4. **多路复用**

HTTP/2 可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「**队头阻塞**」问题，降低了延迟，大幅度提高了连接的利用率。

5. **服务器推送**

HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以**主动**向客户端发送消息。

### HTTP/2的缺陷

HTTP/2 还是存在**队头阻塞**的问题，只不过问题不是在 HTTP 这一层面，而是在 **TCP**这一层。

HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用。当前一个字节数据没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这一个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 **HTTP/2 队头阻塞**问题。

所以，一旦发生了丢包现象，就会触发 TCP 的**重传机制**，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。

### HTTP/3 做了哪些优化？

 HTTP/1.1 和 HTTP/2 都有队头阻塞的问题：

- HTTP/1.1 中的管道虽然解决了请求的队头阻塞，但是**没有解决响应的队头阻塞**，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等相应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。
- HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是**一旦发生丢包，就会阻塞住所有的 HTTP 请求**，这属于 TCP 层队头阻塞。

HTTP/2 队头阻塞的问题是因为 TCP，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP**。

UDP的发生是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。虽然 UDP 是不可靠传输的，但基于 UDP 的 **QUIC 协议** 可以实现类似 TCP 的可靠性传输。QUIC 有以下 3 个特点：

1. **无队头阻塞**

QUIC 连接上**当某个数据流发生丢包时，只会阻塞这个数据流，其他数据流不会受到影响，因此不存在队头阻塞问题**。这与 HTTP/2 不同，HTTP/2 只要某个数据流中的数据包丢失了，其他数据流也会因此受影响。

2. **更快的连接建立**

但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商。

3. **连接迁移**

基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接，那么**当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接**。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。

而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过**连接 ID**来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了**连接迁移**的功能。

所以， QUIC 是一个在 UDP 之上的**伪** TCP + TLS + HTTP/2 的多路复用的协议。

QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。

所以，HTTP/3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。

