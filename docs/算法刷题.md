# 🔥算法刷题

🐷🐹🐰🦄🐸🐲🦧🐒🐾🐈🐈‍⬛🐅

# 一、二叉树

## 解题方法

1️⃣ 遇到二叉树的题目，如何去思考？或者说有没有思考的框架呢？

- **是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

- **是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「**分解问题**」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

2️⃣ 如何正确地理解**前中后序遍历**呢？

**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：

- 前序位置的代码在刚刚进入一个二叉树节点的时候执行；
- 后序位置的代码在将要离开一个二叉树节点的时候执行；
- 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204170940278.png" alt="image-20220417094016966" style="zoom:50%;" /></div>

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204170942506.png" alt="image-20220417094235414" style="zoom:60%;" /></div>

3️⃣前序位置和后序位置的代码有什么区别？后序位置有什么特殊之处？

前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到**子树**通过函数返回值传递回来的数据。

🔥总结：二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，**你只需要单独思考每一个节点应该做什么**，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

## 👉二叉树深度

### 104、求二叉树最大深度

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数，叶子节点是指没有子节点的节点。

**示例：** 
给定二叉树`[3,9,20,null,null,15,7]`，

```php
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3。

**解法一**：递归遍历二叉树，回溯算法思路

遍历一遍二叉树，用一个外部变量记录**每个节点**所在的深度，取最大值就可以得到最大深度。

```php
class Solution {
public:
    int depth = 0;
    int res = 0;
    int maxDepth(TreeNode* root) {
        traverse(root);
        return res;
    }
    //遍历二叉树
    void traverse(TreeNode* root){
		if(root == nullptr){
            return;
        }
        //前序遍历位置
        depth++;
        //遍历过程中记录最大深度
        res = max(depth, res);
        traverse(root->left);
        traverse(root->right);
        //后序遍历位置
        depth--;
    }
};
```

**解法二**：分解成子树问题，动态规划思路

```php
class Solution {
public:
    // 定义：输入一个节点，返回以该节点为根的二叉树的最大深度
    int maxDepth(TreeNode* root) {
		if(root == nullptr){
            return 0;
        }
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        // 根据左右子树的最大深度推出原二叉树的最大深度
        return max(leftDepth, rightDepth) + 1;
    }
};
```

**解法三**：层序遍历

```php
class Solution {
public:
    int maxDepth(TreeNode* root) {
		int depth = 0;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth++;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

求二叉树的最大深度可以延伸到求二叉树的直径：

### 543、二叉树直径

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**
给定二叉树

```php
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

每一条二叉树的「**直径**」长度，就是一个节点的左右子树的**最大深度之和**。把计算「直径」的逻辑放在**后序位置**，准确说应该是放在 `maxDepth` 的后序位置，因为 `maxDepth` 的后序位置是知道左右子树的最大深度的。

```php
class Solution {
public:
    int maxDiameter = 0;
    int diameterOfBinaryTree(TreeNode* root) {
		maxDepth(root);
        return maxDiameter;       
    }
    
    //定义：输入一个节点，返回以该节点为根节点的二叉树的深度
    int maxDepth(TreeNode* root){
		if(root == nullptr){
            return 0;
        }
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        // 后序位置，顺便计算最大直径
        maxDiameter = max(leftDepth + rightDepth, maxDiameter);
        return max(leftDepth, rightDepth) + 1;
    }
};
```

### 111、二叉树的最小深度

给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**示例**：给定二叉树`[3，9，20，null，null，15，7]`：

```php
      3
     / \
    9  20
       / \     
      15  7    
```

返回它的最小深度2。

**解法一**：分解成子树问题，动态规划思想

```php
class Solution {
public:
    //定义：输入一个节点，返回以该节点为根节点的二叉树的最小深度
    int minDepth(TreeNode* root) {
		if(!root) {
            return 0;
        }
        int leftDepth = minDepth(root->left);
        int rightDepth = minDepth(root->right);
        return min(leftDepth, rightDepth) + 1;        
    }    
};
```

❓**上面的算法对吗？为什么？**

❎错误！这个代码就犯了此图中的误区：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171128504.png" alt="111.二叉树的最小深度" style="zoom:50%;" /></div>

如果这么求的话，**没有左孩子的分支会算为最短深度**。

所以，如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度；

反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度；

最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。

✅**正确的解法一**：分解成子树问题，动态规划思想

```php
class Solution {
public:
    int minDepth(TreeNode* root) {
		if(!root){
            return 0;
        }
        int leftDepth = minDepth(root->left);
        int rightDepth = minDepth(root->right);
        if(!root->left){
            return rightDepth + 1;
        }
        if(!root->right){
            return leftDepth + 1;
        }
        return min(leftDepth, rightDepth) + 1;
    }
};
```

**解法二**：层序遍历

```php
class Solution {
public:
    int minDepth(TreeNode* root) {
		int depth = 0;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth++;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(!node->left && !node->right) return depth;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

### 110、平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

**示例 ：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202031331.jpeg" alt="img" style="zoom: 60%;" /></div>

```php
输入：root = [3,9,20,null,null,15,7]
输出：true
```

本题依然是二叉树深度相关的题目，依然是把计算「高度差」的逻辑放在**后序位置**，准确说应该是放在 `maxDepth` 的后序位置，因为 `maxDepth` 的后序位置是知道左右子树的最大深度的。

只计算一次最大深度，计算的过程中在**后序遍历位置**顺便判断二叉树是否平衡：对于每个节点，先算出来左右子树的最大高度，然后在后序遍历的位置根据左右子树的最大高度判断平衡性。

```php
class Solution {
public:
    // 记录二叉树是否平衡
    bool balance = true;

    bool isBalanced(TreeNode* root) {
        maxDepth(root);
        return balance;
    }
	// 定义：输入一个节点，返回以该节点为根的二叉树的最大深度
    int maxDepth(TreeNode* root){
        if(!root) return 0;
        int leftDepth= maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        if(abs(leftDepth - rightDepth) > 1) balance = false;
        return max(leftDepth, rightDepth) + 1;
    }
};
```

## 🦁翻转二叉树

**226、翻转二叉树**

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171844420.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**解法一**：递归遍历，回溯算法的思想

遍历二叉树的每个节点，每个节点的左、右子树交换位置。

```php
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
		traverse(root);
        return root;
    }
    // 二叉树遍历函数
    void traverse(TreeNode* root){
        if(!root){
            return;
        }
        // 每一个节点需要做的事就是交换它的左右子节点
        TreeNode* tmp = root->left;
        root->left = root->right;
        root->right = tmp;
        // 遍历框架，去遍历左右子树的节点
        traverse(root->left);
        traverse(root->right);
    }
};
```

**解法二**：分解为子树的问题，动态规划思想

用 `invertTree(x.left)` 先把 `x` 的左子树翻转，再用 `invertTree(x.right)` 把 `x` 的右子树翻转，最后把 `x` 的左右子树交换，这恰好完成了以 `x` 为根的整棵二叉树的翻转，即完成了 `invertTree(x)` 的定义。

```php
class Solution {
public:
    //定义：输入一个节点，将以该节点为根节点的二叉树进行翻转，返回其根节点
    TreeNode* invertTree(TreeNode* root) {
		if(!root) {
            return root;
        }
        // 利用函数定义，先翻转左右子树
        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);
        // 然后交换左右子节点
		root->left = right;
        root->right = left;
        return root;
    }    
};
```

**解法三**：层序遍历

```php
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();              // 中
            st.pop();
            swap(node->left, node->right);
            if(node->right) st.push(node->right);   // 右
            if(node->left) st.push(node->left);     // 左
        }
        return root;
    }
};
```

## 🐷路径总和

### 112、路径总和

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221122861.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**解法一**：递归遍历，回溯算法思想

前部遍历位置（进入节点）`sum += root->val`，顺便判断是否到达叶子节点且和为`targetSum`；后序遍历位置（离开节点）`sum -= root->val`。

```php
class Solution {
public:
    bool res = false;
    int sum = 0;
    bool hasPathSum(TreeNode* root, int targetSum) {
        traverse(root, targetSum);
        return res;
    }

    void traverse(TreeNode* root, int targetSum){
        if(!root) return;
        //前序遍历位置
        sum += root->val;
        // 到达叶子节点且和为targetSum
        if(!root->left && !root->right && sum == targetSum) res = true;
        traverse(root->left, targetSum);
        traverse(root->right, targetSum);
        //后序遍历位置
        sum -= root->val;
    }
};
```

**解法二**：分解成子树问题，动态规划思想

遍历到一个节点，继续遍历左孩子和右孩子，且targetSum减去节点的数值。

```php
class Solution {
    
public:
    // 定义：输入一个根节点，返回该根节点到叶子节点是否存在一条和为 targetSum 的路径
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return false;
        if(!root->left && !root->right && root->val == targetSum) return true;
        // 左子树或者右子树有一个满足即可
        return hasPathSum(root->left, targetSum - root->val) ||
                hasPathSum(root->right, targetSum - root->val);
    }
};
```

### 113、路径总和ii

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221122861.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
```

相对于⌈**112、路径总和**⌋来说，前序和后序位置不仅要维护`sum`，还要维护路径`path`。

```php
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    int sum = 0;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        traverse(root, targetSum);
        return res;
    }

    void traverse(TreeNode* root, int targetSum){
        if(!root) return;
        //前序遍历位置
        sum += root->val;
        path.push_back(root->val);
        if(!root->left && !root->right && sum == targetSum) res.push_back(path);
        traverse(root->left, targetSum);
        traverse(root->right, targetSum);
        //后序遍历位置
        sum -= root->val;
        path.pop_back();
    }
};
```

### 437、路径总和iii

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221609909.jpeg" alt="img" style="zoom: 50%;" /></div>

```php
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```











## 🐹二叉树是否对称/相等

**101、对称二叉树**和**100、相同的树**结合起来看，两道题方法和代码上非常相似。

### 101、对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201633364.png" alt="101. 对称二叉树" style="zoom:60%;" /></div>

**解法一**：分解成子树问题

对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了**其实我们要比较的是两颗树（这两颗树是根节点的左右子树）**，所以在递归遍历的过程中，也是要同时遍历两棵树。

正是因为要遍历两棵树而且要**比较内侧和外侧节点**，所以准确的来说是一个树的遍历顺序是**左右中**，一个树的遍历顺序是**右左中**，只有内侧和外侧节点分别对应相等，这两棵树才是对称的。

**返回条件**：

- 左节点为空，右节点不为空，不对称，return false；
- 左不为空，右为空，不对称 return false；
- 左右都为空，对称，返回true；
- 左右都不为空，比较节点数值，不相同就return false；
- 左右节点相等的话，再递归判断子节点；

代码如下：

```php
if (left == NULL && right != NULL) return false;
else if (left != NULL && right == NULL) return false;
else if (left == NULL && right == NULL) return true;
else if (left->val != right->val) return false;
```

```php
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
		return compare(root->left, root->right);
    }
    //定义：输入左、右节点，返回分别以这两节点为根节点的二叉树是否对称
    bool compare(TreeNode* left, TreeNode* right){
        // 注意这里终止条件的代码
        if(!left || !right) return left == right;
        if(left->val != right->val) return false;
        bool outside = compare(left->left, right->right);	//外侧节点比较
        bool inside = compare(left->right, right->left);	//内侧节点比较
        return outside && inside;	//左右子节点需要对称相同
	}
};
```

代码简化为：

```php
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
		return compare(root->left, root->right);
    }
    //定义：输入左、右节点，返回分别以这两节点为根节点的二叉树是否对称
    bool compare(TreeNode* left, TreeNode* right){
        // 该对节点是否对称
        if(!left || !right) return left == right;
        if(left->val != right->val) return false;
        // 其他节点是否对称
        return compare(left->left, right->right) && compare(left->right, right->left);
	}
};
```

**解法二**：迭代法，不是层序遍历，这里我们可以使用**队列**来比较两个树（根节点的左右子树）是否相互翻转。

把左右两个子树要比较的元素顺序放进一个容器，然后**成对**的取出来进行比较，那么其实使用**栈**也是可以的。

```php
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        
        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }
            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```

### 100、相同的树

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201830207.jpeg" alt="img" style="zoom:60%;" /></div>

```php
输入：p = [1,2,3], q = [1,2,3]
输出：true
```

解法一：分解成子树问题

```php
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p || !q) return p == q;
        if(p->val != q->val) return false;
        bool left = isSameTree(p->left, q->left);	//比较左子树
        bool right = isSameTree(p->right, q->right);//比较右子树
        return left && right;
    }
};
```

代码简化为：

```php
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // 判断一对节点是否相同
        if(!p || !q) return p == q;
        if(p->val != q->val) return false;
        // 判断其他节点是否相同
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

**解法二**：迭代法

```php
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        queue<TreeNode*> que;
        que.push(p);
        que.push(q);
        //注意不能加上写成如下代码，否则会报错
        //if(p) que.push(p);   
        //if(q) que.push(q);  
        while (!que.empty()) {  // 接下来就要判断这两颗树是否相等
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是相等的
                continue;
            }
            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   
            que.push(rightNode->left); 
            que.push(leftNode->right);  
            que.push(rightNode->right); 
        }
        return true;
    }
};
```

**注意**：

```php
que.push(p);
que.push(q);
```

不能写为：

```
if(p) que.push(p);   
if(q) que.push(q);  
```

否则会报错：

```php
执行出错信息：
Line 15: Char 74: runtime error: member access within misaligned address 0xbebebebebebebebe for type 'TreeNode', which requires 8 byte alignment (solution.cpp)
0xbebebebebebebebe: note: pointer points here
<memory cannot be printed>
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:74
最后执行的输入：
[]
[0]
```

加上`if`判断后，若输入当中有为空的，则无法加入到队列当中，影响后序的代码逻辑运行。

### 572、另一个树的子树

给你两棵二叉树 `root` 和 `subRoot` ，检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。

二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点，`tree` 也可以看做它自身的一棵子树。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201953856.jpeg" alt="img" style="zoom:50%;" /></div>

```
输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
```

遍历以 `root` 为根的这棵二叉树的所有节点，用 ⌈**100、相同的树**⌋ 中的 `isSameTree` 函数判断以该节点为根的子树是否和以 `subRoot` 为根的那棵树相同。

```php
class Solution {
public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
		if(!root) return root == subRoot;
        // 判断以 root 为根的二叉树是否和 subRoot 相同
        if(isSameTree(root, subRoot)) return true;
        // 去左右子树中判断是否有和 subRoot 相同的子树
        return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);
    }
    // 定义：输入两个节点，判断以两个节点为根节点的二叉树是否一样，返回结果
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // 判断一对节点是否相同
        if(!p || !q) return p == q;
        if(p->val != q->val) return false;
        // 判断其他节点是否相同
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

### 617、合并二叉树

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221505893.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
```

```php
class Solution {
public:
    //定义：输入两二叉树根节点，返回二叉树处理后的根节点
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(!root1) return root2;
        if(!root2) return root1;
        root1->val += root2->val; 
        root1->left = mergeTrees(root1->left, root2->left);
        root1->right = mergeTrees(root1->right, root2->right);
        return root1;
    }
};
```

## 🐅左叶子/左下角问题

### 404、左叶子之和

给定二叉树的根节点 `root` ，返回所有左叶子之和。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202035803.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

**首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。**

本题遍历二叉树即可，问题是如何判断节点是**左叶子**呢？

**如果左节点不为空，且左节点没有左右孩子，那么这个节点的左节点就是左叶子**，必须要通过节点的父节点来判断其左孩子是不是左叶子：

```php
if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) {
    左叶子节点处理逻辑
}
```

```php
class Solution {
public:
    int sum = 0;
    
    int sumOfLeftLeaves(TreeNode* root) {
        traverse(root);
        return sum;
    }
    
    void traverse(TreeNode* root){
        if(!root) return;
        // 找到左侧的叶子节点，记录累加值
        if(root->left && !root->left->left && !root->left->right){
            sum += root->left->val;
        }
        traverse(root->left);
        traverse(root->right);
    }
};
```

### 513、找树左下角的值

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204212053339.jpeg" alt="img" style="zoom:60%;" /></div>

```
输入: root = [2,1,3]
输出: 1
```

**解法一**：递归遍历二叉树

二叉树递归框架代码是先递归左子树，后递归右子树，所以**到最大深度时第一次遇到的节点就是左下角的节点**。

```php
class Solution {
public:
    int depth;		// 记录 traverse 递归遍历到的深度
    int maxDepth;	// 记录二叉树的最大深度
    TreeNode* res;

    int findBottomLeftValue(TreeNode* root) {
        traverse(root);
        return res->val;
    }

    void traverse(TreeNode* root){
        if(!root) return;
        depth++;
        // 到最大深度时第一次遇到的节点就是左下角的节点
        if(depth > maxDepth){
            maxDepth = depth;
            res = root;
        }
        traverse(root->left);
        traverse(root->right);
        depth--;
    }
};
```

**解法二**：层序遍历，很好理解

```php
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        int result = 0;	//后续循环会不断刷新result的值
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (i == 0) result = node->val; // 记录最后一行第一个元素
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

找树左下角的值会做了，找树右下角的值自然也会做了，也就是把遍历的顺序改变一下：先遍历右子树，再遍历左子树。



## 🐈‍⬛完全二叉树的节点个数

**222、完全二叉树的节点个数**

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202028146.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,3,4,5,6]
输出：6
```

首先要搞清楚什么是 ⌈**完全二叉树**⌋ 和 ⌈**满二叉树**⌋ ：

**完全二叉树**如下图，每一层都是紧凑靠左排列的，除了最底层节点可能没填满外，其余每层节点数都达到最大值：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211628453.png" alt="img" style="zoom:50%;" /></div>

**满二叉树**如下图，是一种特殊的完全二叉树，每层都是是满的，像一个稳定的三角形：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211629053.png" alt="img" style="zoom:80%;" /></div>

如果是一个**普通**二叉树，显然只要向下面这样遍历一边即可，时间复杂度 O(N)：

```php
int countNodes(TreeNode* root) {
    if (root == null) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}
```

那如果是一棵**满**二叉树，节点总数就和树的高度呈指数关系：

```php
int countNodes(TreeNode* root) {
    int h = 0;
    // 计算树的高度
    while (root != null) {
        root = root->left;
        h++;
    }
    // 节点总数就是 2^h - 1
    return (2 << h) - 1;
}
```

**完全**二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版。

完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。

对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。

对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211649576.png" alt="image-20220421164919517" style="zoom:60%;" /></div>

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211652510.png" alt="image-20220421165226452" style="zoom:40%;" /></div>

可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。

```php
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (!root) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        // 这里初始为0是有目的的，为了下面求指数方便
        int leftHeight = 0;
        int rightHeight = 0; 
        // 记录左、右子树的高度
        while (left) {
            left = left->left;
            leftHeight++;
        }
        while (right) {
            right = right->right;
            rightHeight++;
        }
        // 如果左右子树的高度相同，则是一棵满二叉树
        if (leftHeight == rightHeight) {
            return (2 << leftHeight) - 1; // 注意(2<<1) 相当于2^2，所以leftHeight初始为0
        }
        // 如果左右高度不同，则按照普通二叉树的逻辑计算
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

这个算法的时间复杂度是 `O(logN*logN)`，但直觉感觉好像最坏情况下是 O(N*logN) ，因为之前的 while 需要 logN 的时间，最后要 O(N) 的时间向左右子树递归：

```php
return 1 + countNodes(root.left) + countNodes(root.right);
```

**关键点在于，这两个递归只有一个会真的递归下去，另一个一定会触发 `leftHeight == rightHeight` 而立即返回，不会递归下去**。

所以，算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logN*logN)。

## 🐾二叉树展开为链表

**114、二叉树展开为链表**

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 前序遍历 顺序相同。

**示例 ：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171905704.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**解法一**：递归遍历

对整棵树进行前序遍历，一边遍历一边构造出一条「链表」。

```php
class Solution {
public:
    // 虚拟头节点，res->right 就是结果
    TreeNode* res = new TreeNode(-1);
    // 用来构建链表的指针
    TreeNode* p = res;
    TreeNode* flatten(TreeNode* root) {
        traverse(root);
        return res->right;
    }
    
    void traverse(TreeNode* root){
		if(!root) return;
        p = new TreeNode(root->val);
        p = p->right;
        traverse(root->left);
        traverse(root->right);
    }
};
```

但是注意 `flatten` 函数的签名，返回类型为 `void`，也就是说题目希望我们在原地把二叉树拉平成链表。

这样一来，没办法通过简单的二叉树遍历来解决这道题了。

**解法二**：分解成子树的问题

对于一个节点 `x`，可以执行以下流程：

1、先利用 `flatten(x.left)` 和 `flatten(x.right)` 将 `x` 的左右子树拉平。

2、将 `x` 的右子树接到左子树下方，然后将整个左子树作为右子树。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171948600.png" alt="image-20220417194832538" style="zoom:50%;" /></div>

这样，以 `x` 为根的整棵二叉树就被拉平了，恰好完成了 `flatten(x)` 的定义。

```php
class Solution {
public:
    //定义：输入一个节点，将以该节点为根节点的二叉树展开成单链表
    void flatten(TreeNode* root) {
		if(!root) return;
        // 利用定义，把左右子树拉平
        flatten(root->left);
        flatten(root->right);
        // 1、左右子树已经被拉平成一条链表
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        // 2、将左子树作为右子树
        root->left =  nullptr;
        root->right = left;
        // 3、将原先的右子树接到当前右子树的末端
        TreeNode* p = root;
        // 注意这里的条件是 p->right，而不是 p ，即有右孩子则移动指针
        while(p->right){
            p = p->right;
        }
        p->right = right;
    }
};
```

## 🦄填充每个节点的下一个右侧节点指针

**116、填充每个节点的下一个右侧节点指针**

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```php
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

**示例 1：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171958858.png" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
```

这道题若使用**常规的**遍历二叉树的话，只能将一个节点的左子树指向右子树，**不同节点的子树之间无法建立联系**，所以要改变遍历的方式。传统的 `traverse` 函数是遍历二叉树的所有节点，但现在我们想遍历的其实是两个相邻节点之间的「**空隙**」，所以可以在二叉树的基础上进行抽象，把图中的每一个方框看做一个节点：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204172004189.png" alt="img" style="zoom:30%;" /></div>

**解法一**：递归遍历二叉树

**这样，一棵二叉树被抽象成了一棵三叉树，三叉树上的每个节点就是原先二叉树的两个相邻节点**。

现在，我们只要实现一个 `traverse` 函数来遍历这棵三叉树，每个「三叉树节点」需要做的事就是把自己内部的两个二叉树节点穿起来。这样，`traverse` 函数遍历整棵「三叉树」，将所有相邻节的二叉树节点都连接起来，也就避免了我们之前出现的问题，把这道题完美解决。

```php
class Solution {
public:
    Node* connect(Node* root) {
        if(!root) return root;
        traverse(root->left, root->right);
        return root;
    }
    // 三叉树遍历框架
    void traverse(Node* node1, Node* node2){
        if(!node1 || !node2){
            return;
        }
        node1->next = node2;
        traverse(node1->left, node1->right);
        traverse(node2->left, node2->right);
        traverse(node1->right, node2->left);
    }
};
```

**解法二**：层序遍历

在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204182056966.png" alt="填充每个节点的下一个右侧节点指针.drawio.png" style="zoom:70%;" /></div>

核心代码逻辑为：

- 遍历到每一层的第一个节点时，用pre记录该节点，然后节点出队，node记录pre；

- 向后每遍历一个节点，用node记录该节点，然后节点出队，**pre指向node**，pre指针向后移动一位；

- 该层最后一个节点指向nullptr；

```php
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if (root != NULL) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            Node* nodePre;
            Node* node;
            for (int i = 0; i < size; i++) {
                if (i == 0) {
                    pre = que.front(); // 取出一层的头结点
                    que.pop();
                    node = pre;
                } else {
                    node = que.front();
                    que.pop();
                    pre->next = node; // 本层前一个节点next指向本节点
                    pre = pre->next;
                }
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            nodePre->next = NULL; // 本层最后一个节点指向NULL
        }
        return root;
    }
};
```

## 🐰寻找重复的子树

**652、寻找重复的子树**

给定一棵二叉树 root，返回所有重复的子树。

对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。

如果两棵树具有相同的结构和相同的结点值，则它们是重复的。

**示例**：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204172024286.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,3,4,null,2,4,null,null,4]
输出：[[2,4],[4]]
```

如何知道以某个节点为根的子树是不是重复的，是否应该加入结果列表中，需要知道什么信息呢？

**你需要知道以下两点**：

1、以我为根的这棵二叉树（子树）长啥样？——**后序遍历**

2、以其他节点为根的子树都长啥样？——利用哈希表存起来做比较

现在，明确了要用后序遍历，那应该怎么描述一棵二叉树的模样呢？二叉树的前序/中序/后序遍历结果可以描述二叉树的结构。所以，可以通过**拼接字符串**的方式把二叉树**序列化**。

```php
class Solution {
public:
    unordered_map<string, int> map;
    vector<TreeNode*> res;
    
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
		traverse(root);
        return r
    }
    //定义：输入一个节点，将以该节点为根节点的二叉树序列化，返回序列化后的字符串
    string traverse(TreeNode* root){
		if(!root) return "#";
        string left = traverse(root->left);
        string right = traverse(root->right);
        // 后序位置获取二叉树序列化后的字符串
        string str = left + "," + right + "," + to_string(root->val);
        if(map[str] == 1){
            res.push_back(root);
        }
        map[str]++;
        return str;
    }
};
```

## 🐸构造二叉树

😶‍🌫️二叉树的构造问题一般都是使用「**分解问题**」的思路：**构造整棵树 = 根节点 + 构造左子树 + 构造右子树**。

### 654、构造最大二叉树

给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 `nums` 构建的**最大二叉树**。

**示例**：

```php
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
               6
             /  \
            3    5
             \   /      
              2 0   
               \
                1
```

首先遍历数组把找到最大值 `maxVal`，从而把根节点 `root` 构造出来，然后对 `maxVal` 左边的数组和右边的数组进行递归构建，作为 `root` 的左、右子树。

```php
//定义二叉树
struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x):val(x), left(nullptr), right(nullptr){}
}

class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
		return build(nums, 0, nums.size() - 1);
    }
    
    //定义：输入数组和区间左右端点，返回构造的最大二叉树的根节点
    TreeNode* build(vector<int>& nums, int lo, int hi){
        if(lo > hi){
            return nullptr;
        }
        // 找到数组中的最大值和对应的索引
        // 注意不能写成 int rootVal = 0;
        int rootVal = INT32_MIN;
        int index = 0;
        for(int i = lo; i <= hi; i++){
			if(rootVal < nums[i]){
                rootVal = nums[i];
                index = i;
            }
        }
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(nums, lo, index - 1);
        root->right = build(nums, index + 1, hi);
        return root;
    }
};
```

### 105、从前序与中序遍历序列构造二叉树

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

```php
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171505952.jpeg" alt="img" style="zoom: 67%;" /></div>

前序遍历`preorder` 和 中序遍历`inorder` 数组中的元素分布有如下特点：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171510562.png" alt="image-20220417151011413" style="zoom:80%;" /></div>

找到根节点是很简单的，前序遍历的第一个值 `preorder[0]` 就是根节点的值。关键在于如何通过根节点的值，将 `preorder` 和 `postorder` 数组划分成两半，构造根节点的左右子树？

**暴力**方法是利用for循环遍历整个数组找出`index`，但是通过 for 循环遍历的方式去确定 `index` 效率不算高，可以进一步优化：采用**哈利表**的查到 `rootVal` 对应的 `index`，数组元素无序且不重复，故采用 `unordered_map`来实现，底层由**哈希表**实现。

本道题的一大**难点**在于如何确定左右数组对应的起始索引和终止索引，这个可以通过左子树的节点数推导出来，假设左子树的节点数为 `leftSize`，那么 `preorder` 数组上的索引情况是这样的：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171511724.png" alt="image-20220417151152530" style="zoom:60%;" /></div>

做这种题目一定要画示意图，选择闭区间，若索引填错了，就会引起栈溢出的错误。

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
		int size = inorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[inorder[i]] = i;
        }
        return build(preorder, 0, size - 1, inorder, 0, size - 1);
    }
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd, 
                    vector<int>& inorder, int inStart, int inEnd){
    	if(preStart > preEnd){
            return nullptr;
        }
        //根节点的值
        int rootVal = preorder[preStart];
        //利用哈希表查询到 rootVal 在 inorder 中的索引 index
        int index = map[rootVal];
        
        int leftSize = index - inStart;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(preorder, preStart + 1, preStart + leftSize, 
                          inorder, inStart, index - 1);
    	root->right = build(preorder, preStart + leftSize + 1, preEnd,
                           inorder, index + 1, inEnd);
    	return root;
    }
};
```

### 106、从中序与后序遍历序列构造二叉树

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。

```php
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
```

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171505952.jpeg" alt="img" style="zoom: 67%;" /></div>

 `postoder` 和 `inorder` 对应的状态如下：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171615448.png" alt="image-20220417161545340" style="zoom:60%;" /></div>

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
		int size = inorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[inorder[i]] = i;
        }
        return build(inorder, 0, size - 1, postorder, 0, size - 1);
    }
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& inorder, int inStart, int inEnd, 
                    vector<int>& postorder, int postStart, int postEnd){
    	if(postStart > postEnd){
            return nullptr;
        }
        //根节点的值
        int rootVal = postorder[postEnd];
        //利用哈希表查询到 rootVal 在 inorder 中的索引 index
        int index = map[rootVal];
        
        int leftSize = index - inStart;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(inorder, inStart, index - 1, 
                          postorder, postStart, postStart + leftSize - 1);
    	root->right = build(inorder, index + 1, inEnd,
                           postorder, postStart + leftSize, postEnd - 1);
    	return root;
    }
};
```

### 889、根据前序和后序遍历构造二叉树

给定两个整数数组，`preorder` 和 `postorder` ，其中 `preorder` 是一个具有 **无重复** 值的二叉树的前序遍历，`postorder` 是同一棵树的后序遍历，重构并返回二叉树。

如果存在多个答案，您可以返回其中 **任何** 一个。

```php
输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
输出：[1,2,3,4,5,6,7]
```

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171628354.jpeg" alt="img" style="zoom:60%;" /></div>

这道题和前两道题有一个本质的区别：

**通过前序中序，或者后序中序遍历结果可以确定一棵原始二叉树，但是通过前序后序遍历结果无法确定原始二叉树**。这道题，你可以确定根节点，但是无法确切的知道左右子树有哪些节点，以下是一种构造方法：

1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值。

2、然后把前序遍历结果的第二个元素作为左子树的根节点的值。

3、在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可。

假设前序遍历的第二个元素是左子树的根节点，但实际上左子树有可能是空指针，那么这个元素就应该是右子树的根节点。由于这里无法确切进行判断，所以导致了最终答案的不唯一。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171639321.png" alt="image-20220417163947215" style="zoom:70%;" /></div>

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {
		int size = postorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[postorder[i]] = i;
        }
        return build(preorder, 0, size - 1, postorder, 0, size - 1);
    }
    
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd, 
                    vector<int>& postorder, int postStart, int postEnd){
    	if(postStart > postEnd){
            return nullptr;
        }
        if(postStart == postEnd){
            return new TreeNode(postorder[postStart]);
        }
        //根节点的值
        int rootVal = preorder[preStart];
        int leftRootVal = preorder[preStart + 1];
        //利用哈希表查询到左子树根节点 leftRoot 在 postorder 中的索引 index
        int index = map[leftRootVal];
        
        int leftSize = index - postStart + 1;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(preorder, preStart + 1, preStart + leftSize, 
                          postorder, postStart, index);
    	root->right = build(preorder, preStart + leftSize + 1, preEnd,
                           postorder, index + 1, postEnd - 1);
    	return root;
    }
};
```

## 🦊层序遍历

### 102、二叉树的层序遍历

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181828285.png" alt="102.二叉树的层序遍历" style="zoom:50%;" /></div>

需要借用一个辅助数据结构即**队列**来实现，队列**先进先出**，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。

while循环用来从上到下遍历二叉树的每一层，for循环用来从左到右遍历每一层当中的节点。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181834096.png" alt="image-20220418183400018" style="zoom:50%;" /></div>

```php
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

### 107、二叉树的层次遍历II

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181838870.png" alt="107.二叉树的层次遍历II" style="zoom:55%;" /></div>

相对于102.二叉树的层序遍历，就是最后把`result`数组反转一下就可以了。

```php
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        reverse(result.begin(), result.end()); // 在这里反转一下数组即可
        return result;
    }
};
```

### 515、在每个树行中找最大值

给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204190917513.png" alt="515.在每个树行中找最大值" style="zoom:60%;" /></div>

**解法一**：递归遍历二叉树

我们先来思考这样一个问题：如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？

`traverse`遍历函数的参数当中只包含`TreeNode* root `可以吗？**不行！**还要加上节点所在的层数`level`，因为在递归遍历的过程中，遍历左子树接着遍历右子树，层数leve并不是一直增加，同一层的节点level是一样的，所以不能定义全局变量，而是要放在`traverse`函数参数当中维护。

**如果要在遍历二叉树的过程中获取每个节点所在的层数，则要在`traverse`遍历函数的参数当中添加层数`level`。**

```php
// 定义：二叉树遍历函数，输入一个节点和该节点所在的层数
void traverse(TreeNode root, int level) {
    if (root == null) {
        return;
    }
    // 前序位置
    printf("节点 %s 在第 %d 层", root, level);
    //注意如下代码中的 level + 1
    traverse(root.left, level + 1);
    traverse(root.right, level + 1);
}

// 人为设定根节点位于第1层
traverse(root, 1);
```

回到本题当中，本质上是一个求节点最大值的问题，但问题是**如何保证参与比大小求最值的节点来自于同一层呢**？

🥳在遍历二叉树的过程中获取每一个节点所在的层数，比较层数就可以了呀，也就是说**这是一个涉及二叉树层数的问题，要在`traverse`遍历函数的参数当中添加层数`level`。**

假设二叉树的层数从第0层开始算，res数组所以默认从0开始：

- 假设数组遍历到二叉树第2层某节点，而res数组当中只有**2**个元素（已获取前两层的最大值），即`level == res.size()`，表示res数组当中无该层任何节点，**将该节点添加到res数组中**；

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191022409.png" alt="image-20220419102205366" style="zoom:60%;" /></div>

- 假设数组遍历到二叉树第2层某节点，而res数组当中只有**3**个元素（已获取前三层的最大值），表示该层已经有节点被访问了，则**比大小取最值**；

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191022406.png" alt="image-20220419102248364" style="zoom:60%;" /></div>

所以也就是说，核心代码逻辑要使用`if`语句分以上两种情况讨论。

```php
class Solution {
public:
	vector<int> res;
    void traverse(TreeNode* root,int level){
        if(root == NULL){
            return;
        }
        if(level == res.size()){//每层第一个节点
            res.push_back(root->val);
        } else{					//每层第一个节点之外的节点
            res[level] = max(res[level], root->val);
        } 
        traverse(root->left, level + 1);
        traverse(root->right, level + 1);
    }
    vector<int> largestValues(TreeNode* root) {
        //二叉树层数从第0层开始算
        traverse(root,0);
        return res;
    }
};
```

**解法二**：层序遍历

层序遍历，取每一层的最大值。

- while循环开始遍历每一层时，创建最大值`maxValue`；
- for循环遍历该层每一个节点，顺便更新`maxValue`；
- 退出for循环，该层所有节点遍历完成，`maxValue`放入结果数据`result`中；

```php
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<int> result;
        while (!que.empty()) {
            int size = que.size();
            int maxValue = INT_MIN; // 取每一层的最大值
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                maxValue = node->val > maxValue ? node->val : maxValue;
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(maxValue); // 把最大值放进数组
        }
        return result;
    }
};
```

### 199、二叉树的右视图

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191815468.png" alt="199.二叉树的右视图" style="zoom:55%;" /></div>

**解法一**：递归遍历

要找到每一层最右边的节点，涉及**二叉树节点所在层数**的问题，还是使用 ⌈**515、在每个树行中找最大值**⌋ 中的遍历框架。

**注意**：由于本题是要找每层最右侧节点，所以**先遍历右子树再遍历左子树**，这样每层遍历时首先访问到的就是要求的节点。

```php
class Solution {
public:
    vector<int> res;

    vector<int> rightSideView(TreeNode* root) {
        traverse(root, 0);
        return res;
    }

    void traverse(TreeNode* root, int level){
        if(!root) return;
		//这一层还没有记录值，说明 root 就是右侧视图的第一个节点
        if(res.size() == level){
            res.push_back(root->val);
        }
		// 注意，这里反过来，先遍历右子树再遍历左子树
        // 这样，首先遍历的一定是右侧节点
        traverse(root->right, level + 1);
        traverse(root->left, level + 1);
    }
};
```

那如果是要求二叉树的**左视图**呢，那就**先遍历左子树再遍历右子树**呗，又AC了一题😜。

**解法二**：层序遍历

```php
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
		queue<TreeNode*> que;
        vector<int> res;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(i == (size - 1)){
                    res.push_back(node->val);
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return res;
    }
};
```

### 637、二叉树的层平均值

给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。

**示例 ：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201555469.jpeg" alt="img" style="zoom:60%;" /></div>

```php
输入：root = [3,9,20,null,null,15,7]
输出：[3.00000,14.50000,11.00000]
```

层序遍历轻松完成，**注意**：先求一层所有节点的和，最后再作除法。


```php
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> res;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            // 记录当前层所有节点之和
            double sum = 0;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                sum += node->val;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            // 记录当前行的平均值
            res.push_back(sum / size);
        }
        return res;
    }
};
```

## 🦧二叉树的所有路径

**257、二叉树的所有路径**

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202033263.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

遍历二叉树，这道题和 ⌈**515、在每个树行中找最大值**⌋ 在思路上很相似——回溯，遍历函数 `traverse `的参数中还需要加入路径 `path`。再说的通俗一点儿就是，左右子树都需要对路径`path`进行操作，所以左子树操作完需要**回溯**，右子树才能再操作，不然右子树操作的就是左子树操作完的结果。

```php
class Solution {
public:
    // 记录所有从根节点到叶子节点的路径
    vector<string> res;
	string path;
    vector<string> binaryTreePaths(TreeNode* root) {
        // 记录 traverse 函数递归时的路径
        traverse(root, path);
        return res;
    }
    
    void traverse(TreeNode* root, string path){
        if(!root) return;
        path += to_string(root->val);
        //遍历到叶子节点，路径path加入res数组
        if(!root->left && !root->right){
            res.push_back(path);
        }
        traverse(root->left, path + "->");
        traverse(root->right, path + "->");
    }
};
```

## 🌞最近公共祖先

何为最近公共祖先呢？

**如果一个节点能够在它的左右子树中分别找到`p`和`q`，则该节点为`LCA`节点**。

先来实现一个简单的算法：输入一棵**没有重复元素**的二叉树根节点`root`和目标值`val`，`val2`，写一个函数寻找树中值为`val1`**或**`val2`的节点。

```php
//定义：在以 root 为根的二叉树中寻找值为 val1 或 val2 的节点
TreeNode* find(TreeNode* root, int val1, int val2){
    if(!root) return nullptr;
    // 前序位置，在每一个节点处判断
    if(root->val == val1 || root->val == val2) return root;
    //左右子树寻找
    TreeNode* left = find(root->left, val1, val2);
    TreeNode* right = find(root->right, val1, val2);
    // 后序位置，已经知道左右子树是否存在目标值
	return left != nullptr ? left : right;
}
```

**最近公共祖先系列问题的解法都是把这个函数作为框架的**。

### 236、二叉树的最近公共祖先

给你输入一棵**不含重复值**的二叉树，以及**存在于树中的**两个节点`p`和`q`，请你计算`p`和`q`的最近公共祖先节点。

最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241139188.jpg" alt="640" style="zoom:40%;" /></div>

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241140957.jpg" alt="640 (1)" style="zoom:40%;" /></div>

在`find`函数的后序位置，如果发现`left`和`right`都非空，就说明当前节点是`LCA`节点，即解决了第一种情况；

在`find`函数的前序位置，如果找到一个值为`val1`或`val2`的节点则直接返回，恰好解决了第二种情况。

```php
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return find(root, p->val, q->val);
    }
    // 在二叉树中寻找 val1 和 val2 的最近公共祖先节点
    TreeNode* find(TreeNode* root, int val1, int val2){
        if(!root) return nullptr;
        // 前序位置，在每一个节点处判断，遇到目标值立即返回
        if(root->val == val1 || root->val == val2) return root;
        //左右子树寻找
        TreeNode* left = find(root->left, val1, val2);
        TreeNode* right = find(root->right, val1, val2);
        // 后序位置，已经知道左右子树是否存在目标值
        if(left && right) return root;
        return left != nullptr ? left : right;
    }
};
```

因为题目说了`p`和`q`一定存在于二叉树中(这点很重要），所以即便我们遇到`q`就直接返回，根本没遍历到`p`，也依然可以断定`p`在`q`底下，`q`就是`LCA`节点。

### 1676、二叉树的最近公共祖先 IV

给定一棵[二叉树](https://so.csdn.net/so/search?q=二叉树&spm=1001.2101.3001.7020)的根节点 `root `和 TreeNode 类对象的数组（列表） `nodes`，返回 `nodes `中所有节点的最近公共祖先（LCA）。数组（列表）中所有节点都**存在于该二叉树中**，且二叉树中所有节点的值都是互不相同的。

**示例 3:**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241156790.png" alt="在这里插入图片描述" style="zoom:100%;" /></div>

```php
输入: root = [3,5,1,6,2,0,8,null,null,7,4], nodes = [7,6,2,4]
输出: 5
解释: 节点 7、6、2 和 4 的最近公共祖先节点是 5。
```

依然给你输入一棵不含重复值的二叉树，但这次不是给你输入`p`和`q`两个节点了，而是给你输入一个包含若干节点的列表`nodes`（这些节点都存在于二叉树中），其实换汤不换药，还是使用这个框架。

为了高效地查找数组`nodes`中的元素，使用**哈希表**来装载数组元素，`unordered_set` 来实现。

```php
class Solution {
public:
	unordered_set<int> set; 
    TreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*> &nodes) {
    	for(TreeNode* node: nodes){
            set.insert(node->val);
        }
        return find(root);
    }
    
    // 在二叉树中寻找 val 的最近公共祖先节点
    TreeNode* find(TreeNode* root){
        if(!root) return nullptr;
        // 前序位置，在每一个节点处判断，遇到目标值立即返回
        if(set.count(root->val)) return root;
        //左右子树寻找
        TreeNode* left = find(root->left);
        TreeNode* right = find(root->right);
        // 后序位置，已经知道左右子树是否存在目标值
        if(left && right) return root;
        return left != nullptr ? left : right;
    }
};
```

不过需要注意的是，这两道题的题目都明确告诉我们**这些节点必定存在于二叉树中**，如果没有这个前提条件，就需要修改代码了。

### 1644、二叉树的最近公共祖先 II

给定一棵二叉树的根节点 root，返回给定节点 p 和 q 的最近公共祖先（LCA）节点。如果 p 或 q 之一**不存在于该二叉树中**，返回 null。树中的每个节点值都是互不相同的。

在解决标准的最近公共祖先问题时，我们在`find`函数的前序位置有这样一段代码：

```php
// 前序位置
if (root.val == val1 || root.val == val2) {
    // 如果遇到目标值，直接返回
    return root;
}
```

因为`p`和`q`都存在于树中，所以这段代码恰好可以解决最近公共祖先的第二种情况：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241140957.jpg" alt="640 (1)" style="zoom:40%;" /></div>

但对于这道题来说，`p`和`q`不一定存在于树中，所以不能遇到一个目标值就直接返回，而应该对二叉树进行**完全搜索**（遍历每一个节点），如果发现`p`或`q`不存在于树中，那么是不存在`LCA`的。

哪种写法能够对二叉树进行完全搜索呢？只需要**把前序位置的判断逻辑放到后序位置**即可：

```php
TreeNode find(TreeNode root, int val) {
    if (root == null) {
        return null;
    }
    // 先去左右子树寻找
    TreeNode left = find(root.left, val);
    TreeNode right = find(root.right, val);
    // 后序位置，判断 root 是不是目标节点
    if (root.val == val) {
        return root;
    }
    // root 不是目标节点，再去看看哪边的子树找到了
    return left != null ? left : right;
}
```

同时还要使用`bool`变量记录一下`p` 和 `q `是否存在于二叉树中，若有一个不存在，则返回NULL；若两者都存在，则找到了`LCA`。

```php
class Solution{
    // 用于记录 p 和 q 是否存在于二叉树中
    bool findP = false;
    bool findQ = false;
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
		if(!findP || !findQ) return nullptr;
        // p 和 q 都存在二叉树中，才有公共祖先
        return find(root, p->val, q->val);
	}
	
	// 在二叉树中寻找 val1 和 val2 的最近公共祖先节点
	TreeNode* find(TreeNode* root, int val1, int val2){
        if(!root) return nullptr;
        TreeNode* left = find(root->left, val1, val2);
        TreeNode* right = find(root->right, val1, val2);
		// 后序位置，判断当前节点是不是 LCA 节点
        if(left && right) return root;
        // 后序位置，判断当前节点是不是目标值
        if(root->val == val1 || root->val == val2){
            if(root->val == val1) findP = true;
            if(root->val == val2) findQ = true;
            return root;
        }
        return left != nullptr ? left : right;
    }
};
```

### 235、二叉搜索树的最近公共祖先

输入一棵不含重复值的**二叉搜索树**，以及**存在于树中**的两个节点`p`和`q`，请计算`p`和`q`的最近公共祖先节点。

把之前的解法代码复制过来肯定也可以解决这道题，但没有用到 BST「**左小右大**」的性质，显然效率不是最高的。

在标准的最近公共祖先问题中，我们要在**后序位置**通过左右子树的搜索结果来判断当前节点是不是`LCA`：

```php
TreeNode left = find(root.left, val1, val2);
TreeNode right = find(root.right, val1, val2);

// 后序位置，判断当前节点是不是 LCA 节点
if (left != null && right != null) {
    return root;
}
```

但对于 BST 来说，根本不需要老老实实去遍历子树，由于 BST 左小右大的性质，**将当前节点的值与`val1`和`val2`作对比**，即可判断当前节点是不是`LCA`：

- 假设`val1 < val2`，那么`val1 <= root.val <= val2`，则说明当前节点就是`LCA`；

- 若`root.val`比`val1`还小，则需要去值更大的右子树寻找`LCA`；

- 若`root.val`比`val2`还大，则需要去值更小的左子树寻找`LCA`。

```php
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 保证 val1 较小，val2 较大
        int val1 = min(p->val, q->val);
        int val2 = max(p->val, q->val);
        return find(root, val1, val2);
    }
    // 在 BST 中寻找 val1 和 val2 的最近公共祖先节点
	TreeNode* find(TreeNode* root, int val1, int val2){
        if(!root) return nullptr;
        // 当前节点太大，去左子树找
        if(root->val > val2) return find(root->left, val1, val2);
        // 当前节点太小，去右子树找
        if(root->val < val1) return find(root->right, val1,val2);
        // val1 <= root.val <= val2
    	// 则当前节点就是最近公共祖先
        return root;
    }
};
```

### 1650、二叉树的最近公共祖先 III

给定一棵二叉树中的两个节点 `p` 和 `q`，返回它们的最近公共祖先节点（LCA）。每个节点都包含其父节点的引用（指针），`Node `的定义如下：

```php
class Node {
    int val;
    Node* left;
    Node* right;
    Node* parent;
};
```

**这道题其实不是公共祖先的问题，而是单链表相交的问题**，你把`parent`指针想象成单链表的`next`指针，题目就变成了：给你输入两个单链表的头结点`p`和`q`，这两个单链表必然会相交，请你返回相交点。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241502457.png" alt="image-20220424150259400" style="zoom:60%;" /></div>

**解法一**：双指针法

```php
class Solution {
public:
    Node* lowestCommonAncestor(Node* p, Node * q) {
		// 链表双指针技巧
    	node* a = p;
        node* b = q;
        while(a != b){
            // a 走一步，如果走到根节点，转到 q 节点
            if(!a) a = q;
            else a = a->parent;
            // b 走一步，如果走到根节点，转到 p 节点
            if(!b) b = p;
            else b = b->parent;
        }
        return a;
    };
```

**解法二**：哈希表

```php
class Solution {
public:
    Node* lowestCommonAncestor(Node* p, Node * q) {
        unordered_set<int> sign;
        // 将节点p的元素存入哈希表
        while(p!=NULL){
            sign.insert(p->val);
            p=p->parent;
        }
        // 节点q的元素在哈希表中查询，第一次出现的即LCA
        while(q!=NULL){
            if(sign.count(q->val)){
                return q;
            }
            q=q->parent;
        }
        return NULL;
    }
};
```





103、 二叉树的锯齿形层序遍历

剑指Offer 07、重建二叉树

剑指 Offer 26、树的子结构

剑指 Offer 27、二叉树的镜像

剑指Offer 32-III.从上到下打印二叉树









## 🚆二叉搜索树



























# 二、回溯算法

# 三、动态规划

# 四、贪心算法








# 参考资料

[labuladong 的算法小抄 :: labuladong的算法小抄](https://labuladong.github.io/algo/)

[代码随想录 (programmercarl.com)](https://programmercarl.com/)















