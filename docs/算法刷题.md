# 🔥算法刷题

# 一、二叉树

## 解题方法

1️⃣ 遇到二叉树的题目，如何去思考？或者说有没有思考的框架呢？

- **是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

- **是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「**分解问题**」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

2️⃣ 如何正确地理解**前中后序遍历**呢？

**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：

- 前序位置的代码在刚刚进入一个二叉树节点的时候执行；
- 后序位置的代码在将要离开一个二叉树节点的时候执行；
- 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204170940278.png" alt="image-20220417094016966" style="zoom:50%;" /></div>

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204170942506.png" alt="image-20220417094235414" style="zoom:60%;" /></div>

3️⃣前序位置和后序位置的代码有什么区别？后序位置有什么特殊之处？

前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到**子树**通过函数返回值传递回来的数据。

🔥总结：二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，**你只需要单独思考每一个节点应该做什么**，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

## 1. 最大/小深度、最大直径

### 104、求二叉树最大深度

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数，叶子节点是指没有子节点的节点。

**示例：** 
给定二叉树`[3,9,20,null,null,15,7]`，

```php
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3。

**解法一**：遍历二叉树，回溯算法思路

遍历一遍二叉树，用一个外部变量记录**每个节点**所在的深度，取最大值就可以得到最大深度。

```php
class Solution {
public:
    int depth = 0;
    int res = 0;
    int maxDepth(TreeNode* root) {
        traverse(root);
        return res;
    }
    //遍历二叉树
    void traverse(TreeNode* root){
		if(root == nullptr){
            return;
        }
        //前序遍历位置
        depth++;
        //遍历过程中记录最大深度
        res = max(depth, res);
        traverse(root->left);
        traverse(root->right);
        //后序遍历位置
        depth--;
    }
};
```

**解法二**：分解成子树问题，动态规划思路

```php
class Solution {
public:
    // 定义：输入一个节点，返回以该节点为根的二叉树的最大深度
    int maxDepth(TreeNode* root) {
		if(root == nullptr){
            return 0;
        }
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        // 根据左右子树的最大深度推出原二叉树的最大深度
        return max(leftDepth, rightDepth) + 1;
    }
};
```

**解法三**：层序遍历

```php
class Solution {
public:
    int maxDepth(TreeNode* root) {
		int depth = 0;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth++;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

求二叉树的最大深度可以延伸到求二叉树的直径：

### 543、二叉树直径

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**
给定二叉树

```php
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

每一条二叉树的「**直径**」长度，就是一个节点的左右子树的**最大深度之和**。把计算「直径」的逻辑放在**后序位置**，准确说应该是放在 `maxDepth` 的后序位置，因为 `maxDepth` 的后序位置是知道左右子树的最大深度的。

```php
class Solution {
public:
    int maxDiameter = 0;
    int diameterOfBinaryTree(TreeNode* root) {
		maxDepth(root);
        return maxDiameter;       
    }
    
    //定义：输入一个节点，返回以该节点为根节点的二叉树的深度
    int maxDepth(TreeNode* root){
		if(root == nullptr){
            return 0;
        }
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        // 后序位置，顺便计算最大直径
        maxDiameter = max(leftDepth + rightDepth, maxDiameter);
        return max(leftDepth, rightDepth) + 1;
    }
};
```

### 111、二叉树的最小深度

给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**示例**：给定二叉树`[3，9，20，null，null，15，7]`：

```php
      3
     / \
    9  20
       / \     
      15  7    
```

返回它的最小深度2。

**解法一**：分解成子树问题，动态规划思想

```php
class Solution {
public:
    //定义：输入一个节点，返回以该节点为根节点的二叉树的最小深度
    int minDepth(TreeNode* root) {
		if(!root) {
            return 0;
        }
        int leftDepth = minDepth(root->left);
        int rightDepth = minDepth(root->right);
        return min(leftDepth, rightDepth) + 1;        
    }    
};
```

❓**上面的算法对吗？为什么？**

❎错误！这个代码就犯了此图中的误区：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171128504.png" alt="111.二叉树的最小深度" style="zoom:50%;" /></div>

如果这么求的话，**没有左孩子的分支会算为最短深度**。

所以，如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度；

反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度；

最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。

✅**正确的解法一**：分解成子树问题，动态规划思想

```php
class Solution {
public:
    int minDepth(TreeNode* root) {
		if(!root){
            return 0;
        }
        int leftDepth = minDepth(root->left);
        int rightDepth = minDepth(root->right);
        if(!root->left){
            return rightDepth + 1;
        }
        if(!root->right){
            return leftDepth + 1;
        }
        return min(leftDepth, rightDepth) + 1;
    }
};
```

**解法二**：层序遍历

```php
class Solution {
public:
    int minDepth(TreeNode* root) {
		int depth = 0;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth++;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(!node->left && !node->right) return depth;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

## 2. 翻转二叉树

226. 翻转二叉树

## 3. 二叉树展开为链表

114. 二叉树展开为链表

## 4. 填充每个节点的下一个右侧节点指针

116. 填充每个节点的下一个右侧节点指针

## 5. 寻找重复的子树

652. 寻找重复的子树

## 6. 构造二叉树

😶‍🌫️二叉树的构造问题一般都是使用「**分解问题**」的思路：**构造整棵树 = 根节点 + 构造左子树 + 构造右子树**。

### 654、构造最大二叉树

给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 *`nums` 构建的* ***最大二叉树\*** 。

**示例**：

```php
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
               6
             /  \
            3    5
             \   /      
              2 0   
               \
                1
```

首先遍历数组把找到最大值 `maxVal`，从而把根节点 `root` 构造出来，然后对 `maxVal` 左边的数组和右边的数组进行递归构建，作为 `root` 的左、右子树。

```php
//定义二叉树
struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x):val(x), left(nullptr), right(nullptr){}
}

class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
		return build(nums, 0, nums.size() - 1);
    }
    
    //定义：输入数组和区间左右端点，返回构造的最大二叉树的根节点
    TreeNode* build(vector<int>& nums, int lo, int hi){
        if(lo > hi){
            return nullptr;
        }
        // 找到数组中的最大值和对应的索引
        // 注意不能写成 int rootVal = 0;
        int rootVal = INT32_MIN;
        int index = 0;
        for(int i = lo; i <= hi; i++){
			if(rootVal < nums[i]){
                rootVal = nums[i];
                index = i;
            }
        }
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(nums, lo, index - 1);
        root->right = build(nums, index + 1, hi);
        return root;
    }
};
```

### 105、从前序与中序遍历序列构造二叉树

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

```php
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171505952.jpeg" alt="img" style="zoom: 67%;" /></div>

前序遍历`preorder` 和 中序遍历`inorder` 数组中的元素分布有如下特点：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171510562.png" alt="image-20220417151011413" style="zoom:80%;" /></div>

找到根节点是很简单的，前序遍历的第一个值 `preorder[0]` 就是根节点的值。关键在于如何通过根节点的值，将 `preorder` 和 `postorder` 数组划分成两半，构造根节点的左右子树？

**暴力**方法是利用for循环遍历整个数组找出`index`，但是通过 for 循环遍历的方式去确定 `index` 效率不算高，可以进一步优化：采用**哈利表**的查到 `rootVal` 对应的 `index`，数组元素无序且不重复，故采用 `unordered_map`来实现，底层由**哈希表**实现。

本道题的一大**难点**在于如何确定左右数组对应的起始索引和终止索引，这个可以通过左子树的节点数推导出来，假设左子树的节点数为 `leftSize`，那么 `preorder` 数组上的索引情况是这样的：

<img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171511724.png" alt="image-20220417151152530" style="zoom:60%;" />

做这种题目一定要画示意图，选择闭区间，若索引填错了，就会引起栈溢出的错误。

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
		int size = inorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[inorder[i]] = i;
        }
        return build(preorder, 0, size - 1, inorder, 0, size - 1);
    }
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd, 
                    vector<int>& inorder, int inStart, int inEnd){
    	if(preStart > preEnd){
            return nullptr;
        }
        //根节点的值
        int rootVal = preorder[preStart];
        //利用哈希表查询到 rootVal 在 inorder 中的索引 index
        int index = map[rootVal];
        
        int leftSize = index - inStart;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(preorder, preStart + 1, preStart + leftSize, 
                          inorder, inStart, index - 1);
    	root->right = build(preorder, preStart + leftSize + 1, preEnd,
                           inorder, index + 1, inEnd);
    	return root;
    }
};
```

### 106、从中序与后序遍历序列构造二叉树

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。

```php
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
```

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171505952.jpeg" alt="img" style="zoom: 67%;" /></div>

 `postoder` 和 `inorder` 对应的状态如下：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171615448.png" alt="image-20220417161545340" style="zoom:60%;" /></div>

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
		int size = inorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[inorder[i]] = i;
        }
        return build(inorder, 0, size - 1, postorder, 0, size - 1);
    }
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& inorder, int inStart, int inEnd, 
                    vector<int>& postorder, int postStart, int postEnd){
    	if(postStart > postEnd){
            return nullptr;
        }
        //根节点的值
        int rootVal = postorder[postEnd];
        //利用哈希表查询到 rootVal 在 inorder 中的索引 index
        int index = map[rootVal];
        
        int leftSize = index - inStart;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(inorder, inStart, index - 1, 
                          postorder, postStart, postStart + leftSize - 1);
    	root->right = build(inorder, index + 1, inEnd,
                           postorder, postStart + leftSize, postEnd - 1);
    	return root;
    }
};
```

### 889、根据前序和后序遍历构造二叉树

给定两个整数数组，`preorder` 和 `postorder` ，其中 `preorder` 是一个具有 **无重复** 值的二叉树的前序遍历，`postorder` 是同一棵树的后序遍历，重构并返回二叉树。

如果存在多个答案，您可以返回其中 **任何** 一个。

```php
输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
输出：[1,2,3,4,5,6,7]
```

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171628354.jpeg" alt="img" style="zoom:60%;" /></div>

这道题和前两道题有一个本质的区别：

**通过前序中序，或者后序中序遍历结果可以确定一棵原始二叉树，但是通过前序后序遍历结果无法确定原始二叉树**。这道题，你可以确定根节点，但是无法确切的知道左右子树有哪些节点，以下是一种构造方法：

1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值。

2、然后把前序遍历结果的第二个元素作为左子树的根节点的值。

3、在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可。

假设前序遍历的第二个元素是左子树的根节点，但实际上左子树有可能是空指针，那么这个元素就应该是右子树的根节点。由于这里无法确切进行判断，所以导致了最终答案的不唯一。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171639321.png" alt="image-20220417163947215" style="zoom:70%;" /></div>

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {
		int size = postorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[postorder[i]] = i;
        }
        return build(preorder, 0, size - 1, postorder, 0, size - 1);
    }
    
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd, 
                    vector<int>& postorder, int postStart, int postEnd){
    	if(postStart > postEnd){
            return nullptr;
        }
        if(postStart == postEnd){
            return new TreeNode(postorder[postStart]);
        }
        //根节点的值
        int rootVal = preorder[preStart];
        int leftRootVal = preorder[preStart + 1];
        //利用哈希表查询到左子树根节点 leftRoot 在 postorder 中的索引 index
        int index = map[leftRootVal];
        
        int leftSize = index - postStart + 1;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(preorder, preStart + 1, preStart + leftSize, 
                          postorder, postStart, index);
    	root->right = build(preorder, preStart + leftSize + 1, preEnd,
                           postorder, index + 1, postEnd - 1);
    	return root;
    }
};
```



















# 参考资料

[labuladong 的算法小抄 :: labuladong的算法小抄](https://labuladong.github.io/algo/)

[代码随想录 (programmercarl.com)](https://programmercarl.com/)













