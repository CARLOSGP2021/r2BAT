# 🔥算法刷题

# 一、二叉树

## 解题方法

1️⃣ 遇到二叉树的题目，如何去思考？或者说有没有思考的框架呢？

- **是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

- **是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「**分解问题**」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

2️⃣ 如何正确地理解**前中后序遍历**呢？

**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：

- 前序位置的代码在刚刚进入一个二叉树节点的时候执行；
- 后序位置的代码在将要离开一个二叉树节点的时候执行；
- 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204170940278.png" alt="image-20220417094016966" style="zoom:50%;" /></div>

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204170942506.png" alt="image-20220417094235414" style="zoom:60%;" /></div>

3️⃣前序位置和后序位置的代码有什么区别？后序位置有什么特殊之处？

前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到**子树**通过函数返回值传递回来的数据。

🔥总结：二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，**你只需要单独思考每一个节点应该做什么**，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

## 二叉树深度

### 104、求二叉树最大深度

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数，叶子节点是指没有子节点的节点。

**示例：** 
给定二叉树`[3,9,20,null,null,15,7]`，

```php
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3。

**解法一**：递归遍历二叉树，回溯算法思路

遍历一遍二叉树，用一个外部变量记录**每个节点**所在的深度，取最大值就可以得到最大深度。

```php
class Solution {
public:
    int depth = 0;
    int res = 0;
    int maxDepth(TreeNode* root) {
        traverse(root);
        return res;
    }
    //遍历二叉树
    void traverse(TreeNode* root){
		if(root == nullptr){
            return;
        }
        //前序遍历位置
        depth++;
        //遍历过程中记录最大深度
        res = max(depth, res);
        traverse(root->left);
        traverse(root->right);
        //后序遍历位置
        depth--;
    }
};
```

**解法二**：分解成子树问题，动态规划思路

```php
class Solution {
public:
    // 定义：输入一个节点，返回以该节点为根的二叉树的最大深度
    int maxDepth(TreeNode* root) {
		if(root == nullptr){
            return 0;
        }
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        // 根据左右子树的最大深度推出原二叉树的最大深度
        return max(leftDepth, rightDepth) + 1;
    }
};
```

**解法三**：层序遍历

```php
class Solution {
public:
    int maxDepth(TreeNode* root) {
		int depth = 0;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth++;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

求二叉树的最大深度可以延伸到求二叉树的直径：

### 543、二叉树直径

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**
给定二叉树

```php
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

每一条二叉树的「**直径**」长度，就是一个节点的左右子树的**最大深度之和**。把计算「直径」的逻辑放在**后序位置**，准确说应该是放在 `maxDepth` 的后序位置，因为 `maxDepth` 的后序位置是知道左右子树的最大深度的。

```php
class Solution {
public:
    int maxDiameter = 0;
    int diameterOfBinaryTree(TreeNode* root) {
		maxDepth(root);
        return maxDiameter;       
    }
    
    //定义：输入一个节点，返回以该节点为根节点的二叉树的深度
    int maxDepth(TreeNode* root){
		if(root == nullptr){
            return 0;
        }
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        // 后序位置，顺便计算最大直径
        maxDiameter = max(leftDepth + rightDepth, maxDiameter);
        return max(leftDepth, rightDepth) + 1;
    }
};
```

### 111、二叉树的最小深度

给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**示例**：给定二叉树`[3，9，20，null，null，15，7]`：

```php
      3
     / \
    9  20
       / \     
      15  7    
```

返回它的最小深度2。

**解法一**：分解成子树问题，动态规划思想

```php
class Solution {
public:
    //定义：输入一个节点，返回以该节点为根节点的二叉树的最小深度
    int minDepth(TreeNode* root) {
		if(!root) {
            return 0;
        }
        int leftDepth = minDepth(root->left);
        int rightDepth = minDepth(root->right);
        return min(leftDepth, rightDepth) + 1;        
    }    
};
```

❓**上面的算法对吗？为什么？**

❎错误！这个代码就犯了此图中的误区：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171128504.png" alt="111.二叉树的最小深度" style="zoom:50%;" /></div>

如果这么求的话，**没有左孩子的分支会算为最短深度**。

所以，如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度；

反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度；

最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。

✅**正确的解法一**：分解成子树问题，动态规划思想

```php
class Solution {
public:
    int minDepth(TreeNode* root) {
		if(!root){
            return 0;
        }
        int leftDepth = minDepth(root->left);
        int rightDepth = minDepth(root->right);
        if(!root->left){
            return rightDepth + 1;
        }
        if(!root->right){
            return leftDepth + 1;
        }
        return min(leftDepth, rightDepth) + 1;
    }
};
```

**解法二**：层序遍历

```php
class Solution {
public:
    int minDepth(TreeNode* root) {
		int depth = 0;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth++;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(!node->left && !node->right) return depth;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

### 110、平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

**示例 ：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202031331.jpeg" alt="img" style="zoom: 60%;" /></div>

```php
输入：root = [3,9,20,null,null,15,7]
输出：true
```

本题依然是二叉树深度相关的题目，依然是把计算「高度差」的逻辑放在**后序位置**，准确说应该是放在 `maxDepth` 的后序位置，因为 `maxDepth` 的后序位置是知道左右子树的最大深度的。

只计算一次最大深度，计算的过程中在**后序遍历位置**顺便判断二叉树是否平衡：对于每个节点，先算出来左右子树的最大高度，然后在后序遍历的位置根据左右子树的最大高度判断平衡性。

```php
class Solution {
public:
    // 记录二叉树是否平衡
    bool balance = true;

    bool isBalanced(TreeNode* root) {
        maxDepth(root);
        return balance;
    }
	// 定义：输入一个节点，返回以该节点为根的二叉树的最大深度
    int maxDepth(TreeNode* root){
        if(!root) return 0;
        int leftDepth= maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        if(abs(leftDepth - rightDepth) > 1) balance = false;
        return max(leftDepth, rightDepth) + 1;
    }
};
```

## 翻转二叉树

**226、翻转二叉树**

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171844420.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**解法一**：递归遍历，回溯算法的思想

遍历二叉树的每个节点，每个节点的左、右子树交换位置。

```php
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
		traverse(root);
        return root;
    }
    // 二叉树遍历函数
    void traverse(TreeNode* root){
        if(!root){
            return;
        }
        // 每一个节点需要做的事就是交换它的左右子节点
        TreeNode* tmp = root->left;
        root->left = root->right;
        root->right = tmp;
        // 遍历框架，去遍历左右子树的节点
        traverse(root->left);
        traverse(root->right);
    }
};
```

**解法二**：分解为子树的问题，动态规划思想

用 `invertTree(x.left)` 先把 `x` 的左子树翻转，再用 `invertTree(x.right)` 把 `x` 的右子树翻转，最后把 `x` 的左右子树交换，这恰好完成了以 `x` 为根的整棵二叉树的翻转，即完成了 `invertTree(x)` 的定义。

```php
class Solution {
public:
    //定义：输入一个节点，将以该节点为根节点的二叉树进行翻转，返回其根节点
    TreeNode* invertTree(TreeNode* root) {
		if(!root) {
            return root;
        }
        // 利用函数定义，先翻转左右子树
        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);
        // 然后交换左右子节点
		root->left = right;
        root->right = left;
        return root;
    }    
};
```

**解法三**：层序遍历

```php
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();              // 中
            st.pop();
            swap(node->left, node->right);
            if(node->right) st.push(node->right);   // 右
            if(node->left) st.push(node->left);     // 左
        }
        return root;
    }
};
```

## 路径总和

### 112、路径总和

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221122861.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**解法一**：递归遍历，回溯算法思想

前部遍历位置（进入节点）`sum += root->val`，顺便判断是否到达叶子节点且和为`targetSum`；后序遍历位置（离开节点）`sum -= root->val`。

```php
class Solution {
public:
    bool res = false;
    int sum = 0;
    bool hasPathSum(TreeNode* root, int targetSum) {
        traverse(root, targetSum);
        return res;
    }

    void traverse(TreeNode* root, int targetSum){
        if(!root) return;
        //前序遍历位置
        sum += root->val;
        // 到达叶子节点且和为targetSum
        if(!root->left && !root->right && sum == targetSum) res = true;
        traverse(root->left, targetSum);
        traverse(root->right, targetSum);
        //后序遍历位置
        sum -= root->val;
    }
};
```

**解法二**：分解成子树问题，动态规划思想

遍历到一个节点，继续遍历左孩子和右孩子，且targetSum减去节点的数值。

```php
class Solution {
    
public:
    // 定义：输入一个根节点，返回该根节点到叶子节点是否存在一条和为 targetSum 的路径
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return false;
        if(!root->left && !root->right && root->val == targetSum) return true;
        // 左子树或者右子树有一个满足即可
        return hasPathSum(root->left, targetSum - root->val) ||
                hasPathSum(root->right, targetSum - root->val);
    }
};
```

### 113、路径总和ii

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221122861.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
```

相对于⌈**112、路径总和**⌋来说，前序和后序位置不仅要维护`sum`，还要维护路径`path`。

```php
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    int sum = 0;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        traverse(root, targetSum);
        return res;
    }

    void traverse(TreeNode* root, int targetSum){
        if(!root) return;
        //前序遍历位置
        sum += root->val;
        path.push_back(root->val);
        if(!root->left && !root->right && sum == targetSum) res.push_back(path);
        traverse(root->left, targetSum);
        traverse(root->right, targetSum);
        //后序遍历位置
        sum -= root->val;
        path.pop_back();
    }
};
```

### 437、路径总和iii

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221609909.jpeg" alt="img" style="zoom: 50%;" /></div>

```php
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示
```

这题及要求你准确理解二叉树的前序后序遍历，还要熟悉前缀和技巧，把前缀和技巧用到二叉树上。

这道题涉及到数组的技巧，暂定先不做。





## 二叉树是否对称/相等

**101、对称二叉树**和**100、相同的树**结合起来看，两道题方法和代码上非常相似。

### 100、相同的树

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201830207.jpeg" alt="img" style="zoom:60%;" /></div>

```php
输入：p = [1,2,3], q = [1,2,3]
输出：true
```

解法一：分解成子树问题

```php
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p || !q) return p == q;
        if(p->val != q->val) return false;
        bool left = isSameTree(p->left, q->left);	//比较左子树
        bool right = isSameTree(p->right, q->right);//比较右子树
        return left && right;
    }
};
```

代码简化为：

```php
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // 判断一对节点是否相同
        if(!p || !q) return p == q;
        if(p->val != q->val) return false;
        // 判断其他节点是否相同
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

**解法二**：迭代法

```php
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        queue<TreeNode*> que;
        que.push(p);
        que.push(q);
        //注意不能加上写成如下代码，否则会报错
        //if(p) que.push(p);   
        //if(q) que.push(q);  
        while (!que.empty()) {  // 接下来就要判断这两颗树是否相等
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是相等的
                continue;
            }
            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   
            que.push(rightNode->left); 
            que.push(leftNode->right);  
            que.push(rightNode->right); 
        }
        return true;
    }
};
```

**注意**：

```php
que.push(p);
que.push(q);
```

不能写为：

```
if(p) que.push(p);   
if(q) que.push(q);  
```

否则会报错：

```php
执行出错信息：
Line 15: Char 74: runtime error: member access within misaligned address 0xbebebebebebebebe for type 'TreeNode', which requires 8 byte alignment (solution.cpp)
0xbebebebebebebebe: note: pointer points here
<memory cannot be printed>
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:74
最后执行的输入：
[]
[0]
```

加上`if`判断后，若输入当中有为空的，则无法加入到队列当中，影响后序的代码逻辑运行。

### 101、对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251941296.png" alt="101. 对称二叉树" style="zoom:55%;" /></div>

**解法一**：分解成子树问题

对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了**其实我们要比较的是两颗树（这两颗树是根节点的左右子树）**，所以在递归遍历的过程中，也是要同时遍历两棵树。

正是因为要遍历两棵树而且要**比较内侧和外侧节点**，所以准确的来说是一个树的遍历顺序是**左右中**，一个树的遍历顺序是**右左中**，只有内侧和外侧节点分别对应相等，这两棵树才是对称的。

**返回条件**：

- 左节点为空，右节点不为空，不对称，return false；
- 左不为空，右为空，不对称 return false；
- 左右都为空，对称，返回true；
- 左右都不为空，比较节点数值，不相同就return false；
- 左右节点相等的话，再递归判断子节点；

代码如下：

```
if (left == NULL && right != NULL) return false;
else if (left != NULL && right == NULL) return false;
else if (left == NULL && right == NULL) return true;
else if (left->val != right->val) return false;
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return compare(root->left, root->right);
    }
    //定义：输入左、右节点，返回分别以这两节点为根节点的二叉树是否对称
    bool compare(TreeNode* left, TreeNode* right){
        // 注意这里终止条件的代码
        if(!left || !right) return left == right;
        if(left->val != right->val) return false;
        bool outside = compare(left->left, right->right);   //外侧节点比较
        bool inside = compare(left->right, right->left);    //内侧节点比较
        return outside && inside;   //左右子节点需要对称相同
    }
};
```

代码简化为：

```
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return compare(root->left, root->right);
    }
    //定义：输入左、右节点，返回分别以这两节点为根节点的二叉树是否对称
    bool compare(TreeNode* left, TreeNode* right){
        // 该对节点是否对称
        if(!left || !right) return left == right;
        if(left->val != right->val) return false;
        // 其他节点是否对称
        return compare(left->left, right->right) && compare(left->right, right->left);
    }
};
```

**解法二**：迭代法，不是层序遍历，这里我们可以使用**队列**来比较两个树（根节点的左右子树）是否相互翻转。

把左右两个子树要比较的元素顺序放进一个容器，然后**成对**的取出来进行比较，那么其实使用**栈**也是可以的。

```
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        
        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }
            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```

### 572、另一个树的子树

给你两棵二叉树 `root` 和 `subRoot` ，检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。

二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点，`tree` 也可以看做它自身的一棵子树。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201953856.jpeg" alt="img" style="zoom:50%;" /></div>

```
输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
```

遍历以 `root` 为根的这棵二叉树的所有节点，用 ⌈**100、相同的树**⌋ 中的 `isSameTree` 函数判断以该节点为根的子树是否和以 `subRoot` 为根的那棵树相同。

```php
class Solution {
public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
		if(!root) return root == subRoot;
        // 判断以 root 为根的二叉树是否和 subRoot 相同
        if(isSameTree(root, subRoot)) return true;
        // 去左右子树中判断是否有和 subRoot 相同的子树
        return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);
    }
    // 定义：输入两个节点，判断以两个节点为根节点的二叉树是否一样，返回结果
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // 判断一对节点是否相同
        if(!p || !q) return p == q;
        if(p->val != q->val) return false;
        // 判断其他节点是否相同
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

## 左叶子/左下角问题

### 404、左叶子之和

给定二叉树的根节点 `root` ，返回所有左叶子之和。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202035803.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

**首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。**

本题遍历二叉树即可，问题是如何判断节点是**左叶子**呢？

**如果左节点不为空，且左节点没有左右孩子，那么这个节点的左节点就是左叶子**，必须要通过节点的父节点来判断其左孩子是不是左叶子：

```php
if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) {
    左叶子节点处理逻辑
}
```

```php
class Solution {
public:
    int sum = 0;
    
    int sumOfLeftLeaves(TreeNode* root) {
        traverse(root);
        return sum;
    }
    
    void traverse(TreeNode* root){
        if(!root) return;
        // 找到左侧的叶子节点，记录累加值
        if(root->left && !root->left->left && !root->left->right){
            sum += root->left->val;
        }
        traverse(root->left);
        traverse(root->right);
    }
};
```

### 513、找树左下角的值

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204212053339.jpeg" alt="img" style="zoom:60%;" /></div>

```
输入: root = [2,1,3]
输出: 1
```

**解法一**：递归遍历二叉树

二叉树递归框架代码是先递归左子树，后递归右子树，所以**到最大深度时第一次遇到的节点就是左下角的节点**。

```php
class Solution {
public:
    int depth;		// 记录 traverse 递归遍历到的深度
    int maxDepth;	// 记录二叉树的最大深度
    TreeNode* res;

    int findBottomLeftValue(TreeNode* root) {
        traverse(root);
        return res->val;
    }

    void traverse(TreeNode* root){
        if(!root) return;
        depth++;
        // 到最大深度时第一次遇到的节点就是左下角的节点
        if(depth > maxDepth){
            maxDepth = depth;
            res = root;
        }
        traverse(root->left);
        traverse(root->right);
        depth--;
    }
};
```

**解法二**：层序遍历，很好理解

```php
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        int result = 0;	//后续循环会不断刷新result的值
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (i == 0) result = node->val; // 记录最后一行第一个元素
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

找树左下角的值会做了，找树右下角的值自然也会做了，也就是把遍历的顺序改变一下：先遍历右子树，再遍历左子树。



## 完全二叉树

### [BM35 判断是不是完全二叉树](https://www.nowcoder.com/practice/8daa4dff9e36409abba2adbe413d6fae?tpId=295&tqId=2299105&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

给定一个二叉树，确定他是否是一个**完全二叉树**。

**完全二叉树**的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）

样例图1：叶子节点出现在最后一层

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205012041648.png" alt="img" style="zoom:80%;" /></div>

样例图2：叶子节点出现在最后一次和倒数第二层

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205012050113.png" alt="img" style="zoom:60%;" /></div>

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。

本道题的解题关键就是要紧紧抓住**完全二叉树的定义**，使用**层序遍历**。如果遇到某个节点为空，进行标记，代表访问到完全二叉树的最下层，若是后续还有访问，则不符合完全二叉树的定义。

注意：

```php
que.push(node->left);
que.push(node->right);
```

不能写成：

```php
if(node->left) push(node->left);
if(node->right) que.push(node->right);
```

否则， 完全二叉树最后一层的空节点是访问不到的。


```php
class Solution {
  public:
    bool isCompleteTree(TreeNode* root) {
        //空树一定是完全二叉树
        if(root == NULL)  return true;
        queue<TreeNode*> que;
        if(root) que.push(root); 
        //定义一个首次出现的标记位
        bool flag = false; 
        while(!que.empty()){ 
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                //标记第一次遇到空节点
                if (!node) 
                    flag = true; 
                else{
                    //后续访问已经遇到空节点了，说明经过了叶子
                    if (flag) return false;
                    que.push(node->left);
                    que.push(node->right);
                }
            }
        }
        return true;
    }
};
```

### 222、完全二叉树的节点个数

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202028146.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,3,4,5,6]
输出：6
```

首先要搞清楚什么是 ⌈**完全二叉树**⌋ 和 ⌈**满二叉树**⌋ ：

**完全二叉树**如下图，每一层都是紧凑靠左排列的，除了最底层节点可能没填满外，其余每层节点数都达到最大值：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211628453.png" alt="img" style="zoom:50%;" /></div>

**满二叉树**如下图，是一种特殊的完全二叉树，每层都是是满的，像一个稳定的三角形：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211629053.png" alt="img" style="zoom:80%;" /></div>

如果是一个**普通**二叉树，显然只要向下面这样遍历一边即可，时间复杂度 O(N)：

```php
int countNodes(TreeNode* root) {
    if (root == null) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}
```

那如果是一棵**满**二叉树，节点总数就和树的高度呈指数关系：

```php
int countNodes(TreeNode* root) {
    int h = 0;
    // 计算树的高度
    while (root != null) {
        root = root->left;
        h++;
    }
    // 节点总数就是 2^h - 1
    return (2 << h) - 1;
}
```

**完全**二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版。

完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。

对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。

对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211649576.png" alt="image-20220421164919517" style="zoom:60%;" /></div>

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211652510.png" alt="image-20220421165226452" style="zoom:40%;" /></div>

可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。

```php
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (!root) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        // 这里初始为0是有目的的，为了下面求指数方便
        int leftHeight = 0;
        int rightHeight = 0; 
        // 记录左、右子树的高度
        while (left) {
            left = left->left;
            leftHeight++;
        }
        while (right) {
            right = right->right;
            rightHeight++;
        }
        // 如果左右子树的高度相同，则是一棵满二叉树
        if (leftHeight == rightHeight) {
            return (2 << leftHeight) - 1; // 注意(2<<1) 相当于2^2，所以leftHeight初始为0
        }
        // 如果左右高度不同，则按照普通二叉树的逻辑计算
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

这个算法的时间复杂度是 `O(logN*logN)`，但直觉感觉好像最坏情况下是 O(N*logN) ，因为之前的 while 需要 logN 的时间，最后要 O(N) 的时间向左右子树递归：

```php
return 1 + countNodes(root.left) + countNodes(root.right);
```

**关键点在于，这两个递归只有一个会真的递归下去，另一个一定会触发 `leftHeight == rightHeight` 而立即返回，不会递归下去**。

所以，算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logN*logN)。

## 二叉树展开为链表

**114、二叉树展开为链表**

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 前序遍历 顺序相同。

**示例 ：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171905704.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**解法一**：递归遍历

对整棵树进行前序遍历，一边遍历一边构造出一条「链表」。

```php
class Solution {
public:
    // 虚拟头节点，res->right 就是结果
    TreeNode* res = new TreeNode(-1);
    // 用来构建链表的指针
    TreeNode* p = res;
    TreeNode* flatten(TreeNode* root) {
        traverse(root);
        return res->right;
    }
    
    void traverse(TreeNode* root){
		if(!root) return;
        p = new TreeNode(root->val);
        p = p->right;
        traverse(root->left);
        traverse(root->right);
    }
};
```

但是注意 `flatten` 函数的签名，返回类型为 `void`，也就是说题目希望我们在原地把二叉树拉平成链表。

这样一来，没办法通过简单的二叉树遍历来解决这道题了。

**解法二**：分解成子树的问题

对于一个节点 `x`，可以执行以下流程：

1、先利用 `flatten(x.left)` 和 `flatten(x.right)` 将 `x` 的左右子树拉平。

2、将 `x` 的右子树接到左子树下方，然后将整个左子树作为右子树。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171948600.png" alt="image-20220417194832538" style="zoom:50%;" /></div>

这样，以 `x` 为根的整棵二叉树就被拉平了，恰好完成了 `flatten(x)` 的定义。

```php
class Solution {
public:
    //定义：输入一个节点，将以该节点为根节点的二叉树展开成单链表
    void flatten(TreeNode* root) {
		if(!root) return;
        // 利用定义，把左右子树拉平
        flatten(root->left);
        flatten(root->right);
        // 1、左右子树已经被拉平成一条链表
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        // 2、将左子树作为右子树
        root->left =  nullptr;
        root->right = left;
        // 3、将原先的右子树接到当前右子树的末端
        TreeNode* p = root;
        // 注意这里的条件是 p->right，而不是 p ，即有右孩子则移动指针
        while(p->right){
            p = p->right;
        }
        p->right = right;
    }
};
```

## 填充每个节点的下一个右侧节点指针

**116、填充每个节点的下一个右侧节点指针**

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```php
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171958858.png" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
```

这道题若使用**常规的**遍历二叉树的话，只能将一个节点的左子树指向右子树，**不同节点的子树之间无法建立联系**，所以要改变遍历的方式。传统的 `traverse` 函数是遍历二叉树的所有节点，但现在我们想遍历的其实是两个相邻节点之间的「**空隙**」，所以可以在二叉树的基础上进行抽象，把图中的每一个方框看做一个节点：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204172004189.png" alt="img" style="zoom:30%;" /></div>

**解法一**：递归遍历二叉树

**这样，一棵二叉树被抽象成了一棵三叉树，三叉树上的每个节点就是原先二叉树的两个相邻节点**。

现在，我们只要实现一个 `traverse` 函数来遍历这棵三叉树，每个「三叉树节点」需要做的事就是把自己内部的两个二叉树节点穿起来。这样，`traverse` 函数遍历整棵「三叉树」，将所有相邻节的二叉树节点都连接起来，也就避免了我们之前出现的问题，把这道题完美解决。

```php
class Solution {
public:
    Node* connect(Node* root) {
        if(!root) return root;
        traverse(root->left, root->right);
        return root;
    }
    // 三叉树遍历框架
    void traverse(Node* node1, Node* node2){
        if(!node1 || !node2){
            return;
        }
        node1->next = node2;
        traverse(node1->left, node1->right);
        traverse(node2->left, node2->right);
        traverse(node1->right, node2->left);
    }
};
```

**解法二**：层序遍历

在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204182056966.png" alt="填充每个节点的下一个右侧节点指针.drawio.png" style="zoom:70%;" /></div>

核心代码逻辑为：

- 遍历到每一层的第一个节点时，用pre记录该节点，然后节点出队，node记录pre；

- 向后每遍历一个节点，用node记录该节点，然后节点出队，**pre指向node**，pre指针向后移动一位；

- 该层最后一个节点指向nullptr；

```php
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if (root != NULL) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            Node* pre;
            Node* node;
            for (int i = 0; i < size; i++) {
                if (i == 0) {
                    pre = que.front(); // 取出一层的头结点
                    que.pop();
                    node = pre;
                } else {
                    node = que.front();
                    que.pop();
                    pre->next = node; // 本层前一个节点next指向本节点
                    pre = pre->next;
                }
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            pre->next = NULL; // 本层最后一个节点指向NULL
        }
        return root;
    }
};
```

二刷：

```php
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            Node* pre;
            for(int i = 0; i < size; i++){
                Node* node = que.front();
                que.pop();
                if(i == 0){
                    pre = node;
                }else{
                    pre->next = node;
                    pre = node;
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            pre->next = NULL;
        }
        return root;
    }
};
```

## 二叉树序列化

### 297. 二叉树的序列化与反序列化

**序列化**是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205012111971.jpeg" alt="img" style="zoom:40%;" /></div>

```php
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

使用**拼接字符串**的方式把二叉树**序列化**。

```php
class Codec {
public:

    // 序列化
    string serialize(TreeNode* root) {
        if(!root) return "#";
        return to_string(root->val) + " " + serialize(root->left) + " " + serialize(root->right);
    }

     TreeNode* build(istringstream& iss){
        string tmp;
        iss>>tmp;
        if(tmp == "#") return NULL;
        TreeNode* root = new TreeNode(stoi(tmp));
        root->left = build(iss);
        root->right = build(iss);
        return root;
    }
    // 反序列化
    TreeNode* deserialize(string data) {
        istringstream iss(data);
        return build(iss);
    }
};
```

### 652、寻找重复的子树

给定一棵二叉树 root，返回所有重复的子树。

对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。

如果两棵树具有相同的结构和相同的结点值，则它们是重复的。

**示例**：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204172024286.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,3,4,null,2,4,null,null,4]
输出：[[2,4],[4]]
```

如何知道以某个节点为根的子树是不是重复的，是否应该加入结果列表中，需要知道什么信息呢？

**你需要知道以下两点**：

1、以我为根的这棵二叉树（子树）长啥样？——**后序遍历**

2、以其他节点为根的子树都长啥样？——利用哈希表存起来做比较

现在，明确了要用后序遍历，那应该怎么描述一棵二叉树的模样呢？二叉树的前序/中序/后序遍历结果可以描述二叉树的结构。所以，可以通过**拼接字符串**的方式把二叉树**序列化**。

```php
class Solution {
public:
    unordered_map<string, int> map;
    vector<TreeNode*> res;
    
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
		traverse(root);
		return res;
    }
    //定义：输入一个节点，将以该节点为根节点的二叉树序列化，返回序列化后的字符串
    string traverse(TreeNode* root){
		if(!root) return "#";
       	string left = traverse(root->left);
        string right = traverse(root->right);
        // 后序位置获取二叉树序列化后的字符串
        string str = left + "," + right + "," + to_string(root->val);
        if(map[str] == 1){
            res.push_back(root);
        }
        map[str]++;
        return str;
    }
};
```

## 构造二叉树

😶‍🌫️二叉树的构造问题一般都是使用「**分解问题**」的思路：**构造整棵树 = 根节点 + 构造左子树 + 构造右子树**。

### 617、合并二叉树

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221505893.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
```

```php
class Solution {
public:
    //定义：输入两二叉树根节点，返回二叉树处理后的根节点
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(!root1) return root2;
        if(!root2) return root1;
        root1->val += root2->val; 
        root1->left = mergeTrees(root1->left, root2->left);
        root1->right = mergeTrees(root1->right, root2->right);
        return root1;
    }
};
```

### 654、构造最大二叉树

给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 `nums` 构建的**最大二叉树**。

**示例**：

```php
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
               6
             /  \
            3    5
             \   /      
              2 0   
               \
                1
```

首先遍历数组把找到最大值 `maxVal`，从而把根节点 `root` 构造出来，然后对 `maxVal` 左边的数组和右边的数组进行递归构建，作为 `root` 的左、右子树。

```php
//定义二叉树
struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x):val(x), left(nullptr), right(nullptr){}
}

class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
		return build(nums, 0, nums.size() - 1);
    }
    
    //定义：输入数组和区间左右端点，返回构造的最大二叉树的根节点
    TreeNode* build(vector<int>& nums, int lo, int hi){
        if(lo > hi){
            return nullptr;
        }
        // 找到数组中的最大值和对应的索引
        // 注意不能写成 int rootVal = 0;
        int rootVal = INT32_MIN;
        int index = 0;
        for(int i = lo; i <= hi; i++){
			if(rootVal < nums[i]){
                rootVal = nums[i];
                index = i;
            }
        }
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(nums, lo, index - 1);
        root->right = build(nums, index + 1, hi);
        return root;
    }
};
```

### 105、从前序与中序遍历序列构造二叉树

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

```php
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171505952.jpeg" alt="img" style="zoom: 67%;" /></div>

前序遍历`preorder` 和 中序遍历`inorder` 数组中的元素分布有如下特点：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171510562.png" alt="image-20220417151011413" style="zoom:80%;" /></div>

找到根节点是很简单的，前序遍历的第一个值 `preorder[0]` 就是根节点的值。关键在于如何通过根节点的值，将 `preorder` 和 `postorder` 数组划分成两半，构造根节点的左右子树？

**暴力**方法是利用for循环遍历整个数组找出`index`，但是通过 for 循环遍历的方式去确定 `index` 效率不算高，可以进一步优化：采用**哈利表**的查到 `rootVal` 对应的 `index`，数组元素无序且不重复，故采用 `unordered_map`来实现，底层由**哈希表**实现。

本道题的一大**难点**在于如何确定左右数组对应的起始索引和终止索引，这个可以通过左子树的节点数推导出来，假设左子树的节点数为 `leftSize`，那么 `preorder` 数组上的索引情况是这样的：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171511724.png" alt="image-20220417151152530" style="zoom:60%;" /></div>

做这种题目一定要画示意图，选择闭区间，若索引填错了，就会引起栈溢出的错误。

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
		int size = inorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[inorder[i]] = i;
        }
        return build(preorder, 0, size - 1, inorder, 0, size - 1);
    }
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd, 
                    vector<int>& inorder, int inStart, int inEnd){
    	if(preStart > preEnd){
            return nullptr;
        }
        //根节点的值，注意不能写成 int rootVal = preorder[0];
        int rootVal = preorder[preStart];
        //利用哈希表查询到 rootVal 在 inorder 中的索引 index
        int index = map[rootVal];
        
        int leftSize = index - inStart;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(preorder, preStart + 1, preStart + leftSize, 
                          inorder, inStart, index - 1);
    	root->right = build(preorder, preStart + leftSize + 1, preEnd,
                           inorder, index + 1, inEnd);
    	return root;
    }
};
```

### 106、从中序与后序遍历序列构造二叉树

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。

```php
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
```

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171505952.jpeg" alt="img" style="zoom: 67%;" /></div>

 `postoder` 和 `inorder` 对应的状态如下：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171615448.png" alt="image-20220417161545340" style="zoom:60%;" /></div>

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
		int size = inorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[inorder[i]] = i;
        }
        return build(inorder, 0, size - 1, postorder, 0, size - 1);
    }
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& inorder, int inStart, int inEnd, 
                    vector<int>& postorder, int postStart, int postEnd){
    	if(postStart > postEnd){
            return nullptr;
        }
        //根节点的值
        int rootVal = postorder[postEnd];
        //利用哈希表查询到 rootVal 在 inorder 中的索引 index
        int index = map[rootVal];
        
        int leftSize = index - inStart;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(inorder, inStart, index - 1, 
                          postorder, postStart, postStart + leftSize - 1);
    	root->right = build(inorder, index + 1, inEnd,
                           postorder, postStart + leftSize, postEnd - 1);
    	return root;
    }
};
```

### 889、根据前序和后序遍历构造二叉树

给定两个整数数组，`preorder` 和 `postorder` ，其中 `preorder` 是一个具有 **无重复** 值的二叉树的前序遍历，`postorder` 是同一棵树的后序遍历，重构并返回二叉树。

如果存在多个答案，您可以返回其中 **任何** 一个。

```php
输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
输出：[1,2,3,4,5,6,7]
```

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171628354.jpeg" alt="img" style="zoom:60%;" /></div>

这道题和前两道题有一个本质的区别：

**通过前序中序，或者后序中序遍历结果可以确定一棵原始二叉树，但是通过前序后序遍历结果无法确定原始二叉树**。这道题，你可以确定根节点，但是无法确切的知道左右子树有哪些节点，以下是一种构造方法：

1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值。

2、然后把前序遍历结果的第二个元素作为左子树的根节点的值。

3、在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可。

假设前序遍历的第二个元素是左子树的根节点，但实际上左子树有可能是空指针，那么这个元素就应该是右子树的根节点。由于这里无法确切进行判断，所以导致了最终答案的不唯一。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171639321.png" alt="image-20220417163947215" style="zoom:70%;" /></div>

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {
		int size = postorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[postorder[i]] = i;
        }
        return build(preorder, 0, size - 1, postorder, 0, size - 1);
    }
    
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd, 
                    vector<int>& postorder, int postStart, int postEnd){
    	if(postStart > postEnd){
            return nullptr;
        }
        if(postStart == postEnd){
            return new TreeNode(postorder[postStart]);
        }
        //根节点的值
        int rootVal = preorder[preStart];
        int leftRootVal = preorder[preStart + 1];
        //利用哈希表查询到左子树根节点 leftRoot 在 postorder 中的索引 index
        int index = map[leftRootVal];
        
        int leftSize = index - postStart + 1;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(preorder, preStart + 1, preStart + leftSize, 
                          postorder, postStart, index);
    	root->right = build(preorder, preStart + leftSize + 1, preEnd,
                           postorder, index + 1, postEnd - 1);
    	return root;
    }
};
```



## 层序遍历

### 102、二叉树的层序遍历

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181828285.png" alt="102.二叉树的层序遍历" style="zoom:50%;" /></div>

需要借用一个辅助数据结构即**队列**来实现，队列**先进先出**，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。

while循环用来从上到下遍历二叉树的每一层，for循环用来从左到右遍历每一层当中的节点。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181834096.png" alt="image-20220418183400018" style="zoom:50%;" /></div>

```php
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

### 107、二叉树的层次遍历II

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181838870.png" alt="107.二叉树的层次遍历II" style="zoom:55%;" /></div>

相对于102.二叉树的层序遍历，就是最后把`result`数组反转一下就可以了。

```php
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        reverse(result.begin(), result.end()); // 在这里反转一下数组即可
        return result;
    }
};
```

### 103、 二叉树的锯齿形层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 

**示例：**

<img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251142392.jpeg" alt="img" style="zoom:60%;" />

```php
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
```

这题和 ⌈[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal)⌋ 类似，只是要控制遍历方向，另外使用**双向队列**`deque`来记录遍历路径`path。

**解法一**：使用数组的**深度奇偶变化**来控制遍历顺序

```php
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        if(root) que.push(root);
        int depth = 0;
        while(!que.empty()){
            int size = que.size();
            // 双向队列记录遍历路径
            deque<int> path;
            depth++;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                // 深度为奇数则从左到右
                if(depth % 2 != 0) path.push_back(node->val);
                // 深度为偶数则从右到左
                else path.push_front(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(vector<int>{path.begin(), path.end()});
        }
        return res;
    }
};
```

**解法二**：用一个**布尔变量** `flag` 控制遍历方向

```php
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        bool flag = true;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            // 双向队列记录遍历路径
            deque<int> path;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                // flag为true则从左到右
                if(flag == true) path.push_back(node->val);
                // flag为
                else path.push_front(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            flag = !flag;
            res.push_back(vector<int>{path.begin(), path.end()});
        }
        return res;
    }
};
```

### 515、在每个树行中找最大值

给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204190917513.png" alt="515.在每个树行中找最大值" style="zoom:60%;" /></div>

**解法一**：递归遍历二叉树

我们先来思考这样一个问题：如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？

`traverse`遍历函数的参数当中只包含`TreeNode* root `可以吗？**不行！**还要加上节点所在的层数`level`，因为在递归遍历的过程中，遍历左子树接着遍历右子树，层数leve并不是一直增加，同一层的节点level是一样的，所以不能定义全局变量，而是要放在`traverse`函数参数当中维护。

**如果要在遍历二叉树的过程中获取每个节点所在的层数，则要在`traverse`遍历函数的参数当中添加层数`level`。**

```php
// 定义：二叉树遍历函数，输入一个节点和该节点所在的层数
void traverse(TreeNode root, int level) {
    if (root == null) {
        return;
    }
    // 前序位置
    printf("节点 %s 在第 %d 层", root, level);
    //注意如下代码中的 level + 1
    traverse(root.left, level + 1);
    traverse(root.right, level + 1);
}

// 人为设定根节点位于第1层
traverse(root, 1);
```

回到本题当中，本质上是一个求节点最大值的问题，但问题是**如何保证参与比大小求最值的节点来自于同一层呢**？

🥳在遍历二叉树的过程中获取每一个节点所在的层数，比较层数就可以了呀，也就是说**这是一个涉及二叉树层数的问题，要在`traverse`遍历函数的参数当中添加层数`level`。**

假设二叉树的层数从第0层开始算，res数组所以默认从0开始：

- 假设数组遍历到二叉树第2层某节点，而res数组当中只有**2**个元素（已获取前两层的最大值），即`level == res.size()`，表示res数组当中无该层任何节点，**将该节点添加到res数组中**；

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191022409.png" alt="image-20220419102205366" style="zoom:60%;" /></div>

- 假设数组遍历到二叉树第2层某节点，而res数组当中只有**3**个元素（已获取前三层的最大值），表示该层已经有节点被访问了，则**比大小取最值**；

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191022406.png" alt="image-20220419102248364" style="zoom:60%;" /></div>

所以也就是说，核心代码逻辑要使用`if`语句分以上两种情况讨论。

版本一：

```php
class Solution {
public:
	vector<int> res;
    void traverse(TreeNode* root,int level){
        if(root == NULL){
            return;
        }
        if(level == res.size()){//每层第一个节点
            res.push_back(root->val);
        } else{					//每层第一个节点之外的节点
            res[level] = max(res[level], root->val);
        } 
        traverse(root->left, level + 1);
        traverse(root->right, level + 1);
    }
    vector<int> largestValues(TreeNode* root) {
        //二叉树层数从第0层开始算
        traverse(root,0);
        return res;
    }
};
```

版本二：

```php
class Solution {
public:
    vector<int> res;
    int depth = 0;
    vector<int> largestValues(TreeNode* root) {
        traverse(root);
        return res;
    }

    void traverse(TreeNode* root){
        if(!root) return;
        if(depth == res.size()) res.push_back(root->val);
        else{
            res[depth] = max(res[depth], root->val);
        }
        depth++;
        traverse(root->left);
        traverse(root->right);
        depth--;
    }
};
```

**注意**：这个版本的代码会把根节点当成第一层，但是本题是要将根节点当作第0层，所以主要代码逻辑要写在`depth++;`前面，或者初始化`int depth = -1`。

**解法二**：层序遍历

层序遍历，取每一层的最大值。

- while循环开始遍历每一层时，创建最大值`maxValue`；
- for循环遍历该层每一个节点，顺便更新`maxValue`；
- 退出for循环，该层所有节点遍历完成，`maxValue`放入结果数据`result`中；

```php
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<int> result;
        while (!que.empty()) {
            int size = que.size();
            int maxValue = INT_MIN; // 取每一层的最大值
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                maxValue = node->val > maxValue ? node->val : maxValue;
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(maxValue); // 把最大值放进数组
        }
        return result;
    }
};
```

### 199、二叉树的右视图

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191815468.png" alt="199.二叉树的右视图" style="zoom:55%;" /></div>

**解法一**：递归遍历

要找到每一层最右边的节点，涉及**二叉树节点所在层数**的问题，还是使用 ⌈**515、在每个树行中找最大值**⌋ 中的遍历框架。

**注意**：由于本题是要找每层最右侧节点，所以**先遍历右子树再遍历左子树**，这样每层遍历时首先访问到的就是要求的节点。

```php
class Solution {
public:
    vector<int> res;

    vector<int> rightSideView(TreeNode* root) {
        traverse(root, 0);
        return res;
    }

    void traverse(TreeNode* root, int level){
        if(!root) return;
		//这一层还没有记录值，说明 root 就是右侧视图的第一个节点
        if(res.size() == level){
            res.push_back(root->val);
        }
		// 注意，这里反过来，先遍历右子树再遍历左子树
        // 这样，首先遍历的一定是右侧节点
        traverse(root->right, level + 1);
        traverse(root->left, level + 1);
    }
};
```

那如果是要求二叉树的**左视图**呢，那就**先遍历左子树再遍历右子树**呗，又AC了一题😜。

**解法二**：层序遍历

```php
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
		queue<TreeNode*> que;
        vector<int> res;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(i == (size - 1)){
                    res.push_back(node->val);
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return res;
    }
};
```

### 637、二叉树的层平均值

给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。

**示例 ：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201555469.jpeg" alt="img" style="zoom:60%;" /></div>

```php
输入：root = [3,9,20,null,null,15,7]
输出：[3.00000,14.50000,11.00000]
```

层序遍历轻松完成，**注意**：先求一层所有节点的和，最后再作除法。


```php
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> res;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            // 记录当前层所有节点之和
            double sum = 0;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                sum += node->val;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            // 记录当前行的平均值
            res.push_back(sum / size);
        }
        return res;
    }
};
```



## 二叉树的所有路径

**257、二叉树的所有路径**

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202033263.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

遍历二叉树，这道题和 ⌈**515、在每个树行中找最大值**⌋ 在思路上很相似——回溯，遍历函数 `traverse `的参数中还需要加入路径 `path`。再说的通俗一点儿就是，左右子树都需要对路径`path`进行操作，所以左子树操作完需要**回溯**，右子树才能再操作，不然右子树操作的就是左子树操作完的结果。

```php
class Solution {
public:
    // 记录所有从根节点到叶子节点的路径
    vector<string> res;
	string path;
    vector<string> binaryTreePaths(TreeNode* root) {
        // 记录 traverse 函数递归时的路径
        traverse(root, path);
        return res;
    }
    
    void traverse(TreeNode* root, string path){
        if(!root) return;
        path += to_string(root->val);
        //遍历到叶子节点，路径path加入res数组
        if(!root->left && !root->right){
            res.push_back(path);
        }
        traverse(root->left, path + "->");
        traverse(root->right, path + "->");
    }
};
```

## 最近公共祖先

何为最近公共祖先呢？

**如果一个节点能够在它的左右子树中分别找到`p`和`q`，则该节点为`LCA`节点**。

先来实现一个简单的算法：输入一棵**没有重复元素**的二叉树根节点`root`和目标值`val1`，`val2`，写一个函数寻找树中值为`val1`**或**`val2`的节点。

```php
//定义：在以 root 为根的二叉树中寻找值为 val1 或 val2 的节点
TreeNode* find(TreeNode* root, int val1, int val2){
    if(!root) return nullptr;
    // 前序位置，在每一个节点处判断
    if(root->val == val1 || root->val == val2) return root;
    //左右子树寻找
    TreeNode* left = find(root->left, val1, val2);
    TreeNode* right = find(root->right, val1, val2);
    // 后序位置，已经知道左右子树是否存在目标值
	return left != nullptr ? left : right;
}
```

**最近公共祖先系列问题的解法都是把这个函数作为框架的**。

### 236、二叉树的最近公共祖先

给你输入一棵**不含重复值**的二叉树，以及**存在于树中的**两个节点`p`和`q`，请你计算`p`和`q`的最近公共祖先节点。

最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241139188.jpg" alt="640" style="zoom:40%;" /></div>

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241140957.jpg" alt="640 (1)" style="zoom:40%;" /></div>

在`find`函数的后序位置，如果发现`left`和`right`都非空，就说明当前节点是`LCA`节点，即解决了第一种情况；

在`find`函数的前序位置，如果找到一个值为`val1`或`val2`的节点则直接返回，恰好解决了第二种情况。

```php
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return find(root, p->val, q->val);
    }
    // 在二叉树中寻找 val1 和 val2 的最近公共祖先节点
    TreeNode* find(TreeNode* root, int val1, int val2){
        if(!root) return nullptr;
        // 前序位置，在每一个节点处判断，遇到目标值立即返回
        if(root->val == val1 || root->val == val2) return root;
        //左右子树寻找
        TreeNode* left = find(root->left, val1, val2);
        TreeNode* right = find(root->right, val1, val2);
        // 后序位置，已经知道左右子树是否存在目标值
        if(left && right) return root;
        return left != nullptr ? left : right;
    }
};
```

因为题目说了`p`和`q`一定存在于二叉树中(这点很重要），所以即便我们遇到`q`就直接返回，根本没遍历到`p`，也依然可以断定`p`在`q`底下，`q`就是`LCA`节点。

### 1676、二叉树的最近公共祖先 IV

给定一棵[二叉树](https://so.csdn.net/so/search?q=二叉树&spm=1001.2101.3001.7020)的根节点 `root `和 TreeNode 类对象的数组（列表） `nodes`，返回 `nodes `中所有节点的最近公共祖先（LCA）。数组（列表）中所有节点都**存在于该二叉树中**，且二叉树中所有节点的值都是互不相同的。

**示例 3:**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241156790.png" alt="在这里插入图片描述" style="zoom:100%;" /></div>

```php
输入: root = [3,5,1,6,2,0,8,null,null,7,4], nodes = [7,6,2,4]
输出: 5
解释: 节点 7、6、2 和 4 的最近公共祖先节点是 5。
```

依然给你输入一棵不含重复值的二叉树，但这次不是给你输入`p`和`q`两个节点了，而是给你输入一个包含若干节点的列表`nodes`（这些节点都存在于二叉树中），其实换汤不换药，还是使用这个框架。

为了高效地查找数组`nodes`中的元素，使用**哈希表**来装载数组元素，`unordered_set` 来实现。

```php
class Solution {
public:
	unordered_set<int> set; 
    TreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*> &nodes) {
    	for(TreeNode* node: nodes){
            set.insert(node->val);
        }
        return find(root);
    }
    
    // 在二叉树中寻找 val 的最近公共祖先节点
    TreeNode* find(TreeNode* root){
        if(!root) return nullptr;
        // 前序位置，在每一个节点处判断，遇到目标值立即返回
        if(set.count(root->val)) return root;
        //左右子树寻找
        TreeNode* left = find(root->left);
        TreeNode* right = find(root->right);
        // 后序位置，已经知道左右子树是否存在目标值
        if(left && right) return root;
        return left != nullptr ? left : right;
    }
};
```

不过需要注意的是，这两道题的题目都明确告诉我们**这些节点必定存在于二叉树中**，如果没有这个前提条件，就需要修改代码了。

### 1644、二叉树的最近公共祖先 II

给定一棵二叉树的根节点 root，返回给定节点 p 和 q 的最近公共祖先（LCA）节点。如果 p 或 q 之一**不存在于该二叉树中**，返回 null。树中的每个节点值都是互不相同的。

在解决标准的最近公共祖先问题时，我们在`find`函数的前序位置有这样一段代码：

```php
// 前序位置
if (root.val == val1 || root.val == val2) {
    // 如果遇到目标值，直接返回
    return root;
}
```

因为`p`和`q`都存在于树中，所以这段代码恰好可以解决最近公共祖先的第二种情况：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241140957.jpg" alt="640 (1)" style="zoom:40%;" /></div>

但对于这道题来说，`p`和`q`不一定存在于树中，所以不能遇到一个目标值就直接返回，而应该对二叉树进行**完全搜索**（遍历每一个节点），如果发现`p`或`q`不存在于树中，那么是不存在`LCA`的。

哪种写法能够对二叉树进行完全搜索呢？只需要**把前序位置的判断逻辑放到后序位置**即可：

```php
TreeNode find(TreeNode root, int val) {
    if (root == null) {
        return null;
    }
    // 先去左右子树寻找
    TreeNode left = find(root.left, val);
    TreeNode right = find(root.right, val);
    // 后序位置，判断 root 是不是目标节点
    if (root.val == val) {
        return root;
    }
    // root 不是目标节点，再去看看哪边的子树找到了
    return left != null ? left : right;
}
```

同时还要使用`bool`变量记录一下`p` 和 `q `是否存在于二叉树中，若有一个不存在，则返回NULL；若两者都存在，则找到了`LCA`。

```php
class Solution{
    // 用于记录 p 和 q 是否存在于二叉树中
    bool findP = false;
    bool findQ = false;
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
		if(!findP || !findQ) return nullptr;
        // p 和 q 都存在二叉树中，才有公共祖先
        return find(root, p->val, q->val);
	}
	
	// 在二叉树中寻找 val1 和 val2 的最近公共祖先节点
	TreeNode* find(TreeNode* root, int val1, int val2){
        if(!root) return nullptr;
        TreeNode* left = find(root->left, val1, val2);
        TreeNode* right = find(root->right, val1, val2);
		// 后序位置，判断当前节点是不是 LCA 节点
        if(left && right) return root;
        // 后序位置，判断当前节点是不是目标值
        if(root->val == val1 || root->val == val2){
            if(root->val == val1) findP = true;
            if(root->val == val2) findQ = true;
            return root;
        }
        return left != nullptr ? left : right;
    }
};
```

### 235、二叉搜索树的最近公共祖先

输入一棵不含重复值的**二叉搜索树**，以及**存在于树中**的两个节点`p`和`q`，请计算`p`和`q`的最近公共祖先节点。

把之前的解法代码复制过来肯定也可以解决这道题，但没有用到 BST「**左小右大**」的性质，显然效率不是最高的。

在标准的最近公共祖先问题中，我们要在**后序位置**通过左右子树的搜索结果来判断当前节点是不是`LCA`：

```php
TreeNode left = find(root.left, val1, val2);
TreeNode right = find(root.right, val1, val2);

// 后序位置，判断当前节点是不是 LCA 节点
if (left != null && right != null) {
    return root;
}
```

但对于 BST 来说，根本不需要老老实实去遍历子树，由于 BST 左小右大的性质，**将当前节点的值与`val1`和`val2`作对比**，即可判断当前节点是不是`LCA`：

- 假设`val1 < val2`，那么`val1 <= root->val <= val2`，则说明当前节点就是`LCA`；

- 若`root->val`比`val1`还小，则需要去值更大的右子树寻找`LCA`；

- 若`root->val`比`val2`还大，则需要去值更小的左子树寻找`LCA`。

```php
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 保证 val1 较小，val2 较大
        int val1 = min(p->val, q->val);
        int val2 = max(p->val, q->val);
        return find(root, val1, val2);
    }
    // 在 BST 中寻找 val1 和 val2 的最近公共祖先节点
	TreeNode* find(TreeNode* root, int val1, int val2){
        if(!root) return nullptr;
        // 当前节点太大，去左子树找
        if(root->val > val2) return find(root->left, val1, val2);
        // 当前节点太小，去右子树找
        if(root->val < val1) return find(root->right, val1,val2);
        // val1 <= root.val <= val2
    	// 则当前节点就是最近公共祖先
        return root;
    }
};
```

### 1650、二叉树的最近公共祖先 III

给定一棵二叉树中的两个节点 `p` 和 `q`，返回它们的最近公共祖先节点（LCA）。每个节点都包含其父节点的引用（指针），`Node `的定义如下：

```php
class Node {
    int val;
    Node* left;
    Node* right;
    Node* parent;
};
```

**这道题其实不是公共祖先的问题，而是单链表相交的问题**，你把`parent`指针想象成单链表的`next`指针，题目就变成了：给你输入两个单链表的头结点`p`和`q`，这两个单链表必然会相交，请你返回相交点。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241502457.png" alt="image-20220424150259400" style="zoom:60%;" /></div>

**解法一**：双指针法

```php
class Solution {
public:
    Node* lowestCommonAncestor(Node* p, Node * q) {
		// 链表双指针技巧
    	node* a = p;
        node* b = q;
        while(a != b){
            // a 走一步，如果走到根节点，转到 q 节点
            if(!a) a = q;
            else a = a->parent;
            // b 走一步，如果走到根节点，转到 p 节点
            if(!b) b = p;
            else b = b->parent;
        }
        return a;
    };
```

**解法二**：哈希表

```php
class Solution {
public:
    Node* lowestCommonAncestor(Node* p, Node * q) {
        unordered_set<int> sign;
        // 将节点p的元素存入哈希表
        while(p!=NULL){
            sign.insert(p->val);
            p=p->parent;
        }
        // 节点q的元素在哈希表中查询，第一次出现的即LCA
        while(q!=NULL){
            if(sign.count(q->val)){
                return q;
            }
            q=q->parent;
        }
        return NULL;
    }
};
```

## 二叉搜索树

二叉搜索树（Binary Search Tree，后文简写 BST）有如下特性：

1、对于 BST 的每一个节点 `node`，左子树节点的值都比 `node` 的值要小，右子树节点的值都比 `node` 的值大。

2、对于 BST 的每一个节点 `node`，它的左侧子树和右侧子树都是 BST。

二叉搜索树并不算复杂，它可以算是数据结构领域的半壁江山，直接基于 BST 的数据结构有**AVL 树**，**红黑树**等等，拥有了自平衡性质，可以提供 **logN**级别的增删查改效率；还有 **B+** 树，线段树等结构都是基于 BST 的思想来设计的。

从做算法题的角度来看 BST，除了它的定义，还有一个重要的性质：**BST 的中序遍历结果是有序的（升序）**。

也就是说，如果输入一棵 BST，以下代码可以将 BST 中每个节点的值升序打印出来：

```php
void traverse(TreeNode* root) {
    if (!root) return;
    traverse(root->left);
    // 这里添加中序遍历代码
    traverse(root->right);
}
```

那么根据这个性质，我们来做两道算法题。

BST 相关的问题，要么利用 **BST 左小右大**的特性提升算法效率，要么利用**中序遍历**的特性满足题目的要求。

### 230. 二叉搜索树中第K小的元素

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251501802.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [3,1,4,null,2], k = 1
输出：1
```

最直接的思路就是**升序排序**，然后找第 `k` 个元素，BST 的中序遍历其实就是升序排序的结果。

```php
class Solution {
public:
    // 记录当前元素的排名
    int count = 0;
    int res;
    int kthSmallest(TreeNode* root, int k) {
        // 利用 BST 的中序遍历特性
        traverse(root, k);
        return res;
    }

    void traverse(TreeNode* root, int k){
        if(!root) return;
        traverse(root->left, k);
        /* 中序遍历代码位置 */
        count++;
        // 找到第 k 小的元素
        if(count == k){
            res = root->val;
            return;
        }
        traverse(root->right, k);
    }
};
```

### 538. 把二叉搜索树转换为累加树

给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251517895.png" alt="img" style="zoom:50%;" /></div>

```php
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

 BST 的中序遍历代码可以升序打印节点的值，那降序打印节点的值怎么办呢？

只要把递归顺序改一下就行了：

```php
void traverse(TreeNode* root) {
    if (!root) return;
    traverse(root->right);
    // 这里添加中序遍历代码
    traverse(root->left);
}
```

这段代码可以降序打印 BST 节点的值，如果维护一个外部累加变量 `sum`，然后把 `sum` 赋值给 BST 中的每一个节点，不就将 BST 转化成累加树了吗？

```php
class Solution {
public:
    //记录累加和
    int sum = 0;
    TreeNode* convertBST(TreeNode* root) {
        traverse(root);
        return root;
    }

    void traverse(TreeNode* root){
        if(!root) return;
        traverse(root->right);
        // 维护累加和
        sum += root->val;
        // 将 BST 转化成累加树
        root->val = sum;
        traverse(root->left);
    }
};
```

### 530. 二叉搜索树的最小绝对差

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271647211.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [4,2,6,1,3]
输出：1
```

中序遍历会有序遍历 BST 的节点，遍历过程中计算最小差值即可。因为要做差，所以需要维护一个`pre`指针来记录上一个节点。

```php
class Solution {
public:
    int res = INT_MAX;
    TreeNode* pre = nullptr;
    int getMinimumDifference(TreeNode* root) {
        traverse(root);
        return res;
    }

    void traverse(TreeNode* root){
        if(!root) return;
        traverse(root->left);
        //这里的if(pre)判断条件不能掉
        if(pre) res = min(root->val - pre->val, res);
        pre = root;
        traverse(root->right);
    }
};
```

### 501. 二叉搜索树中的众数

给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有众数（即出现频率最高的元素）。

如果树中有不止一个众数，可以按 **任意顺序** 返回。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271843086.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,null,2,2]
输出：[2]
```

首先，需要统计节点出现的频率，维护一个`pre`指针：

- 若`pre`为空，则为第一个节点；
- 若`pre->val == root->val`，则频率加1；
- 若`pre->val != root->val`，则出现新的节点，频率为1；

然后，与最大频率作比较：

- 若频率等于最大频率，节点加入数组；
- 若频率大于最大频率，则更新最大数值，清空数组后加入该节点；

```php
class Solution {
public:
    int count = 0;
    int maxCount = 0;
    TreeNode* pre = nullptr;
    vector<int> res;

    vector<int> findMode(TreeNode* root) {
        traverse(root);
        return res;
    }

    void traverse(TreeNode* root){
        if(!root) return;
        traverse(root->left);
        // 统计root节点出现的频率
        if(!pre) count = 1;						//第一个节点
        else if(pre->val == root->val) count++;	//与前一个节点值相等
        else count = 1;							//与前一个节点值不等
        pre = root;
        
        // 和最大频率作比较，判断是否加入数组
        if(count == maxCount) res.push_back(root->val);
        else if(count > maxCount){
            maxCount = count;
            res.clear();
            res.push_back(root->val);
        }
        traverse(root->right);
    }
};
```

### 剑指 Offer 36. 二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

以下面的二叉搜索树为例：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301207350.png" alt="img" style="zoom:40%;" /></div>

我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。

![img](https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png)

特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。

1. **排序链表：** 节点应从小到大排序，因此应使用 **中序遍历** “从小到大”访问树的节点。
2. **双向链表：** 在构建相邻节点的引用关系时，设前驱节点 `pre` 和当前节点 `cur` ，不仅应构建 `pre->right = cur` ，也应构建 `cur->left = pre` 。
3. **循环链表：** 设链表头节点 `head` 和尾节点 `tail` ，则应构建 `head->left = tail` 和 `tail->right = head` 。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301210130.png" alt="Picture1.png" style="zoom:50%;" /></div>

```php
class Solution {
public:
    Node* head = NULL;
    Node* pre = NULL;
    Node* treeToDoublyList(Node* root) {
        if(!root) return head;
        traverse(root);
        head->left = pre;
        pre->right = head;
        return head;
    }

    void traverse(Node* root){
        if(!root) return;
        traverse(root->left);
        if(pre){
            pre->right = root;
            root->left = pre;
        }else{
            head = root;
        }
        pre = root;
        traverse(root->right);
    }
};
```



------

BST 的完整定义如下：

1、BST 中任意一个节点的左子树所有节点的值都小于该节点的值，右子树所有节点的值都大于该节点的值。

2、BST 中任意一个节点的左右子树都是 BST。

有了 BST 的这种特性，就可以在二叉树中做类似**二分搜索**的操作，搜索一个元素的效率很高。

比如下面这就是一棵合法的二叉树：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251601659.png" alt="img" style="zoom:18%;" /></div>

对于 BST 相关的问题，经常会看到类似下面这样的代码逻辑：

```php
void BST(TreeNode* root, int target) {
    if (root->val == target)
        // 找到目标，做点什么
    if (root->val < target) 
        BST(root->right, target);
    if (root->val > target)
        BST(root->left, target);
}
```

这个代码框架其实和二叉树的遍历框架差不多，无非就是利用了 BST **左小右大**的特性而已。

### 98. 验证二叉搜索树

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251606314.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [2,1,3]
输出：true
```

**解法一**：中序遍历，需要比较节点和上一个节点的大小关系，所以引入指针`pre`。

```php
class Solution {
public:
    TreeNode* pre = nullptr; //记录前一个节点
    bool isValidBST(TreeNode* root) {
        // 二叉搜索树也可以为空
        if(!root) return true;
        bool left = isValidBST(root->left);
        if(pre && pre->val >= root->val) return false;
        pre = root;
        bool right = isValidBST(root->right);
        return left && right;
    }
};
```

**解法二**：二叉树定义，左小右大

这里有一个陷阱：BST 不是左小右大么，那我只要检查 `root->val > root->left->val` 且 `root->val < root->right->val` 不就行了？

这样是**错误**的，因为 BST**左小右大**的特性是指 `root->val` 要比左子树的所有节点都更大，要比右子树的所有节点都小，只检查左右两个子节点当然是不够的。

**正确解法**是通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉搜索树算法的一个小技巧吧。

```php
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return valid(root, nullptr, nullptr);
    }

    bool valid(TreeNode* root, TreeNode* min, TreeNode* max){
        if(!root) return true;
        if(min && root->val <= min->val) return false;
        if(max && root->val >= max->val) return false;
        return valid(root->left, min, root) && valid(root->right, root, max);
    }
};
```

### 669. 修剪二叉搜索树

给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271918176.jpeg" alt="img" style="zoom:40%;" /></div>

```php
输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]
```

明确了递归函数的定义之后进行思考，如果一个节点的值没有落在 `[lo, hi]` 中，有两种情况：

1、`root.val < lo`，这种情况下 `root` 节点本身和 `root` 的左子树全都是小于 `lo` 的，都需要被剪掉，返回`root` 的右子树；

2、`root.val > hi`，这种情况下 `root` 节点本身和 `root` 的右子树全都是大于 `hi` 的，都需要被剪掉， 返回`root` 的左子树；

```php
class Solution {
public:
    // 定义：删除 BST 中小于 low 和大于 high 的所有节点，返回结果 BST
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if(!root) return root;
        // 直接返回 root.right，等于删除 root 以及 root 的左子树
        if(root->val < low) return trimBST(root->right, low,high);
        // 直接返回 root.left，等于删除 root 以及 root 的右子树
        if(root->val > high) return trimBST(root->left, low, high);
        // 闭区间 [lo, hi] 内的节点什么都不做
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
};
```

### 700. 二叉搜索树中的搜索

给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204270954033.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [4,2,7,1,3], val = 2
输出：[2,1,3]
```

解法一：二叉树定义，左小右大

```php
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root) return root;
        //比目标值大，到左子树寻找
        if(root->val > val) return searchBST(root->left, val);
        //比目标值小，到右子树找
        if(root->val < val) return searchBST(root->right, val);
        //等于目标值，返回节点
        return root;
    }
};
```

解法二：中序遍历

```php
class Solution {
public:
    TreeNode* res;
    TreeNode* searchBST(TreeNode* root, int val) {
        traverse(root, val);
        return res;
    }

    void traverse(TreeNode* root, int val){
        if(!root) return;
        traverse(root->left, val);
        if(root->val == val){
            res = root;
            return;
        }
        traverse(root->right, val);
    }
};
```

### 701. 二叉搜索树中的插入操作

给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树，返回插入后二叉搜索树的根节点。 输入数据 **保证**新值和原始二叉搜索树中的任意节点值都不同。

**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271015149.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
```

如果要递归地插入或者删除二叉树节点，递归函数一定要有返回值，而且返回值要被正确的接收。

插入的过程可以分两部分：

1、寻找正确的插入位置，类似 [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree)。

2、把元素插进去，这就要把新节点以返回值的方式接到父节点上。

```php
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        // 找到空位置插入新节点
        if(!root) return new TreeNode(val);
        if(root->val > val) root->left = insertIntoBST(root->left, val);
        if(root->val < val) root->right = insertIntoBST(root->right, val);
        return root;
    }
};
```

### 450. 删除二叉搜索树中的节点

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变，返回二叉搜索树（有可能被更新）的根节点的引用。

跟插入操作类似，先「找」再「改」，先把框架写出来：

```php
TreeNode* deleteNode(TreeNode* root, int key) {
    if (root->val == key) {
        // 找到啦，进行删除
    } else if (root->val > key) {
        // 去左子树找
        root->left = deleteNode(root->left, key);
    } else if (root.val < key) {
        // 去右子树找
        root->right = deleteNode(root->right, key);
    }
    return root;
}
```

删除比插入和搜索都要复杂一些，分三种情况：

**情况 1**：`A` 恰好是末端节点，两个子节点都为空，那么直接删除：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271044120.png" alt="img" style="zoom:25%;" /></div>

```php
if (root->left == null && root->right == null)
    return null;
```

**情况 2**：`A` 只有一个非空子节点，那么它要让这个孩子接替自己的位置。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271044561.png" alt="img" style="zoom:48%;" /></div>

```php
// 排除了情况 1 之后
if (root->left == null) return root->right;
if (root->right == null) return root->left;
```

**情况 3**：`A` 有两个子节点，麻烦了，为了不破坏 BST 的性质，`A` 必须找到**左子树中最大的那个节点**，或者**右子树中最小的那个节点**来接替自己，下列为第二种方式。

![img](https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271046754.png)

```php
if (root->left != null && root->right != null) {
    // 找到右子树的最小节点
    TreeNode* minNode = getMin(root->right);
    // 把 root 改成 minNode
    root->val = minNode->val;
    // 转而去删除 minNode
    root->right = deleteNode(root->right, minNode->val);
}
```

三种情况分析完毕，填入框架，简化一下代码：

```php
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(!root) return root;
        if(root->val == key){
        	// 这两个 if 把情况 1 和 2 都正确处理了
            if(!root->left) return root->right;
            if(!root->right) return root->left;
        	// 处理情况 3
        	// 获得右子树最小的节点
            TreeNode* minNode = getMin(root->right);
            // 删除右子树最小的节点
            root->right = deleteNode(root->right, minNode->val);
            // 用右子树最小的节点替换 root 节点
            minNode->left = root->left;
            minNode->right = root->right;
            root = minNode;
        }else if(root->val > key){
            root->left = deleteNode(root->left, key);
        }else if(root->val < key){
            root->right = deleteNode(root->right, key);
        }
        return root;
    }

    TreeNode* getMin(TreeNode* root){
        // BST 最左边的就是最小的
        while(root->left) root = root->left;
        return root;
    }
};
```

### 96. 不同的二叉搜索树

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271115456.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：n = 3
输出：5
```

`dp[i]`：1到`i`为节点组成的二叉搜索树的个数为`dp[i]`，也可以理解是`i`的不同元素节点组成的二叉搜索树的个数为`dp[i]`，都是一样的。

`dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]`，`j`相当于是头结点的元素，从1遍历到`i`为止。所以递推公式：`dp[i] += dp[j - 1] * dp[i - j]`，`j - 1` 为`j`为头结点的左子树节点数量，`i - j` 为以`j`为头结点的右子树节点数量。

初始化：从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，所以初始化`dp[0] = 1`。

 ```php
 class Solution {
 public:
     int numTrees(int n) {
         vector<int> dp(n + 1);
         dp[0] = 1;
         for (int i = 1; i <= n; i++) {
             for (int j = 1; j <= i; j++) {
                 dp[i] += dp[j - 1] * dp[i - j];
             }
         }
         return dp[n];
     }
 };
 ```

### 95. 不同的二叉搜索树 II

给你一个整数 `n` ，请你生成并返回所有由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的不同 **二叉搜索树** ，可以按 **任意顺序** 返回答案。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271559371.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：n = 3
输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
```

想要构造出所有合法 BST，分以下三步：

1、穷举 `root` 节点的所有可能；

2、递归构造出左右子树的所有合法 BST；

3、给 `root` 节点穷举所有左右子树的组合。

```php
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        if(n == 0) return {};
        return build(1, n);
    }
    //定义：构造闭区间 [lo, hi] 组成的 BST
    vector<TreeNode*> build(int lo, int hi){
        vector<TreeNode*> res;
        if(lo > hi){
            res.push_back(nullptr);
            return res;
        }
        //1、穷举root节点所有可能
        for(int i = lo; i <= hi; i++){
            // 2、递归构造出左右子树的所有合法 BST
            vector<TreeNode*> leftTree = build(lo, i - 1);
            vector<TreeNode*> rightTree = build(i + 1, hi);
            // 3、给 root 节点穷举所有左右子树的组合
            for(TreeNode* left: leftTree){
                for(TreeNode* right: rightTree){
                    // i 作为根节点 root 的值
                    TreeNode* root = new TreeNode(i);
                    root->left = left;
                    root->right = right;
                    res.push_back(root);
                }
            }
        }
        return res;
    }
};
```

### 108. 将有序数组转换为二叉搜索树

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271942183.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
```

二叉树的构建问题很简单，说白了就是：构造根节点，然后构建左右子树。

一个有序数组对于 BST 来说就是**中序遍历**结果，根节点在数组中心，数组左侧是左子树元素，右侧是右子树元素。

```php
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return build(nums, 0, nums.size() - 1);
    }

    TreeNode* build(vector<int>& nums, int left, int right){
        if(left > right) return nullptr;
        int mid = (left + right + 1) / 2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = build(nums, left, mid - 1);
        root->right = build(nums, mid + 1, right);
        return root;
    }
};
```

### 109、有序链表转换二叉搜索树

给定一个单链表的头节点  `head` ，其中的元素 **按升序排序** ，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差不超过 1。

**示例:**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301023724.jpeg" alt="img" style="zoom:40%;" /></div>

```php
输入: head = [-10,-3,0,5,9]
输出: [0,-3,9,-10,null,5]
```

链表和数组相比的一个关键差异是无法通过索引快速访问元素，所以这题有几个思路：

1、把链表转化成数组，然后直接复用 [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree) 的解法。

2、稍微改写 [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree) 的解法，用 [单链表的六大解题套路](https://labuladong.github.io/article/fname.html?fname=链表技巧) 说到的双指针方法获取链表的中点，时间复杂度略高一些。

3、如果深刻理解二叉树算法，可以利用中序遍历的特点写出最优化的解法。

**解法一**：中序遍历，分冶的思想

```php
class Solution {
public:
    TreeNode* buildTree(ListNode* &p, int left, int right) {
        if (left > right) {
            return nullptr;
        }
        int mid = (left + right + 1) / 2;
        TreeNode* leftTree = buildTree(p, left, mid - 1);
        TreeNode* root = new TreeNode(p->val);
        p = p->next;
        TreeNode* rightTree = buildTree(p, mid + 1, right);
        root->left = leftTree;
        root->right = rightTree;
        return root;
    }

    TreeNode* sortedListToBST(ListNode* head) {
        int len = 0;
        for(ListNode* ptr = head; ptr != nullptr; ptr = ptr->next){
            len++;
        }
        return buildTree(head, 0, len - 1);
    }
};
```

**解法二**：**双指针**获取链表的中点

```php
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        return build(head, nullptr);
    }

    // 把链表左闭右开区间 [begin, end) 的节点构造成 BST
    TreeNode* build(ListNode* begin, ListNode* end){
        if(begin == end) return nullptr;
        ListNode* mid = getMid(begin, end);
        TreeNode* root = new TreeNode(mid->val);
        root->left = build(begin, mid);
        root->right = build(mid->next, end);
        return root;
    }

    // 获取链表左闭右开区间 [begin, end) 的中心节点
    ListNode* getMid(ListNode* begin, ListNode* end){
        ListNode* slow = begin;
        ListNode* fast = begin;
        while(fast != end && fast->next != end){
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

### 剑指 Offer 33. 二叉搜索树的后序遍历序列

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

参考以下这颗二叉搜索树：

```
     5
    / \
   2   6
  / \
 1   3
```

**示例：**

```php
输入: [1,6,3,2,5]
输出: false
```

- 利用二叉搜索树**左大右小**的性质划分左右子树：

  遍历后序遍历的`[start, end]`区间的元素，寻找第一个大于根节点的节点，索引记为 `midIndex `。此时，可划分出左子树区间 `[start, midIndex - 1]`，右子树区间` [midIndex, end - 1] `、根节点索引 `end`。

- 判断是否为二叉搜索树：
  左子树区间 `[start, midIndex - 1]`内的所有节点都应 `< postorder[end]` 。而第 1.划分左右子树 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。
  右子树区间 ` [midIndex, end - 1] ` 内的所有节点都应 `> postorder[j]` 。实现方式为遍历，当遇到 `≤postorder[j]`的节点则跳出；则可通过`index == end`判断是否为二叉搜索树。

- 返回值： 

  所有子树都需正确才可判定正确，因此使用 与逻辑符 && 连接。
  

```php
class Solution {
public:
    bool traversal(vector<int>& postorder, int start, int end) {
        /* 递归终止条件 */
        if(start > end) return true;
        int index = start;
        /* 中间处理逻辑 */
        while(postorder[index] < postorder[end]) index++;
        /* 记录分割点 */
       int midIndex = index;
        while(postorder[index] > postorder[end]) index++;
        /* 递归左右子树 */
        bool left = traversal(postorder, start, midIndex - 1);
        bool right = traversal(postorder, midIndex, end - 1);
        return index == end && left && right;
    }

    bool verifyPostorder(vector<int>& postorder) {
        return traversal(postorder, 0, postorder.size() - 1);
    }
};
```



# 二、链表

## 合并链表

### 21、合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301513096.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

用指针分别访问两个链表，根据题意比较节点的大小，赋值到新的链表。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301537463.gif" alt="1" style="zoom:50%;" /></div>

这个算法的逻辑类似于「拉拉链」，`l1, l2` 类似于拉链两侧的锯齿，指针 `p` 就好像拉链的拉索，将两个有序链表合并。合并后 list1 和 list2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可。

**代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 `dummy` 节点**，它相当于是个占位符，可以避免处理空指针的情况，降低代码的复杂性。

```php
struct ListNode{
    int val;
    ListNode* next;
    ListNode(int x): val(x), next(nullptr){}
}

class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        //虚拟头节点
        ListNode* dummy = new ListNode(-1);
        ListNode* p = dummy, *p1 = list1, *p2 = list2;
        while(p1 && p2){
            // 比较 p1 和 p2 两个指针，将值较小的的节点接到 p 指针
            if(p1->val > p2->val){
                p->next = p2;
                p2 = p2->next;
            }else{
                p->next = p1;
                p1 = p1->next;
            }
            p = p->next;
        }
        p->next = !p1 ? p2 : p1;
        return dummy->next;
    }
};
```

### 23、合并 k 个有序链表

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例：**

```php
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

本题是上一道题目[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists) 的延伸，利用 [优先级队列（二叉堆）](https://labuladong.github.io/article/fname.html?fname=二叉堆详解实现优先级队列) 进行节点排序即可。

**具体步骤**

1.  新建虚拟节点`dummy`，指向合并后的链表， 新建一个优先级队列`priority_queue` ；
2.  将所有的链表的第一个元素加入队列；
3.  将队列的第一元素出队列，插入到新链表的尾部；
4.  将第一元素的下一个元素入队，比较剩下的链表的第1个元素和第i个链表的第2个元素；
5.  重复3-4步, 得到新的队列。

```php
class Solution {
public:
    struct Comp{
        //小根堆，从小到大排序
        bool operator()(ListNode* l1,ListNode* l2){
            return l1->val > l2->val;
        }
    }; 
    
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        //优先级队列，最小堆
        priority_queue<ListNode*, vector<ListNode*>, Comp> pq;
        //虚拟节点
		ListNode* dummy = new ListNode(-1);
        ListNode* p = dummy;
        // 将所有的链表的第一个元素加入队列
        for(ListNode* head : lists){
            if(head) pq.push(head);
        }
        while(!pq.empty()){
            // 获取最小节点，接到结果链表中
            ListNode *node = pq.top(); pq.pop();
            p->next = node;
            p = p->next;
            if(node->next) pq.push(node->next);
        }
        return dummy->next;
    }
};
```

这个算法是面试常考题，它的时间复杂度是多少呢？

优先级队列 `pq` 中的元素个数最多是 `k`，所以一次 `poll` 或者 `add` 方法的时间复杂度是 `O(logk)`；所有的链表节点都会被加入和弹出 `pq`，**所以算法整体的时间复杂度是 `O(Nlogk)`，其中 `k` 是链表的条数，`N` 是这些链表的节点总数**。

### 86. 分隔链表

给你一个链表的头节点 `head `和一个特定值 `x` ，请你对链表进行分隔，使得所有小于` x` 的节点都出现在 大于或等于 `x` 的节点之前。

你应当 保留 两个分区中每个节点的初始相对位置。

**示例**：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101321822.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```

只需要遍历链表的所有节点，小于`x`的放到一个小的链表中，大于等于`x`的放到一个大的链表中，最后再把这两个链表串起来即可。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101328225.png" alt="image.png" style="zoom:80%;" /></div>

```php
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode* small = new ListNode(0);
        ListNode* smallHead = small;
        ListNode* large = new ListNode(0);
        ListNode* largeHead = large;
        ListNode* p = head;
        while(p){
            if(p->val < x){
                small->next = p;
                small = small->next;
            }else{
                large->next = p;
                large = large->next;
            }
            p = p->next;
        }
        large->next = nullptr;
        small->next = largeHead->next;
        return smallHead->next;
    }
};
```

### 328. 奇偶链表

给定单链表的头节点 `head `，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。第一个节点的索引被认为是奇数 ， 第二个节点的索引为偶数 ，以此类推。

请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。

**示例**：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205111119176.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入: head = [1,2,3,4,5]
输出: [1,3,5,2,4]
```

分别维护两个链表，一个链表接入索引为奇数的节点，另一个链表接入索引为偶数的节点，然后组合两个链表。

```php
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        int count = 1;
        ListNode* l1 = new ListNode(0);
        ListNode* l2 = new ListNode(0);
        ListNode* head1 = l1, * head2 = l2;
        while(head){
            if(count % 2 !=0){
                l1->next = head;
                l1 = l1->next;
            }else{
                l2->next = head;
                l2 = l2->next;
            }
            head = head->next;
            count++;
        }
        l1->next = head2->next;
        l2->next = nullptr;
        return head1->next;
    }
};
```

## 倒数第K个节点

### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 `6` 个节点，从头节点开始，它们的值依次是 `1、2、3、4、5、6`。这个链表的倒数第 `3` 个节点是值为 `4` 的节点。

**示例：**

```php
给定一个链表: 1->2->3->4->5, 和 k = 2.
返回链表 4->5.
```

如何**只遍历一次链表**，就算出倒数第 `k` 个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出**只需遍历一次链表**的解法。

首先，我们先让一个指针 `p1` 指向链表的头节点 `head`，然后走 `k` 步：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051454870.png" alt="image-20220505145454803" style="zoom:70%;" /></div>

趁这个时候，再用一个指针 `p2` 指向链表头节点 `head`，此时若把`p1`当作链表尾部的`NULL`，则`p2` 就是倒数第`k`个节点。：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051459242.png" alt="image-20220505145900194" style="zoom:65%;" /></div>

那如何让`p1`成为真正的尾节点而且`p1`和`p2`之间的位置关系保持不变呢？俩指针一同向后移动呗，直到`p1 == NULL`为止，此时`p1`就是真正的倒数第`k`个节点。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051501166.png" alt="image-20220505150130107" style="zoom:60%;" /></div>

这道题目重点在于理解双指针移动的原理与方法，方法理解了，代码实现就非常简单了。

```php
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode* p1 = head;
        //p1 移动 k 步
        for(int i = 0; i < k; i++){
            p1 = p1->next;
        }
        ListNode* p2 = head;
        //p1 和 p2 一同向后移动
        while(p1){
            p1 = p1->next;
            p2 = p2->next;
        }
        return p2;
    }
};
```

### 19. 删除链表的倒数第 N 个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051516856.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

要删除倒数第 `n` 个节点，就得获得倒数第 `n + 1` 个节点的指针。获取单链表的倒数第 `k` 个节点，就是想考察 [双指针技巧](https://labuladong.github.io/article/fname.html?fname=链表技巧) 中快慢指针的运用，一般都会要求**只遍历一次链表**，就算出倒数第 `k` 个节点。

**注意**：使用了**虚拟头结点**的技巧，也是**为了防止出现空指针**的情况。比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点，但第一个节点前面已经没有节点了，这就会出错。但有了虚拟头节点 `dummy` 的存在，就避免了这个问题，能够对这种情况进行正确的删除。

```php
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        // 删除倒数第 n 个，要先找倒数第 n + 1 个节点
        ListNode* p = find(dummy, n + 1);
        // 删掉倒数第 n 个节点
        p->next = p->next->next;
        return dummy->next;
    }

    ListNode* find(ListNode* head, int n){
        ListNode* p1 = head;
        for(int i = 0; i < n; i++){
            p1 = p1->next;
        }
        ListNode* p2 = head;
        while(p1){
            p1 = p1->next;
            p2 = p2->next;
        }
        return p2;
    }
};
```

## 中间节点 && 环形链表

### 876. 链表的中间结点

**题目**：给定一个头结点为 `head` 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。

如果想一次遍历就得到中间节点，就要使用「快慢指针」的技巧：

我们让两个指针 `slow` 和 `fast` 分别指向链表头结点 `head`。**每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步，这样当 `fast` 走到链表末尾时，`slow` 就指向了链表中点**。

上述思路的代码实现如下：

```php
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* fast = head, * slow = head;
        // 快指针走到末尾时停止
        while(fast && fast->next){
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
};
```

需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。另外，这段代码稍加修改就可以直接用到**判断链表成环**的算法题上。

### 141. 环形链表

给你一个链表的头节点 `head` ，判断链表中是否有环。如果链表中存在环，则返回 `true` ； 否则，返回 `false` 。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051537983.png" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

经典题目了，要使用双指针技巧中的**快慢指针**，每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。

如果 `fast` 最终遇到空指针，说明链表中没有环；如果 `fast` 最终和 `slow` 相遇，那肯定是 `fast` 超过了 `slow` 一圈，说明链表中含有环。

```php
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* fast = head, * slow = head;
        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
            // 快慢指针相遇，说明含有环
            if(fast == slow) return true;
        }
        // 不含有环
        return false;
    }
};
```

### 142. 环形链表 II

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。**不允许修改** 链表。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051547660.png" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。**为什么要这样呢？

假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051554426.png" alt="image-20220505155433363" style="zoom:60%;" /></div>

`fast` 一定比 `slow` 多走了 `k` 步，这多走的 `k` 步其实就是 `fast` 指针在环里转圈圈，所以 `k` 的值就是环长度的「整数倍」。

假设相遇点距环的起点的距离为 `m`，那么结合上图的 `slow` 指针，环的起点距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点。

巧的是，如果从相遇点继续前进 `k - m` 步，也恰好到达环起点。因为结合上图的 `fast` 指针，从相遇点开始走k步可以转回到相遇点，那走 `k - m` 步肯定就走到环起点了：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051555842.png" alt="image-20220505155537778" style="zoom:65%;" /></div>

所以，只要我们把快慢指针中的任一个重新指向 `head`，然后两个指针同速前进，`k - m` 步后一定会相遇，相遇之处就是环的起点了。

```php
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head, * slow = head;
        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
            if(fast == slow) break;
        }
        // fast 遇到空指针说明没有环
        if(!fast || !fast->next) return NULL;
        // 重新指向头结点
        slow = head;
        // 快慢指针同步前进，相交点就是环起点
        while(slow != fast){
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
```



## 翻转链表

### 206. 反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080908373.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```
**解法一**：递归法

```php
class Solution {
public:
    //定义：将以head为起点的链表反转，并返回反转之后的头结点
    ListNode* reverseList(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode* last = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return last;
    }
};
```

**对于递归算法，最重要的就是明确递归函数的定义**。具体来说，我们的 `reverse` 函数定义是这样的：

**输入一个节点 `head`，将「以 `head` 为起点」的链表反转，并返回反转之后的头结点**。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080927213.png" alt="image-20220508092702168" style="zoom:70%;" /></div>

那么输入 `reverse(head)` 后，会在这里进行递归：

```php
ListNode* last = reverseList(head->next);
```

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080928389.png" alt="image-20220508092851331" style="zoom:60%;" /></div>

`reverseList(head->next)` 执行完成后，整个链表就成了这样：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080930542.png" alt="image-20220508093035486" style="zoom:80%;" /></div>

并且根据函数定义，`reverse` 函数会返回反转之后的头结点，我们用变量 `last` 接收了。

现在再来看下面的代码：

```php
head->next->next = head;
```

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080931640.png" alt="image-20220508093159593" style="zoom:70%;" /></div>

接下来：

```php
head->next = NULL;
return last;
```

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080933837.png" alt="image-20220508093304789" style="zoom:70%;" /></div>

这样整个链表就反转过来了！递归代码就是这么简洁优雅，不过其中有两个地方需要注意：

1、递归函数要有 base case，也就是这句：

```php
if(!head || !head->next) return head;
```

意思是如果链表为空或者只有一个节点的时候，反转结果就是它自己，直接返回即可。

2、当链表递归反转之后，新的头结点是 `last`，而之前的 `head` 变成了最后一个节点，别忘了链表的末尾要指向 null：

```php
head->next = NULL;
```

理解了这两点后，我们就可以进一步深入了，接下来的问题其实都是在这个算法上的扩展。

**解法二**：迭代法，双指针法

```php
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr, * cur = head, * tmp = head;
        while(cur){
            tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
};
```

注意：

- `pre`和`cur`指针都要向后移动，所以还要记录`cur`后一个节点的指针`tmp`，因为`cur->next = pre`改变了`cur`的指向，`cur`下一个节点无法获得，所以要在该语句之前用`tmp`提前记录；
- `while`循环结束后，`cur`指向`NULL`，`pre`指向翻转后链表的头节点，所以要返回`pre`；
- 还可理解为在`[head, NULL)`区间（左闭右开）内翻转链表。

### 92. 反转链表 II

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080949720.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

首先思考一下：**如何反转链表前 N 个节点**？

比如说对于下图链表，执行 `reverseN(head, 3)`：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080941826.png" alt="image-20220508094103751" style="zoom:60%;" /></div>

解决思路和反转整个链表差不多，只要稍加修改即可：

```php
ListNode* successor = NULL; // 后驱节点

// 定义：反转以 head 为起点的 n 个节点，返回新的头结点
ListNode* reverseN(ListNode* head, int n) {
    if (n == 1) {
        // 记录第 n + 1 个节点
        successor = head->next;
        return head;
    }
    // 以 head->next 为起点，需要反转前 n - 1 个节点
    ListNode* last = reverseN(head->next, n - 1);
    head->next->next = head;
    // 让反转之后的 head 节点和后面的节点连起来
    head->next = successor;
    return last;
}
```

具体的区别：

1、base case 变为 `n == 1`，反转一个元素，就是它本身，同时**要记录后驱节点**。

2、刚才我们直接把 `head->next` 设置为 NULL，因为整个链表反转后原来的 `head` 变成了整个链表的最后一个节点。但现在 `head` 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 `successor`（第 `n + 1` 个节点），反转之后将 `head` 连接上。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080944191.png" alt="image-20220508094450123" style="zoom:60%;" /></div>

这个函数能看懂，就离实现「**反转一部分链表**」不远了。

首先，如果 `left == 1`，就相当于反转链表开头的 `right` 个元素，也就是我们刚才实现的功能；

如果 `right != 1` 怎么办？如果我们把 `head` 的索引视为 1，那么我们是想从第 `left` 个元素开始反转；如果把 `head->next` 的索引视为 1 呢？那么相对于 `head->next`，反转的区间应该是从第 `left - 1` 个元素开始的；那么对于 `head->next->next` 呢……

```php
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if(left == 1) return reverseN(head, right);
        // 前进到反转的起点触发 base case
        head->next = reverseBetween(head->next, left - 1, right - 1);
        return head;
    }
    
    ListNode* successor = nullptr;
    ListNode* reverseN(ListNode* head, int n){
        if(n == 1){
            successor = head->next;
            return head;
        }
        ListNode* last = reverseN(head->next, n - 1);
        head->next->next = head;
        head->next = successor;
        return last;
    }
};
```

### 24. 两两交换链表中的节点

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例**：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205091351001.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**解法一**：递归法

```php
class Solution {
public:
    // 定义：返回链表节点两两交换后的头节点
    ListNode* swapPairs(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode* newHead = head->next;
        head->next = swapPairs(newHead->next);
        newHead->next = head;
        return newHead;
    }
};
```

**解法二**：迭代法

初始时，`cur`指向虚拟头结点，然后进行如下三步：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101114825.png" alt="image-20220510111404759" style="zoom:80%;" /></div>

打羊胎素展开链表：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101115513.png" alt="image-20220510111531466" style="zoom:80%;" /></div>

```php
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        ListNode* p = dummy;
        while(p->next && p->next->next){
            ListNode* tmp1 = p->next;
            ListNode* tmp2 = tmp1->next;
            ListNode* tmp3 = tmp2->next;
            p->next = tmp2;
            tmp2->next = tmp1;
            tmp1->next = tmp3;
            p = tmp1;
        }
        return dummy->next;
    }
};
```

### 25. K 个一组翻转链表

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205081042731.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

输入 `head`，`reverseKGroup` 函数能够把以 `head` 为头的这条链表进行翻转。我们要充分利用这个递归函数的定义，把原问题分解成规模更小的子问题进行求解。

**1、先反转以 `head` 开头的 `k` 个元素**。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205081131992.png" alt="image-20220508113128936" style="zoom:60%;" /></div>

**2、将第 `k + 1` 个元素作为 `head` 递归调用 `reverseKGroup` 函数**。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205081133011.png" alt="image-20220508113301946" style="zoom:65%;" /></div>

**3、将上述两个过程的结果连接起来**。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205081134446.png" alt="image-20220508113408376" style="zoom:70%;" /></div>

**4、最后函数递归完成之后就是这个结果，完全符合题意：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205081135250.png" alt="image-20220508113522192" style="zoom:70%;" /></div>

```php
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(!head) return nullptr;
        ListNode* a = head, * b = head;
        // 区间 [a, b) 包含 k 个待反转元素
        for(int i = 0; i < k; i++){
            // 不足 k 个，不需要反转，base case
            if(!b) return head;
            b = b->next;
        }
        // 反转前 k 个元素
        ListNode* newHead = reverse(a, b);
        // 递归反转后续链表并连接起来
        a->next = reverseKGroup(b, k);
        return newHead;
    }
	// 定义：反转区间 [a, b) 的元素，注意是左闭右开
    ListNode* reverse(ListNode* a, ListNode* b){
        ListNode* pre =nullptr, * cur = a, * nxt = a;
        while(cur != b){
            nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }
};
```

这里使用迭代法来写翻转链表reverse函数，其中三个指针的移动过程如图所示：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205081154922.gif" alt="8" style="zoom:40%;" /></div>

### 61. 旋转链表

给你一个链表的头节点 `head `，旋转链表，将链表每个节点向右移动 `k `个位置。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101131379.jpeg" alt="img" style="zoom:50%;" /></div>

**示例**：

```php
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

假设链表的长度为`len`，为了将链表每个节点向右移动 `k` 个位置，只需要将链表的后` k % len`个节点移动到链表的最前面，然后将链表的后`k % len`个节点和前 `len - k`个节点连接到一块即可。

1、首先遍历整个链表，求出链表的长度`n`，并找出链表的尾节点`tail`。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101146039.png" alt="image-20220510114658985" style="zoom:60%;" /></div>

2、由于`k`可能很大，所以我们令 `k = k % n`，然后再次从头节点`head`开始遍历，找到第`n - k`个节点p，那么1 ~ p是链表的前 `n - k`个节点，p+1 ~ n是链表的后`k`个节点。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101148095.png" alt="image-20220510114840024" style="zoom:60%;" /></div>

3、接下来就是依次执行 `tail->next = head`，`head = p->next`，`p->next = nullptr`，将链表的后`k`个节点和前 `n - k`个节点拼接到一块，并让`head`指向新的头节点`p->next`，新的尾节点即p节点的`next`指针指向`null`。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101152961.png" alt="image-20220510115248903" style="zoom:60%;" /></div>

4、最后返回链表的新的头节点`head`。

```php
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head || !k) return head;
        int len = 1;
        ListNode* tail = head;
        while(tail->next){
            tail = tail->next;
            len++;
        }
        k = k % len;
        ListNode* p = head;
        for(int i = 1; i < len - k; i++){
            p = p->next;
        }
        tail->next = head;
        head = p->next;
        p->next = nullptr;
        return head;
    }
};
```

## 链表重排

### 143. 重排链表

给定一个单链表 L 的头节点 head ，单链表 L 表示为：`L0 → L1 → … → Ln - 1 → Ln`
请将其重新排列后变为：`L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …`
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

**示例**：

```php
输入：head = [1,2,3,4]
输出：[1,4,2,3]
```

注意观察链表是怎么变化的，方法：**寻找链表中点 + 链表逆序 + 合并链表**

目标链表即为将原链表的左半端和反转后的右半端合并后的结果，这样我们的任务即可划分为三步：

- 找到原链表的中点（参考「876. 链表的中间结点」），使用快慢指针来 O(N) 地找到链表的中间节点。
- 将原链表的右半端反转（参考「206. 反转链表」），使用迭代法实现链表的反转。
- 将原链表的两端合并，因为两链表长度相差不超过 1，因此直接合并即可。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205102108369.png" alt="image-20220510210809294" style="zoom:70%;" /></div>

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205102110174.png" alt="image-20220510211017122" style="zoom:70%;" /></div>

```php
class Solution {
public:
    void reorderList(ListNode* head) {
        if(!head) return;
        ListNode* mid = middleNode(head);
        ListNode* l1 = head;
        ListNode* l2 = mid->next;
        mid->next = nullptr;
        l2 = reverse(l2);
        merge(l1, l2);
    }

    ListNode* middleNode(ListNode* head){
        ListNode* slow = head, * fast = head->next;
        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }

    ListNode* reverse(ListNode* head){
        ListNode* pre = nullptr, * cur = head;
        while(cur){
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }

    void merge(ListNode* l1, ListNode* l2){
        ListNode* p1, * p2;
        while(l1 && l2){
            p1 = l1->next;
            p2 = l2->next;
            l1->next = l2;
            l1 = p1;
            l2->next = l1;
            l2 = p2;
        }
    }
};
```

### 148. 排序链表

给你链表的头结点 `head `，请将其按 **升序** 排列并返回排序后的链表 。

**示例**：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205102114649.jpeg" alt="img" style="zoom:40%;" /></div>

```php
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

通过递归实现链表**归并排序**，有以下两个环节：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205111006447.png" alt="Picture2.png" style="zoom:40%;" /></div>



```php
class Solution {
public:
    // 定义：排序链表
    ListNode* sortList(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode* mid = middleNode(head);
        ListNode* l1 = head, * l2 = mid->next;
        mid->next = nullptr;
        // 注意：两链表排序之后再合并
        return merge(sortList(l1), sortList(l2));
    }
	// 定义：找链表的中心节点
    ListNode* middleNode(ListNode* head){
        // 注意 fast = head->next，若有两个中心节点则找到靠左的那个
        ListNode* fast = head->next, * slow = head;
        while(fast && fast->next){
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
	// 定义：合并两个链表
    ListNode* merge(ListNode* list1, ListNode* list2) {
        if(!list1 && !list2) return list1;
        ListNode* dummy = new ListNode(-1);
        ListNode* p = dummy, *p1 = list1, *p2 = list2;
        while(p1 && p2){
            if(p1->val > p2->val){
                p->next = p2;
                p2 = p2->next;
            }else{
                p->next = p1;
                p1 = p1->next;
            }
            p = p->next;
        }
        p->next = !p1 ? p2 : p1;
        return dummy->next;
    }
};
```

### 234. 回文链表

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205081046989.jpeg" alt="img" style="zoom:60%;" /></div>

```php
输入：head = [1,2,2,1]
输出：true
```

[双指针技巧](https://labuladong.github.io/algo/2/18/23/)，从两端向中间逼近即可：

```cpp
bool isPalindrome(string s) {
    int left = 0, right = s.length - 1;
    while (left < right) {
        if (s[left] != s[right]) return false;
        left++; right--;
    }
    return true;
}
```

以上代码很好理解，**因为回文串是对称的，所以正着读和倒着读应该是一样的，这一特点是解决回文串问题的关键**。

**解法一**：利用后序遍历

如果想正序打印链表中的 `val` 值，可以在前序遍历位置写代码；反之，如果想倒序遍历链表，就可以在后序遍历位置操作。

```php
class Solution {
public:
    ListNode* left;
    bool res = true;
    bool isPalindrome(ListNode* head) {
        left = head;
        traverse(head);
        return res;
    }

    void traverse(ListNode* right){
        if(!right) return;
        traverse(right->next);
        // 后序遍历位置
        if(left->val != right->val) res = false;
        left = left->next;
    }
};
```

利用后序遍历，算法的时间和空间复杂度都是 O(N)。能不能不用额外的空间，解决这个问题呢？

**解法二**：优化空间复杂度

1、先通过 ⌈双指针技巧⌋ 中的快慢指针来找到链表的中点：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205091153464.png" alt="image-20220509115340350" style="zoom:60%;" /></div>

2、如果`fast`指针没有指向`null`，说明链表长度为奇数，`slow`还要再前进一步：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205091155968.png" alt="image-20220509115524911" style="zoom:60%;" /></div>

3、从`slow`开始反转后面的链表，现在就可以开始比较回文串了：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205091156704.png" alt="image-20220509115621642" style="zoom:50%;" /></div>

```php
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* left = head;
        ListNode* right = middleNode(head);
        right = reverseList(right);
        while(right){
            if(left->val != right->val) return false;
            left = left->next;
            right = right->next;
        }
        return true;
    }

    ListNode* middleNode(ListNode* head){
        ListNode* slow = head, * fast = head;
        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
        }
        // 链表长度为奇数，`slow还要再前进一步
        if(fast) slow = slow->next;
        return slow;
    }

    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr, * cur = head, * tmp = head;
        while(cur){
            tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
};
```

算法总体的时间复杂度 O(N)，空间复杂度 O(1)，已经是最优的了。

另一个版本，找中间节点函数`middleNode`另一种写法：

```php
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* mid = middleNode(head);
        ListNode* left = head, * right = mid->next;
        mid->next = nullptr;
        right = reverse(right);
        while(right){
            if(left->val != right->val) return false;
            left = left->next;
            right = right->next;
        }
        return true;
    }
    
    ListNode* middleNode(ListNode* head){
        ListNode* fast = head->next, * slow = head;
        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }

    ListNode* reverse(ListNode* head){
        ListNode* pre = nullptr, * cur = head, * tmp;
        while(cur){
            tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
};
```

## 删除链表元素

### 203. 移除链表元素

给你一个链表的头节点 `head `和一个整数 `val `，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 新的头节点 。

**示例**：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205091330784.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

```php
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* pre = dummy;
        while(pre->next){
            if(pre->next->val == val){
                pre->next = pre->next->next;
            }else{
                pre = pre->next;
            }
        }
        return dummy->next;
    }
};
```

### 83. 删除排序链表中的重复元素

给定一个已排序的链表的头 `head` ， 删除所有重复的元素，使每个元素只出现一次 ，返回 已排序的链表 。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101206051.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [1,1,2,3,3]
输出：[1,2,3]
```

```php
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head) return nullptr;
        ListNode* pre = head;
        while(pre->next){
            if(pre->val == pre->next->val){
                pre->next = pre->next->next;
            }else{
                pre = pre->next;
            }
        }
        return head;
    }
};
```

## 445. 两数相加 II

给定两个 非空链表 `l1`和 `l2 `来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。可以假设除了数字 0 之外，这两个数字都不会以零开头。

**示例**：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205111138200.png" alt="img" style="zoom:50%;" /></div>

```php
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
```

本题的主要难点在于链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，可以使用**栈**：把所有数字压入栈中，再依次取出相加，**计算过程中需要注意进位的情况**。

```php
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        stack<int> s1, s2;
        while(l1){
            s1.push(l1->val);
            l1 = l1->next;
        }
        while(l2){
            s2.push(l2->val);
            l2 = l2->next;
        }
        int carry = 0, cur = 0; //进位，本位
        ListNode* res = nullptr;
        while(!s1.empty() || !s2.empty() || carry){
            int a = s1.empty() ? 0 : s1.top();
            int b = s2.empty() ? 0 : s2.top();
            if(!s1.empty()) s1.pop();
            if(!s2.empty()) s2.pop();
            int sum = a + b + carry;
            carry = sum / 10;
            cur = sum % 10;
            ListNode* node = new ListNode(cur);
            node->next = res;
            res = node;
        }
        return res;
    }
};
```

## 160. 相交链表

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null`。图示两个链表在节点 `c1` 开始相交。题目数据 **保证** 整个链式结构中不存在环。**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051608009.png" alt="img" style="zoom:50%;" /></div>



这题难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051844252.png" alt="image-20220505184443179" style="zoom:50%;" /></div>

如果用两个指针 `p1` 和 `p2` 分别在两条链表上前进，并不能**同时**走到公共节点，也就无法得到相交节点 `c1`。

**解决这个问题的关键是，通过某些方式，让 `p1` 和 `p2` 能够同时到达相交节点 `c1`。**

**解法一**：使用双指针

如果用两个指针 `p1` 和 `p2` 分别在两条链表上前进，我们可以让 `p1` 遍历完链表 `A` 之后开始遍历链表 `B`，让 `p2` 遍历完链表 `B` 之后开始遍历链表 `A`，这样相当于「逻辑上」两条链表接在了一起。

如果这样进行拼接，就可以让 `p1` 和 `p2` 同时进入公共部分，也就是同时到达相交节点 `c1`：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051848637.png" alt="image-20220505184819556" style="zoom:50%;" /></div>

那如果两个链表没有相交点，是否能够正确的返回 null 呢？这个逻辑可以覆盖这种情况的，相当于 `c1` 节点是 null 空指针嘛，可以正确返回 null。

```php
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* p1 = headA, * p2 = headB;
        while(p1 != p2){
            if(!p1) p1 = headB;
            else p1 = p1->next;
            if(!p2) p2 = headA;
            else p2 = p2->next;
        }
        return p1;
    }
};
```

运用了相同方法的题目：**1650、二叉树的最近公共祖先 III**

## 剑指 Offer 06. 从尾到头打印链表

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

**示例：**

```php
输入：head = [1,3,2]
输出：[2,3,1]
```

利用链表后序遍历位置即可得到倒序遍历的结果。

```php
class Solution {
public:
    vector<int> res;
    vector<int> reversePrint(ListNode* head) {
        traverse(head);
        return res;
    }

    void traverse(ListNode* head){
        if(!head) return;
        traverse(head->next);
        res.push_back(head->val);
    }
};
```



# 三、数组

## 双指针

### 26. 删除有序数组中的重复项

给你一个 **升序排列** 的数组 `nums `，请你原地删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新长度。元素的相对顺序 应该保持 一致 。

示例：

```php
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

有序序列去重的通用解法就是我们前文 [双指针技巧](https://labuladong.github.io/article/fname.html?fname=双指针技巧) 中的快慢指针技巧。

让慢指针 `slow` 走在后面，快指针 `fast` 走在前面探路，找到一个不重复的元素就告诉 `slow` 并让 `slow` 前进一步。这样当 `fast` 指针遍历完整个数组 `nums` 后，`nums[0..slow]` 就是不重复元素。

```php
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(!nums.size()) return 0;
        int slow = 0, fast = 0;
        while(fast < nums.size()){
            if(nums[fast] != nums[slow]){
                slow++;
                nums[slow] = nums[fast];
            }
            fast++;
        }
        // 数组长度为 索引 + 1
        return slow + 1;
    }
};
```

### 27. 移除元素

给你一个数组 `nums` 和一个值 `val`，你需要原地移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

```php
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
```

题目要求我们把 `nums` 中所有值为 `val` 的元素原地删除，依然需要使用快慢指针技巧：如果 `fast` 遇到值为 `val` 的元素，则直接跳过，否则就赋值给 `slow` 指针，并让 `slow` 前进一步。

注意这里和有序数组去重的解法有一个细节差异，我们这里是先给 `nums[slow]` 赋值然后再给 `slow++`，这样可以保证`nums[0..slow-1]` 是不包含值为 `val` 的元素的，最后的结果数组长度就是 `slow`。

```php
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int fast = 0, slow = 0;
        while(fast < nums.size()){
            if(nums[fast] != val){
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```

### 283. 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

示例：

```php
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

可以直接复用 [27. 移除元素](https://leetcode.cn/problems/remove-element) 的解法，先移除所有 0，然后把最后的元素都置为 0，就相当于移动 0 的效果。

```php
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // 去除nums中的所有0
        int len = remove(nums, 0);
        // 将len之后的所有元素赋值为 0
        while(len < nums.size()){
            nums[len] = 0;
            len++;
        }
    }
	// 定义：在数组nums中移除值为val的元素，返回数组长度
    int remove(vector<int>& nums, int val){
        int fast = 0, slow = 0;
        while(fast < nums.size()){
            if(nums[fast] != val){
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```

## NSUM 问题

### 167. 两数之和-输入有序数组

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。

```php
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
```

只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 `left` 和 `right` 就可以调整 `sum` 的大小：

```php
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0, right = numbers.size() - 1;
        while(left < right){
            int sum = numbers[left] + numbers[right];
            if(sum == target){
                return {left + 1, right + 1}; 
            }else if(sum < target){
                left++;
            }else{
                right--;
            }
        }
        return {};
    }
};
```

### 1. 两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

```php
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
```

若要求返回数组元素，则可以可将数组排序后使用双指针：

```php
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int left = 0, right = nums.size() - 1;
        while(left < right){
            int sum = nums[left] + nums[right];
            if(sum == target){
                return {nums[left], nums[right]};
            }else if(sum < target){
                left++;
            }else{
                right--;
            }
        }
        return {};
    }
};
```

若要求返回数组元素的索引，则无法使用上述的双指针，因为排序后数组元素的索引有变动，可使用哈希表：

```php
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> map;
        for(int i = 0; i < nums.size(); i++){
            auto it = map.find(target - nums[i]);
            if(it != map.end()) return {it->second, i};
            map[nums[i]] = i;
        }
        return {};
    }
};
```

魔改题目：

`nums` 中可能有多对元素之和都等于 `target`，请你的算法返回所有和为 `target` 的元素对，**其中不能出现重复**。

```php
vector<vector<int>> twoSumTarget(vector<int>& nums, int target) {
    // nums 数组必须有序
    sort(nums.begin(), nums.end());
    int lo = 0, hi = nums.size() - 1;
    vector<vector<int>> res;
    while (lo < hi) {
        int sum = nums[lo] + nums[hi];
        // 记录索引 lo 和 hi 最初对应的值
        int left = nums[lo], right = nums[hi];
        if (sum < target) {
            while (lo < hi && nums[lo] == left) lo++;
        } else if (sum > target) {
            while (lo < hi && nums[hi] == right) hi--;
        } else {
            res.push_back({left, right});
            // 跳过所有重复的元素
            while (lo < hi && nums[lo] == left) lo++;
            while (lo < hi && nums[hi] == right) hi--;
        }
    }
    return res;
}
```

### 15. 三数之和

给你一个包含 `n` 个整数的数组 `nums`，判断 `nums `中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且**不重复**的三元组。

```php
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

这个问题怎么解决呢？**很简单，穷举呗**。现在我们想找和为 `target` 的三个数字，那么对于第一个数字，可能是什么？`nums` 中的每一个元素 `nums[i]` 都有可能！

那么，确定了第一个数字之后，剩下的两个数字可以是什么呢？其实就是和为 `target - nums[i]` 的两个数字呗，那不就是 `twoSum` 函数解决的问题么🤔。

**关键点在于，不能让第一个数重复，至于后面的两个数，我们复用的 `twoSum` 函数会保证它们不重复**。所以代码中必须用一个 while 循环来保证 `3Sum` 中第一个元素不重复。

```php
class Solution {
public:

    /* 计算数组 nums 中所有和为 target 的三元组 */
    vector<vector<int>> threeSum(vector<int>& nums) {
        // 数组得排个序
        sort(nums.begin(), nums.end());
        int n = nums.size();
        vector<vector<int>> res;
        // 穷举 threeSum 的第一个数
        for (int i = 0; i < n; i++) {
            // 对 target - nums[i] 计算 twoSum
            vector<vector<int>> tuples = twoSumTarget(nums, i + 1, - nums[i]);
            // 如果存在满足条件的二元组，再加上 nums[i] 就是结果三元组
            for (vector<int>& tuple : tuples) {
                tuple.push_back(nums[i]);
                res.push_back(tuple);
            }
            // 跳过第一个数字重复的情况，否则会出现重复结果
            while (i < n - 1 && nums[i] == nums[i + 1]) i++;
        }
        return res;
    }
    vector<vector<int>> twoSumTarget(vector<int>& nums, int start, int target) {
        // nums 数组必须有序
        sort(nums.begin(), nums.end());
        int lo = start, hi = nums.size() - 1;
        vector<vector<int>> res;
        while (lo < hi) {
            int sum = nums[lo] + nums[hi];
            // 记录索引 lo 和 hi 最初对应的值
            int left = nums[lo], right = nums[hi];
            if (sum < target) {
                while (lo < hi && nums[lo] == left) lo++;
            } else if (sum > target) {
                while (lo < hi && nums[hi] == right) hi--;
            } else {
                res.push_back({left, right});
                // 跳过所有重复的元素
                while (lo < hi && nums[lo] == left) lo++;
                while (lo < hi && nums[hi] == right) hi--;
            }
        }
        return res;
    }    
};
```

代码优化一下：

再比如 LeetCode 的 `3Sum` 问题，找 `target == 0` 的三元组：

```php
vector<vector<int>> threeSum(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    // n 为 3，从 nums[0] 开始计算和为 0 的三元组
    return nSumTarget(nums, 3, 0, 0);        
}
```

`nSumTarget`函数实现见下一题。

### 18. 四数之和

给你一个由 `n `个整数组成的数组 `nums `，和一个目标值 `target `。请你找出并返回满足下述全部条件且不重复的四元组` [nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

- 0 <= a, b, c, d < n

- a、b、c 和 d 互不相同

- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按任意顺序返回答案 。

```php
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

都到这份上了，`4Sum` 完全就可以用相同的思路：穷举第一个数字，然后调用 `3Sum` 函数计算剩下三个数，最后组合出和为 `target` 的四元组。总结 `nSum` 函数：

```php
/* 注意：调用这个函数之前一定要先给 nums 排序 */
// n为整数个数，start为双指针初始值，target为目标值
vector<vector<int>> nSumTarget(vector<int>& nums, int n, int start, int target) {
    int size = nums.size();
    vector<vector<int>> res;
    // 至少是 2Sum，且数组大小不应该小于 n
    if (n < 2 || size < n) return res;
    // 2Sum 是 base case
    if (n == 2) {
        // 双指针那一套操作
        int lo = start, hi = size - 1;
        while (lo < hi) {
            int left = nums[lo], right = nums[hi];
            int sum = left + right;                
            if (sum < target) {
                while (lo < hi && nums[lo] == left) lo++;
            } else if (sum > target) {
                while (lo < hi && nums[hi] == right) hi--;
            } else {
                res.push_back({left, right});
                while (lo < hi && nums[lo] == left) lo++;
                while (lo < hi && nums[hi] == right) hi--;
            }
        }
    } else {
        // n > 2 时，递归计算 (n-1)Sum 的结果
        for (int i = start; i < size; i++) {
            vector<vector<int>> sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
            for (vector<int>& arr : sub) {
                // (n-1)Sum 加上 nums[i] 就是 nSum
                arr.push_back(nums[i]);
                res.push_back(arr);
            }
            while (i < size - 1 && nums[i] == nums[i + 1]) i++;
        }
    }
    return res;
}
```

实际上就是把之前的题目解法合并起来了，`n == 2` 时是 `twoSum` 的双指针解法，`n > 2` 时就是穷举第一个数字，然后递归调用计算 `(n-1)Sum`，组装答案。

**需要注意的是，调用这个 `nSum` 函数之前一定要先给 `nums` 数组排序**，因为 `nSum` 是一个递归函数，如果在 `nSum` 函数里调用排序函数，那么每次递归都会进行没有必要的排序，效率会非常低。

比如说现在我们写 LeetCode 上的 `4Sum` 问题：

```php
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    sort(nums.begin(), nums.end());
    // n 为 4，从 nums[0] 开始计算和为 target 的四元组
    return nSumTarget(nums, 4, 0, target);
}
```

那么，如果让你计算 `100Sum` 问题，直接调用这个函数就完事儿了。

## 二分搜索

### 704. 二分查找

给定一个 `n `个元素有序的（升序）整型数组 `nums `和一个目标值 `target  `，写一个函数搜索 `nums `中的 `target`，如果目标值存在返回下标，否则返回 -1。

```php
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
```

版本一：

```php
//闭区间[left, right]
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right)
        {
            int mid = left + (right - left) / 2;
            if (nums[mid] > target)  right = mid - 1;
            else if (nums[mid] < target)  left = mid + 1;
            else return mid;
        }
        return -1;
    }
};
```

版本二：

```php
//左闭右开区间[left, right)
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size();
        while (left < right)
        {
            int mid = left + (right - left) / 2;
            if (nums[mid] > target) right = mid;
            else if (nums[mid] < target) left = mid + 1;
            else return mid;
        }
        return -1;
   }
};
```

🔥while 循环的条件是 <=还是 <？

`right = nums.size() - 1`相当于两端都闭区间 `[left, right]`，`right = nums.size()`相当于左闭右开区间 `[left, right)`，因为索引大小为 `nums.length` 是越界的。

什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：

```php
if(nums[mid] == target) return mid; 
```

但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？**搜索区间为空的时候应该终止**，意味着你没得找了，就等于没找到嘛。

版本一：

`while(left <= right)` 的终止条件是 `left == right + 1`，写成区间的形式就是 `[right + 1, right]`，或者带个具体的数字进去 `[3, 2]`，可见**这时候区间为空**，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。

版本二：

`while(left < right)` 的终止条件是 `left == right`，写成区间的形式就是 `[right, right)`，或者带个具体的数字进去 `[2, 2)`，**这时候区间为空**，所以这时候 while 循环终止是正确的，直接返回 -1 即可。

### 367. 有效的完全平方数

给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。

```php
输入：num = 16
输出：true
```

可使用二分查找，因为`num`是正整数，所以若正整数`a`满足`axa= num`，则z一定满足`1<a<num`，于是我们可以将`1`和`num`作为二分查找搜索区间的初始边界。

```php
class Solution {
public:
    bool isPerfectSquare(int num) {
        int left = 0, right = num;
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            long square = (long) mid * mid;
            if (square < num) {
                left = mid + 1;
            } else if (square > num) {
                right = mid - 1;
            } else {
                return true;
            }
        }
        return false;
    }
};
```

### 34. 在排序数组中查找元素的第一个和最后一个位置

给定一个按照**升序**排列的整数数组 `nums`，和一个目标值 `target`，找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。

```php
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

1. **寻找左侧边界的二分查找**：

因为初始化 `right = nums.size()`，所以决定了「搜索区间」是 `[left, right)`，所以决定了 `while (left < right)`，同时也决定了 `left = mid + 1` 和 `right = mid`。因为需找到 `target `的最左侧索引，所以当 `nums[mid] == target `时不要立即返回，而要收紧右侧边界以锁定左侧边界。

2. **寻找右侧边界的二分查找**：

因为初始化 `right = nums.size()`，所以决定了「搜索区间」是 `[left, right)`，所以决定了 `while (left < right)`，同时也决定了 `left = mid + 1` 和 `right = mid`。因为需找到 target 的最右侧索引，所以当 `nums[mid] == target` 时不要立即返回，而要收紧左侧边界以锁定右侧边界。又因为收紧左侧边界时必须 left = mid + 1，所以最后无论返回 left 还是 right，必须减一。


```php
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = leftBound(nums, target);
        int right = rightBound(nums, target);
        // [left, right)
        if(left == right) return {-1, -1};
        return {left, right - 1};
    }
	// 找左边界
    int leftBound(vector<int>& nums, int target){
        int left = 0, right = nums.size();
        while(left < right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) right = mid;
            else if(nums[mid] > target) right = mid;
            else left = mid + 1;
        }
        return left;
    }
	//找右边界
    int rightBound(vector<int>& nums, int target){
        int left = 0, right = nums.size();
        while(left < right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) left = mid + 1;
            else if(nums[mid] > target) right = mid;
            else left = mid + 1;
        }
        return right;
    }
};
```

### 35. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

```php
输入: nums = [1,3,5,6], target = 5
输出: 2
```

当目标元素 `target` 不存在数组 `nums` 中时，搜索左侧边界的二分搜索的返回值可以做以下几种解读：

1、返回的这个值是 `nums` 中大于等于 `target` 的最小元素索引。

2、返回的这个值是 `target` 应该插入在 `nums` 中的索引位置。

3、返回的这个值是 `nums` 中小于 `target` 的元素个数。

比如在有序数组 `nums = [2,3,5,7]` 中搜索 `target = 4`，**搜索左边界**的二分算法会返回 2，带入上面的说法，都是对的。

所以以上三种解读都是等价的，可以根据具体题目场景灵活运用，显然这里我们需要的是第二种。

```php
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size();
        while(left < right){
            int mid = left + (right - left) / 2;
            if(nums[mid] >= target) right = mid;
            else left = mid + 1;
        }
        return left;
    }
};
```

## 滑动窗口

### 3. 无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

```
输入: s = "abcabcbb"
输出: 3 
```

这就是变简单了，连 `need` 和 `valid` 都不需要，而且更新窗口内数据也只需要简单的更新计数器 `window` 即可。当 `window[c]` 值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动 `left` 缩小窗口了。

唯一需要注意的是，在哪里更新结果 `res` 呢？我们要的是最长无重复子串，哪一个阶段可以保证窗口中的字符串是没有重复的呢？

这里和之前不一样，要在收缩窗口完成后更新 `res`，因为窗口收缩的 `while `条件是存在重复元素的，换句话说收缩完成后一定保证窗口中没有重复。

```php
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> window;
        int left = 0, right = 0, res = 0;
        while(right < s.size()){
            char c = s[right];
            right++;
            window[c]++;
            while(window[c] > 1){
                char d = s[left];
                left++;
                window[d]--;
            }
            res = max(res, right - left);
        }
        return res;
    }
};
```

### 209. 长度最小的子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` ，找出该数组中满足其和` ≥ target` 的长度最小的 连续子数组` [numsl, numsl+1, ..., numsr-1, numsr] `，并返回其长度。如果不存在符合条件的子数组，返回 0 。

```php
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
```

不过需要强调的是，**题目说了 `nums` 数组中的元素都是正数，有了这个前提才能使用滑动窗口算法**，因为窗口扩大时窗口内元素之和必然增大，窗口缩小时窗口内元素之和必然减小。

如果 `nums` 数组中包含负数，则窗口扩大时元素和不见得就增大，窗口缩小时元素和不见得就减小，这种情况就不能单纯使用滑动窗口技巧了，可能需要混合动态规划和单调队列来做。

```php
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left = 0, right = 0, sum = 0, res = INT_MAX;
        while(right < nums.size()){
            sum += nums[right];
            right++;
            while(sum >= target && left < right){
                res = min(res, right - left);
                sum -= nums[left];
                left++;
            }
        }
        return res == INT_MAX ? 0 : res;

    }
};
```

### 76. 最小覆盖子串

给你一个字符串 `s` 、一个字符串 `t `，返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串`""` 。

```php
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

滑动窗口的思路：

1、我们在字符串 `S` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个「窗口」。

2、我们先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T` 中的所有字符）。

3、此时，我们停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了）。同时，每次增加 `left`，我们都要更新一轮结果。

4、重复第 2 和第 3 步，直到 `right` 到达字符串 `S` 的尽头。

这个思路其实也不难，**第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解**，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「**滑动窗口**」这个名字的来历。

初始状态：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205201152976.png" alt="image-20220520115217917" style="zoom:80%;" /></div>

增加 `right`，直到窗口 `[left, right)` 包含了 `T` 中所有字符：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205201153833.png" alt="image-20220520115349776" style="zoom:80%;" /></div>

现在开始增加 `left`，缩小窗口 `[left, right)`：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205201154016.png" alt="image-20220520115450943" style="zoom:80%;" /></div>

直到窗口中的字符串不再符合要求，`left` 不再继续移动：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205201155927.png" alt="image-20220520115526871" style="zoom:80%;" /></div>

之后重复上述过程，先移动 `right`，再移动 `left`…… 直到 `right` 指针到达字符串 `S` 的末端，算法结束。

首先，初始化 `window` 和 `need` 两个哈希表，记录窗口中的字符和需要凑齐的字符：

```php
unordered_map<char, int> need, window;
for (char c : t) need[c]++;
```

然后，使用 `left` 和 `right` 变量初始化窗口的两端，不要忘了，区间 `[left, right)` 是**左闭右开**的，所以初始情况下窗口没有包含任何元素：

```php
int left = 0, right = 0;
int valid = 0; 
while (right < s.size()) {
    // 开始滑动
}
```

**其中 `valid` 变量表示窗口中满足 `need` 条件的字符个数**，如果 `valid` 和 `need.size` 的大小相同，则说明窗口已满足条件，已经完全覆盖了串 `T`。

如果一个字符进入窗口，应该增加 `window` 计数器；如果一个字符将移出窗口的时候，应该减少 `window` 计数器；当 `valid` 满足 `need` 时应该收缩窗口；应该在收缩窗口的时候更新最终结果。

```php
string minWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t){
        need[c]++;
    }
    int left = 0, right = 0, valid = 0; // valid表示窗口中满足 need 条件的字符个数
    // 记录最小覆盖子串的起始索引及长度
    int start = 0, len = INT_MAX;
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 扩大窗口
        right++;
        // 进行窗口内数据的一系列更新
        if (need.count(c)) {
            window[c]++;
            if (window[c] == need[c]) valid++;
        }

        // 判断左侧窗口是否要收缩
        while (valid == need.size()) {
            // 在这里更新最小覆盖子串
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            // d 是将移出窗口的字符
            char d = s[left];
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            if (need.count(d)) {
                if (window[d] == need[d]) valid--;
                window[d]--;
            }                    
        }
    }
    // 返回最小覆盖子串
    return len == INT_MAX ? "" : s.substr(start, len);
}
```

需要注意的是，当我们发现某个字符在 `window` 的数量满足了 `need` 的需要，就要更新 `valid`，表示有一个字符已经满足要求，而且两次对窗口内数据的更新操作是完全对称的。

当 `valid == need.size()` 时，说明 `T` 中所有字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该开始收缩窗口了，以便得到「最小覆盖子串」。

移动 `left` 收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。

### 567. 字符串的排列

给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` 的排列。如果是，返回 `true `；否则，返回 `false `。

```php
输入：s1 = "ab" s2 = "eidbaooo"
输出：true
输入：s1= "ab" s2 = "eidboaoo"
输出：false
```

注意哦，输入的 `s1` 是可以包含重复字符的，所以这个题难度不小。

这种题目，是明显的滑动窗口算法，**相当给你一个 `S` 和一个 `T`，请问你 `S` 中是否存在一个子串，包含 `T` 中所有字符且不包含其他字符**？

对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：

1、本题移动 `left` 缩小窗口的时机是窗口大小大于 `t.size()` 时，应为排列嘛，显然长度应该是一样的。

2、当发现 `valid == need.size()` 时，就说明窗口中就是一个合法的排列，所以立即返回 `true`。

至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。

```php
class Solution {
public:
    // 判断 s2 中是否存在 s1 的排列
    bool checkInclusion(string s1, string s2) {
        unordered_map<char, int> need, window;
        for(char c : s1){
            need[c]++;
        }
        int left = 0, right = 0, valid = 0;
        while(right < s2.size()){
            char c = s2[right];
            right++;
            if(need.count(c)){
                window[c]++;
                if(window[c] == need[c]) valid++;
            }
            // 判断左侧窗口是否要收缩
            while(valid == need.size()){
                // 判断是否找到了合法的子串
                if(right - left == s1.size()) return true;
                char d = s2[left];
                left++;
                if(need.count(d)){
                    if(window[d] == need[d]) valid--;
                    window[d]--;
                }
            }
        }
        // 未找到符合条件的子串
        return false;
    }
};
```

### 438. 找到字符串中所有字母异位词

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p`的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

```php
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
```

所谓的**字母异位词**就是**排列**，相当于输入一个串 `S`，一个串 `T`，找到 `S` 中所有 `T` 的排列，返回它们的起始索引。跟寻找字符串的排列一样，只是找到一个合法异位词（排列）之后将起始索引加入 `res` 即可。

```php
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        unordered_map<char, int> need, window;
        for(char c : p) need[c]++;
        int left = 0, right = 0, valid = 0;
        vector<int> res;
        while(right < s.size()){
            char c = s[right];
            right++;
            if(need.count(c)){
                window[c]++;
                if(window[c] == need[c]) valid++;
            }
            // 判断左侧窗口是否要收缩
            while(valid == need.size()){
                // 当窗口符合条件时，把起始索引加入 res
                if(right - left == p.size()) res.push_back(left);
                char d = s[left];
                left++;
                if(need.count(d)){
                    if(need[d] == window[d]) valid--;
                    window[d]--;
                }
            }
        }
        return res;
    }
};
```

## 二维数组遍历

### 48. 旋转图像

给定一个 `n × n` 的二维矩阵 matrix 表示一个图像。请你将图像**顺时针**旋转 90 度。你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205211142216.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

旋转二维矩阵的难点在于将「行」变成「列」，将「列」变成「行」，而只有按照对角线的对称操作是可以轻松完成这一点的，对称操作之后就很容易发现规律了。

我们可以先将 `n x n` 矩阵 `matrix` 按照左上到右下的对角线进行镜像对称：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205211151127.png" alt="image-20220521115152062" style="zoom:80%;" /></div>

然后再对矩阵的每一行进行反转：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205211153864.png" alt="image-20220521115345798" style="zoom:80%;" /></div>

发现结果就是 `matrix` 顺时针旋转 90 度的结果：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205211155575.png" alt="image-20220521115523512" style="zoom:80%;" /></div>

```php
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for(int i = 0; i < n; i++){
            for(int j = 0; j < i; j++){
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        for(int i = 0; i < n; i++){
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
```


**那如何将矩阵逆时针旋转 90 度呢**？

思路是类似的，只要通过另一条对角线镜像对称矩阵，然后再反转每一行，就得到了逆时针旋转矩阵的结果：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205211156783.png" alt="image-20220521115657715" style="zoom:80%;" /></div>

```php
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n - i; j++){
                swap(matrix[i][j], matrix[n - j - 1][n - i - 1]);
            }
        }
        for(int i = 0; i < n; i++){
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
```

### 54. 螺旋矩阵

给你一个 `m `行 `n` 列的矩阵 matrix ，请按照 **顺时针**螺旋顺序 ，返回矩阵中的所有元素。

<div align=center><img src="https://s1.ax1x.com/2022/05/21/Oj35qK.jpg" alt="Oj35qK.jpg" style="zoom:70%;" /></div>

```php
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界。

<div align=center><img src="https://s1.ax1x.com/2022/05/21/OjGnXt.png" style="zoom:40%;" /></div>

随着螺旋遍历，相应的边界会收缩，直到螺旋遍历完整个数组：

<div align=center><img src="https://s1.ax1x.com/2022/05/21/OjJ1Dx.png" style="zoom:40%;" /></div>

```php
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        int upper = 0, lower = m - 1, left = 0, right = n - 1;
        vector<int> res;
        // res.size() == m * n 则遍历完整个数组
        while(res.size() < m * n){
            // 在顶部从左向右遍历
            if(upper <= lower){
                for(int j = left; j <= right; j++){
                    res.push_back(matrix[upper][j]);
                }
                // 上边界下移
                upper++;
            }
            if(left <= right){
                // 在右侧从上向下遍历
                for(int i = upper; i <= lower; i++){
                    res.push_back(matrix[i][right]);
                }
                // 右边界左移
                right--;
            }
            if(upper <= lower){
                // 在底部从右向左遍历
                for(int j = right; j >= left; j--){
                    res.push_back(matrix[lower][j]);
                }
                // 下边界上移
                lower--;
            }
            if(left <= right){
                // 在左侧从下向上遍历
                for(int i = lower; i >= upper; i--){
                    res.push_back(matrix[i][left]);
                }
                // 左边界右移
                left++;
            }
        }
        return res;
    }
};
```

### 59. 螺旋矩阵II

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

<div align=center><img src="https://s1.ax1x.com/2022/05/21/Oj35qK.jpg" alt="Oj35qK.jpg" style="zoom:70%;" /></div>

```php
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

和上一道题类似的思路：

```php
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n));
        int upper = 0, lower = n - 1, left = 0, right = n - 1;
        int num = 1;
        while(num <= n * n){
            if(upper <= lower){
                for(int j = left; j <= right; j++){
                    res[upper][j] = num++;
                }
                upper++;
            }
            if(left <= right){
                for(int i = upper; i <= lower; i++){
                    res[i][right] = num++;
                }
                right--;
            }
            if(upper <= lower){
                for(int j = right; j >= left; j--){
                    res[lower][j] = num++;
                }
                lower--;
            }
            if(left <= right){
                for(int i = lower; i >= upper; i--){
                    res[i][left] = num++;
                }
                left++;
            }
        }
        return res;
    }
};
```

# 四、回溯算法

## 排列组合子集问题

### 78. 子集

给你一个整数数组 `nums`，**数组中的元素互不相同** ，返回该数组所有可能的子集（幂集）。解集不能包含重复的子集，你可以按任意顺序 返回解集。

 ```php
 输入：nums = [1,2,3]
 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
 ```

本质上子集问题就是遍历这样用一棵回溯树：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206111654937.png" alt="image-20220611165427827" style="zoom:80%;" /></div>

```php
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    vector<vector<int>> subsets(vector<int>& nums) {
        backtrack(nums, 0);
        return res;
    }

    void backtrack(vector<int>& nums, int start){
        res.push_back(path);
        for(int i = start; i < nums.size(); i++){
            path.push_back(nums[i]);
            backtrack(nums, i + 1);
            path.pop_back();
        }
    }
};
```

### 90. 子集 II

给你一个整数数组`nums`，**其中可能包含重复元素**，请你返回该数组所有可能的子集（幂集）。解集不能包含重复的子集，返回的解集中，子集可以按任意顺序排列。

```php
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

这道题目和**78.子集**的区别就是集合里有重复的元素，而且求取的子集path要去重。需要先进行排序，让相同的元素靠在一起，如果发现 `nums[i] == nums[i-1]`，则跳过。path中加入一个元素，不会再加入相同的元素。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206111737073.png" alt="image-20220611173659959" style="zoom:80%;" /></div>

```php
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());	// 去重前需要排序
        backtrack(nums, 0);
        return res;
    }

    void backtrack(vector<int>& nums, int start){
        res.push_back(path);
        for(int i = start; i < nums.size(); i++){
            if(i > start && nums[i] == nums[i - 1]) continue; // 去重
            path.push_back(nums[i]);
            backtrack(nums, i + 1);
            path.pop_back();
        }
    }
};
```

### 77. 组合

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合，你可以按 **任何顺序** 返回答案。

```php
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

大小为 k 的组合就是大小为 k 的子集，还是以 nums = [1,2,3] 为例，刚才求所有子集，就是把所有节点的值都收集起来；现在只需要把第 2 层（根节点视为第 0 层）的节点收集起来，就是大小为 2 的所有组合：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206111758888.png" alt="image-20220611175811776" style="zoom:80%;" /></div>

```php
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    vector<vector<int>> combine(int n, int k) {
        backtrack(n, k, 1);
        return res;
    }

    void backtrack(int n, int k, int start){
        if(k == path.size()){
            res.push_back(path);
            return;
        }
        for(int i = start; i <= n; i++){
            path.push_back(i);
            backtrack(n, k, i + 1);
            path.pop_back();
        }
    }
};
```

### 39. 组合总和

给你一个**无重复元素**的整数数组 `candidates `和一个目标整数 `target `，找出 `candidates `中可以使数字和为目标数 `target `的 所有不同组合 ，并以列表形式返回。你可以按任意顺序返回这些组合。`candidates `中的**同一个数字可以无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 `target `的不同组合数少于 150 个。

 ```php
 输入：candidates = [2,3,6,7], target = 7
 输出：[[2,2,3],[7]]
 解释：
 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。
 ```

本道题中：输入数组无重复元素，每个元素可以被无限次使用。

标准的子集/组合问题是如何保证不重复使用元素的？在于 `backtrack` 递归时输入的参数 `start`， `i` 从 `start `开始，那么下一层回溯树就是从 `start + 1` 开始，从而保证 `nums[start]` 这个元素不会被重复使用。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206121142519.png" alt="image-20220612114218321" style="zoom:70%;" /></div>

想让每个元素被重复使用，我只要把 `i + 1` 改成 `i` 即可。这相当于给之前的回溯树添加了一条树枝，在遍历这棵树的过程中，一个元素可以被无限次使用。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206121145763.png" alt="image-20220612114503646" style="zoom:80%;" /></div>

```php
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    int sum = 0;
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtrack(candidates, target, 0);
        return res;
    }

    void backtrack(vector<int>& candidates, int target, int start){
        if(sum > target) return;
        if(sum == target){
            res.push_back(path);
            return;
        }
        for(int i = start; i < candidates.size(); i++){
            path.push_back(candidates[i]);
            sum += candidates[i];
            backtrack(candidates, target, i);
            path.pop_back();
            sum -= candidates[i];
        }
    }
};
```

### 40. 组合总和 II

给定一个候选人编号的集合 `candidates `和一个目标数 `target `，找出 `candidates` 中所有可以使数字和为 `target `的组合。`candidates` 中的**每个数字在每个组合中只能使用一次 **。注意：**解集不能包含重复的组合**。 

```php
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
	[1,1,6],
	[1,2,5],
	[1,7],
	[2,6]
]
```

本道题中：输入数组有重复元素，每个元素只能使用一次，需要去重。

```php
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    int sum = 0;
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        backtrack(candidates, target, 0);
        return res;
    }

    void backtrack(vector<int>& candidates, int target, int start){
        if(sum > target) return;
        if(sum == target){
            res.push_back(path);
            return;
        }
        for(int i = start; i < candidates.size(); i++){
            if(i > start && candidates[i - 1] == candidates[i]) continue;
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtrack(candidates, target, i + 1);
            sum -= candidates[i];
            path.pop_back();
        }
    }
};
```

### 216. 组合总和 III

找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：只使用数字1到9，**每个数字最多使用一次**，返回所有可能的有效组合的列表。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

 ```php
 输入: k = 3, n = 7
 输出: [[1,2,4]]
 解释:1 + 2 + 4 = 7，没有其他符合的组合了。
 ```

本道题中：输入数组无重复元素，每个元素只能使用一次。当满足`sum == n && k == path.size()`时，`path`加入`res`。

```php
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    int sum = 0;
    vector<vector<int>> combinationSum3(int k, int n) {
        backtrack(k, n, 1);
        return res;
    }

    void backtrack(int k, int n, int start){
        if(sum > n) return;
        if(sum == n && k == path.size()){
            res.push_back(path);
            return;
        }
        for(int i = start; i <= 9; i++){
            sum += i;
            path.push_back(i);
            backtrack(k, n, i + 1);
            sum -= i;
            path.pop_back();
        }
    }  
};
```

### 46. 全排列

给定一个**不含重复数字**的数组 `nums`，返回其所有可能的全排列，你可以按任意顺序返回答案。

```php
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

排列问题就是穷举元素，nums[i] 之后也可以出现 nums[i] 左边的元素，所以之前的那一套玩不转了，需要额外使用 `used` 数组来标记哪些元素还可以被选择。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206121430486.png" alt="image-20220612143008374" style="zoom:70%;" /></div>

```php
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> used(nums.size(), false);
        backtrack(nums, used);
        return res;
    }

    void backtrack(vector<int>& nums, vector<bool>& used){
        if(path.size() == nums.size()){
            res.push_back(path);
            return;
        }
        for(int i = 0; i < nums.size(); i++){
            // path里已经收录的元素，直接跳过
            if(used[i]) continue;
            path.push_back(nums[i]);
            used[i] = true;
            backtrack(nums, used);
            path.pop_back();
            used[i] = false;
        }
    }
};
```

path里已经收录的元素，直接跳过：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206121449434.png" alt="image-20220612144916318" style="zoom:80%;" /></div>

### 47. 全排列 II

给定一个可包含重复数字的序列 `nums` ，按任意顺序返回所有**不重复**的全排列。

```php
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

`nums` 数组当中包含重复的元素，如何去掉重复的全排列呢？**保证相同元素在排列中的相对位置保持不变即可**。首先对 `nums `进行排序，然后添加了一句额外的剪枝逻辑。

那么反映到代码上，剪枝逻辑如下：

```java
// 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置
if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
    // 如果前面的相邻相等元素没有用过，则跳过
    continue;
}
// 选择 nums[i]
```

当出现重复元素时，比如输入 `nums = [1,2,2',2'']`，`2'` 只有在 `2` 已经被使用的情况下才会被选择，同理，`2''` 只有在 `2'` 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定。

```php
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<bool> used(nums.size(), false);
        backtrack(nums, used);
        return res;
    }

    void backtrack(vector<int>& nums, vector<bool>& used){
        if(path.size() == nums.size()){
            res.push_back(path);
            return;
        }
        for(int i = 0; i < nums.size(); i++){
            if(used[i]) continue;
            if(i > 0 && nums[i] == nums[i - 1] && !used[i - 1]){
                continue;
            }
            path.push_back(nums[i]);
            used[i] = true;
            backtrack(nums, used);
            path.pop_back();
            used[i] = false;
        }
    }
};
```

### 491. 递增子序列

给你一个整数数组 `nums `，找出并返回所有该数组中不同的递增子序列，递增子序列中至少有两个元素 。你可以按任意顺序返回答案。数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

```php
输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
```

本题求自增子序列，是不能对原数组经行排序的，排完序的数组都是自增子序列了，所以不能使用之前的去重逻辑！使用`unordered_set<int>`来记录本层元素是否重复使用。

```php
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        backtracking(nums, 0);
        return result;
    }
    void backtracking(vector<int>& nums, int startIndex) {
        if (path.size() > 1) {
            result.push_back(path);
            // 注意这里不要加return，要取树上的节点
        }
        unordered_set<int> uset; // 使用set对本层元素进行去重
        for (int i = startIndex; i < nums.size(); i++) {
            if ((!path.empty() && nums[i] < path.back()) || uset.count(nums[i])) {
                continue;
            }
            uset.insert(nums[i]); // 记录这个元素在本层用过了，本层后面不能再用了
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
};

```

用数组来做哈希，效率就高了很多。注意题目中说了，数值范围[-100,100]，所以完全可以用数组来做哈希。

```php
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        backtracking(nums, 0);
        return result;
    }
    void backtracking(vector<int>& nums, int startIndex) {
        if (path.size() > 1) {
            result.push_back(path);
        }
        int used[201] = {0}; // 这里使用数组来进行去重操作，题目说数值范围[-100, 100]
        for (int i = startIndex; i < nums.size(); i++) {
            if ((!path.empty() && nums[i] < path.back()) || used[nums[i] + 100] == 1) {
                    continue;
            }
            used[nums[i] + 100] = 1; // 记录这个元素在本层用过了，本层后面不能再用了
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
};
```



## 切割问题

### 131. 分割回文串

给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 ，返回 s 所有可能的分割方案。回文串是正着读和反着读都一样的字符串。

```php
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

本题要思考如下问题：

- 切割问题可以抽象为组合问题
- 如何模拟那些切割线
- 切割问题中递归如何终止
- 在递归循环中如何截取子串
- 如何判断回文

```php
class Solution {
public:
    vector<vector<string>> result;
    vector<string> path; // 放已经回文的子串
    vector<vector<string>> partition(string s) {
        backtracking(s, 0);
        return result;
    }

    void backtracking (const string& s, int startIndex) {
        // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
        if (startIndex >= s.size()) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < s.size(); i++) {
            if(!isPalindrome(s, startIndex, i)) continue;
            string str = s.substr(startIndex, i - startIndex + 1);
            path.push_back(str);
            backtracking(s, i + 1); // 寻找i + 1为起始位置的子串
            path.pop_back();        // 回溯过程，弹出本次已经填在的子串
        }
    }

    bool isPalindrome(const string& s, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            if (s[i] != s[j]) {
                return false;
            }
        }
        return true;
    }
};
```

### 93. 复原 IP 地址

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。

给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你不能重新排序或删除 s 中的任何数字。你可以按任何顺序返回答案。

```php
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

在131.分割回文串中我列举的分割字符串的难点，本题都覆盖了。而且本题还需要操作字符串添加逗号作为分隔符，并验证区间的合法性。可以说是131.分割回文串的加强版。

```php
class Solution {
public:
    vector<string> result;// 记录结果
    vector<string> restoreIpAddresses(string s) {
        if (s.size() < 4 || s.size() > 12) return result; // 算是剪枝了
        backtracking(s, 0, 0);
        return result;
    }

    // startIndex: 搜索的起始位置，pointNum:添加逗点的数量
    void backtracking(string& s, int startIndex, int pointNum) {
        if (pointNum == 3) { // 逗点数量为3时，分隔结束
            // 判断第四段子字符串是否合法，如果合法就放进result中
            if (isValid(s, startIndex, s.size() - 1)) {
                result.push_back(s);
            }
            return;
        }
        for (int i = startIndex; i < s.size(); i++) {
			if (!isValid(s, startIndex, i)) continue;        // 判断 [startIndex,i] 这个区间的子串是否合法
			s.insert(s.begin() + i + 1 , '.');  // 在i的后面插入一个逗点
			pointNum++;
			backtracking(s, i + 2, pointNum);   // 插入逗点之后下一个子串的起始位置为i + 2
			pointNum--;                         // 回溯
			s.erase(s.begin() + i + 1);         // 回溯删掉逗点
        }
    }
    
    // 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法
    bool isValid(const string& s, int start, int end) {
        if (start > end) return false;
        if (s[start] == '0' && start != end) { // 0开头的数字不合法
            return false;
        }
        int num = 0;
        for (int i = start; i <= end; i++) {
            if (s[i] > '9' || s[i] < '0') { // 遇到非数字字符不合法
                return false;
            }
            num = num * 10 + (s[i] - '0');
            if (num > 255) { // 如果大于255了不合法
                return false;
            }
        }
        return true;
    }
};
```

## 岛屿问题

岛屿系列题目的核心考点就是用 DFS/BFS 算法**遍历二维数组**。

### 200. 岛屿数量

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。

 ```php
 输入：grid = [
   ["1","1","1","1","0"],
   ["1","1","0","1","0"],
   ["1","1","0","0","0"],
   ["0","0","0","0","0"]
 ]
 输出：1
 ```

用 DFS 算法解决岛屿题目是最常见的，每次遇到一个岛屿中的陆地，就用 DFS 算法吧这个岛屿「淹掉」。

如何使用 DFS 算法遍历二维数组？把二维数组中的每个格子看做「图」中的一个节点，这个节点和周围的四个节点连通，这样二维矩阵就被抽象成了一幅网状的「图」。

为什么每次遇到岛屿，都要用 DFS 算法把岛屿「淹了」呢？主要是为了省事，避免维护 `visited` 数组。遍历图是需要 `visited` 数组记录遍历过的节点防止走回头路。因为 `dfs` 函数遍历到值为 `0` 的位置会直接返回，所以只要把经过的位置都设置为 `0`，就可以起到不走回头路的作用。

```php
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int count = 0;
        int m = grid.size(), n = grid[0].size();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    count++;            // 每发现一个岛屿，岛屿数量加一
                    dfs(grid, i, j);    // 然后使用 DFS 将岛屿淹了
                }
            }
        }
        return count;
    }

    // 从 (i, j) 开始，将与之相邻的陆地都变成海水
    void dfs(vector<vector<char>>& grid, int i, int j){
        int m = grid.size(), n = grid[0].size();
        if(i < 0 || j < 0 || i >= m || j >= n) return;
        if(grid[i][j] == '0') return;
        grid[i][j] = '0';
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
};
```

### 1254. 统计封闭岛屿的数目

二维矩阵 grid 由 0 （土地）和 1 （水）组成。岛是由最大的4个方向连通的 0 组成的群，封闭岛是一个 **完全 由1包围**（左、上、右、下）的岛，请返回 封闭岛屿 的数目。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206141112335.png" alt="img" style="zoom:80%;" /></div>

```php
输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
输出：2
解释：灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。
```

和上一题有两点不同：

1. 用 `0` 表示陆地，用 `1` 表示海水。

2. 让你计算「封闭岛屿」的数目。所谓「封闭岛屿」就是上下左右全部被 `1` 包围的 `0`，也就是说**靠边的陆地不算作「封闭岛屿」**。

那么如何判断「封闭岛屿」呢？把上一题中那些靠边的岛屿排除掉，剩下的就是「封闭岛屿」。

```php
class Solution {
public:
    int closedIsland(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        for (int j = 0; j < n; j++) {
            dfs(grid, 0, j);        // 把靠上边的岛屿淹掉
            dfs(grid, m - 1, j);    // 把靠下边的岛屿淹掉
        }
        for (int i = 0; i < m; i++) {
            dfs(grid, i, 0);        // 把靠左边的岛屿淹掉
            dfs(grid, i, n - 1);    // 把靠右边的岛屿淹掉
        }
        // 遍历 grid，剩下的岛屿都是封闭岛屿
        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    count++;            // 每发现一个岛屿，岛屿数量加一
                    dfs(grid, i, j);    // 然后使用 DFS 将岛屿淹了
                }
            }
        }
        return count;
    }

    // 从 (i, j) 开始，将与之相邻的陆地都变成海水
    void dfs(vector<vector<int>>& grid, int i, int j){
        int m = grid.size(), n = grid[0].size();
        if(i < 0 || j < 0 || i >= m || j >= n) return;
        if(grid[i][j] == 1) return;
        grid[i][j] = 1;
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
};
```

### 1020. 飞地的数量

给你一个大小为 m x n 的二进制矩阵 `grid `，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。一次 **移动 **是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。返回网格中**无法**在任意次数的移动中离开网格边界的陆地单元格的数量。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206141123972.jpeg" alt="img" style="zoom:50%;" /></div>

 ```php
 输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
 输出：3
 解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
 ```

这题不求封闭岛屿的数量，而是求封闭岛屿的面积总和，本质上和上一题是一样的。思路都是一样的，先把靠边的陆地淹掉，然后去数剩下的陆地数量。

```php
class Solution {
public:
    int numEnclaves(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        for (int j = 0; j < n; j++) {
            dfs(grid, 0, j);        // 把靠上边的岛屿淹掉
            dfs(grid, m - 1, j);    // 把靠下边的岛屿淹掉
        }
        for (int i = 0; i < m; i++) {
            dfs(grid, i, 0);        // 把靠左边的岛屿淹掉
            dfs(grid, i, n - 1);    // 把靠右边的岛屿淹掉
        }
        // 遍历 grid，剩下的岛屿都是封闭岛屿
        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    count++;            // 每发现一个岛屿，岛屿数量加一
                }
            }
        }
        return count;

    }

    // 从 (i, j) 开始，将与之相邻的陆地都变成海水
    void dfs(vector<vector<int>>& grid, int i, int j){
        int m = grid.size(), n = grid[0].size();
        if(i < 0 || j < 0 || i >= m || j >= n) return;
        if(grid[i][j] == 0) return;
        grid[i][j] = 0;
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
};
```

### 695. 岛屿的最大面积

给你一个大小为 m x n 的二进制矩阵 grid 。岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设**grid 的四个边缘都被 0（代表水）包围着**。岛屿的面积是岛上值为 1 的单元格的数目。计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206141131954.jpeg" alt="img" style="zoom:40%;" /></div>

```php
输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
输出：6
解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。
```

这题的大体思路和之前完全一样，只不过 `dfs` 函数淹没岛屿的同时，还应该想办法记录这个岛屿的面积。可以给 `dfs` 函数设置返回值，记录每次淹没的陆地的个数。

```php
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // 淹没岛屿，并更新最大岛屿面积
                    count = max(count, dfs(grid, i, j));  
                }
            }
        }
        return count;
    }

    // 淹没与 (i, j) 相邻的陆地，并返回淹没的陆地面积
    int dfs(vector<vector<int>>& grid, int i, int j){
        int m = grid.size(), n = grid[0].size();
        if(i < 0 || j < 0 || i >= m || j >= n) return 0;
        if(grid[i][j] == 0) return 0;
        grid[i][j] = 0;
        return 
        dfs(grid, i + 1, j) +
        dfs(grid, i, j + 1) +
        dfs(grid, i - 1, j) +
        dfs(grid, i, j - 1) + 1;
    }
};
```

### 1905. 统计子岛屿

给你两个 m x n 的二进制矩阵 grid1 和 grid2 ，它们只包含 0 （表示水域）和 1 （表示陆地）。一个 岛屿 是由 四个方向 （水平或者竖直）上相邻的 1 组成的区域。**任何矩阵以外的区域都视为水域**。如果 grid2 的一个岛屿，被 grid1 的一个岛屿 完全 包含，也就是说 grid2 中该岛屿的每一个格子都被 grid1 中同一个岛屿完全包含，那么我们称 grid2 中的这个岛屿为 子岛屿 。请你返回 grid2 中子岛屿的数目。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206141253750.png" style="zoom:80%;" /></div>

```php
输入：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], 
grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
输出：3
解释：如上图所示，左边为 grid1 ，右边为 grid2。grid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。
```

什么情况下 `grid2` 中的一个岛屿 `B` 是 `grid1` 中的一个岛屿 `A` 的子岛？当岛屿 `B` 中所有陆地在岛屿 `A` 中也是陆地的时候，岛屿 `B` 是岛屿 `A` 的子岛。**反过来说，如果岛屿 `B` 中存在一片陆地，在岛屿 `A` 的对应位置是海水，那么岛屿 `B` 就不是岛屿 `A` 的子岛**。那么，我们只要遍历 `grid2` 中的所有岛屿，把那些不可能是子岛的岛屿排除掉，剩下的就是子岛。

```php
class Solution {
public:
    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {
        int m = grid1.size(), n = grid1[0].size();
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if (grid1[i][j] == 0 && grid2[i][j] == 1) {
                    // 这个岛屿肯定不是子岛，淹掉
                    dfs(grid2, i, j);
                }
            }
        }
        // 现在 grid2 中剩下的岛屿都是子岛，计算岛屿数量
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid2[i][j] == 1) {
                    res++;
                    dfs(grid2, i, j);
                }
            }
        }
        return res;
    }

    // 从 (i, j) 开始，将与之相邻的陆地都变成海水
    void dfs(vector<vector<int>>& grid, int i, int j){
        int m = grid.size(), n = grid[0].size();
        if(i < 0 || j < 0 || i >= m || j >= n) return;
        if(grid[i][j] == 0) return;
        grid[i][j] = 0;
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
};
```

## 玩游戏

### 51. N 皇后

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 n ，返回所有不同的 n 皇后问题的解决方案。每一种解法包含一个不同的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206121524334.png" alt="image-20220612152411212" style="zoom:80%;" /></div>

 ```php
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
 ```

皇后的约束条件：不能同行、不能同列、不能同斜线。

搜索皇后的位置，可以抽象为一棵树：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206131136053.png" alt="image-20220613113646889" style="zoom:80%;" /></div>

那么我们用皇后们的约束条件，来回溯搜索这棵树，**只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了**。

用`row`来记录当前遍历到棋盘的第几层，递归深度就是`row`控制棋盘的行，每一层里for循环的`col`控制棋盘的列，一行一列，确定了放置皇后的位置。每次都是要从新的一行的起始位置开始搜，所以都是从0开始。

那如何验证棋盘是否合法呢？按照皇后的约束条件。**没有在同行进行检查**，因为在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，所以不用去重了。

```php
class Solution {
    public:
    vector<vector<string>> res;
    /* 输入棋盘边长 n，返回所有合法的放置 */
    vector<vector<string>> solveNQueens(int n) {
        // '.' 表示空，'Q' 表示皇后，初始化空棋盘。
        vector<string> board(n, string(n, '.'));
        backtrack(board, 0);
        return res;
    }
    
    // 路径：board 中小于 row 的那些行都已经成功放置了皇后
    // 选择列表：第 row 行的所有列都是放置皇后的选择
    // 结束条件：row 超过 board 的最后一行
    void backtrack(vector<string>& board, int row) {
        // 触发结束条件
        if (row == board.size()) {
            res.push_back(board);
            return;
        }
        int n = board[row].size();
        for (int col = 0; col < n; col++) {
            // 排除不合法选择
            if (!isValid(board, row, col)) continue;
            // 做选择
            board[row][col] = 'Q';
            // 进入下一行决策
            backtrack(board, row + 1);
            // 撤销选择
            board[row][col] = '.';
        }
    }
    
    /* 是否可以在 board[row][col] 放置皇后？*/
    bool isValid(vector<string>& board, int row, int col) {
        int n = board.size();
        // 检查列是否有皇后互相冲突
        for (int i = 0; i <= row; i++) {
            if(board[i][col] == 'Q') return false;
        }
        // 检查右上方是否有皇后互相冲突
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if(board[i][j] == 'Q') return false;
        }
        // 检查左上方是否有皇后互相冲突
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if(board[i][j] == 'Q') return false;
        }
        return true;
    }
};
```

### 37. 解数独

编写一个程序，通过填充空格来解决数独问题。数独的解法需遵循如下规则：

1. 数字 1-9 在每一行只能出现一次。

2. 数字 1-9 在每一列只能出现一次。

3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

数独部分空格内已填入了数字，空白格用 '.' 表示。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206141406503.png" alt="img" style="zoom:80%;" /></div>

算法的核心思路非常非常的简单，就是对每一个空着的格子穷举 1 到 9，如果遇到不合法的数字（在同一行或同一列或同一个 3×3 的区域中存在相同的数字）则跳过，如果找到一个合法的数字，则继续穷举下一个空格子。

```php
class Solution {
public:
    void solveSudoku(vector<vector<char>>& board) {
        backtrack(board, 0, 0);
    }

    bool backtrack(vector<vector<char>>& board, int i, int j){
        if(j == 9){
            // 穷举到最后一列的话就换到下一行重新开始。
            return backtrack(board, i + 1, 0);
        }
        // 找到一个可行解，触发 base case
        if(i == 9) return true;
        if (board[i][j] != '.') {
            // 如果有预设数字，不用我们穷举
            return backtrack(board, i, j + 1);
        }
        for(char ch = '1'; ch <= '9'; ch++){
            // 如果遇到不合法的数字，就跳过
            if (!isValid(board, i, j, ch)) continue;
            board[i][j] = ch;
            // 如果找到一个可行解，立即结束
            if (backtrack(board, i, j + 1)) return true;
            board[i][j] = '.';
        }
        // 穷举完 1~9，依然没有找到可行解，此路不通
        return false;
    }

    // 判断 board[i][j] 是否可以填入 ch
    bool isValid(vector<vector<char>>& board, int row, int col, char ch){
        for(int i = 0; i < 9; i++){
            // 判断行是否存在重复
            if (board[row][i] == ch) return false;
            // 判断列是否存在重复
            if (board[i][col] == ch) return false;
            // 判断 3 x 3 方框是否存在重复
            if (board[(row / 3) * 3 + i / 3][(col / 3) * 3 + i % 3] == ch){
                return false;
            }
        }
        return true;
    }
};
```

## 22. 括号生成

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

 ```php
 输入：n = 3
 输出：["((()))","(()())","(())()","()(())","()()()"]
 ```

一个「合法」括号组合的左括号数量一定等于右括号数量，并且对于一个「合法」的括号字符串组合 p，必然对于任何 0 <= i < len(p) 都有：子串 p[0..i] 中左括号的数量都大于或等于右括号的数量。

> 比如这个括号组合 `))((`，前几个子串都是右括号多于左括号，显然不是合法的括号组合。

题目相当于有 2n 个位置，每个位置可以放置字符 ( 或者 )，组成的所有括号组合中，有多少个是合法的？

用 `left `记录还可以使用多少个左括号，用 `right `记录还可以使用多少个右括号，就可以直接套用回溯算法套路框架了。

```php
class Solution {
public:
    vector<string> res; // 记录所有合法的括号组合
    string track;       // 回溯过程中的路径
    vector<string> generateParenthesis(int n) {
        backtrack(n, n); // 可用的左括号和右括号数量初始化为 n
        return res;
    }

    // 可用的左括号数量为 left 个，可用的右括号数量为 riht 个
    void backtrack(int left, int right) {
        // 若左括号剩下的多，说明不合法
        if (right < left) return;
        // 数量小于 0 肯定是不合法的
        if (left < 0 || right < 0) return;
        // 当所有括号都恰好用完时，得到一个合法的括号组合
        if (left == 0 && right == 0) {
            res.push_back(track);
            return;
        }
        // 尝试放一个左括号
        track.push_back('('); // 选择
        backtrack(left - 1, right);
        track.pop_back(); // 撤消选择
        // 尝试放一个右括号
        track.push_back(')'); // 选择
        backtrack(left, right - 1);
        track.pop_back(); // 撤消选择
    }
};
```

## 17. 电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合，答案可以按任意顺序返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206141452844.png" alt="img" style="zoom:150%;" /></div>

```php
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

```php
class Solution {
private:
    const string letterMap[10] = {
        "",     // 0
        "",     // 1
        "abc",  // 2
        "def",  // 3
        "ghi",  // 4
        "jkl",  // 5
        "mno",  // 6
        "pqrs", // 7
        "tuv",  // 8
        "wxyz", // 9
    };
public:
    vector<string> result;
    string s;
    vector<string> letterCombinations(string digits) {
        if(digits.empty()) return result;
        backtracking(digits, 0);
        return result;
    }

    void backtracking(const string& digits, int index) {
        if (index == digits.size()) {
            result.push_back(s);
            return;
        }
        int digit = digits[index] - '0';        // 将index指向的数字转为int
        string letters = letterMap[digit];      // 取数字对应的字符集
        for (int i = 0; i < letters.size(); i++) {
            s.push_back(letters[i]);            // 处理
            backtracking(digits, index + 1);    // 递归，注意index + 1，下一层要处理下一个数字了
            s.pop_back();                       // 回溯
        }
    }
};
```

注意：`index`用来记录遍历第几个数字，就是用来遍历digits的。

# 五、动态规划

动态规划是什么？解决动态规划问题有什么技巧？如何学习动态规划？

首先，**动态规划问题的一般形式就是求最值**。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。

既然是要求最值，核心问题是什么呢？**求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。

首先，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，需要你熟练掌握递归思维，只有列出**正确的「状态转移方程」**，才能正确地穷举。而且，你需要判断算法问题是否**具备「最优子结构」**，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题**存在「重叠子问题」**，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。在实际的算法问题中，写出状态转移方程是最困难的，这也就是为什么很多朋友觉得动态规划问题困难的原因。总结的一个思维框架，来辅助思考状态转移方程：

**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 `dp` 数组/函数的含义**。

按上面的套路走，最后的解法代码就会是如下的框架：

```php
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是**重叠子问题**（斐波那契数列没有求最值，所以严格来说不是动态规划问题），后者主要举集中于如何列出**状态转移方程**。

## 拆分

### 343. 整数拆分

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。返回你可以获得的最大乘积。

```php
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

`dp[i]`：拆分数字`i`，可以得到的最大乘积为`dp[i]`。

`dp[i]`最大乘积是怎么得到的呢？其实可以从1遍历`j`，然后有两种渠道得到`dp[i]`：一个是`j * (i - j) `直接相乘；一个是`j * dp[i - j]`，相当于是拆分`(i - j)`。递推公式：`dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))`。

也可以这么理解，`j * (i - j)` 是单纯的把整数拆分为两个数相乘，而`j * dp[i - j]`是拆分成两个以及两个以上的个数相乘。

初始化：可以只初始化`dp[2] = 1`，从`dp[i]`的定义来说，拆分数字2，得到的最大乘积是1。

```php
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n ; i++) {
            for (int j = 1; j < i - 1; j++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
    }
};
```

### 96. 不同的二叉搜索树

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

**示例：**

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271115456.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：n = 3
输出：5
```

`dp[i]`：1到`i`为节点组成的二叉搜索树的个数为`dp[i]`，也可以理解是`i`的不同元素节点组成的二叉搜索树的个数为`dp[i]`，都是一样的。

`dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]`，`j`相当于是头结点的元素，从1遍历到`i`为止。所以递推公式：`dp[i] += dp[j - 1] * dp[i - j]`，`j - 1` 为`j`为头结点的左子树节点数量，`i - j` 为以`j`为头结点的右子树节点数量。

初始化：从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，所以初始化`dp[0] = 1`。

 ```php
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
 ```

## 爬楼梯

### 509.波那契数

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```php
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

```php
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

`dp` 数组的迭代（递推）解法：

```php
class Solution {
public:
    int fib(int n) {
        if(n <= 1) return n;
        vector<int> dq(n + 1);
        dq[0] = 0; dq[1] = 1;
        for(int i = 2; i <= n; i++){
            dq[i] = dq[i - 1] + dq[i - 2];
        }
        return dq[n];
    }
};
```

当然可以发现，我们只需要维护两个数值就可以了，不需要记录整个序列。

```php
class Solution {
public:
    int fib(int n) {
        if(n <= 1) return n;
        int d0 = 0, d1 = 1;
        for(int i = 2; i <= n; i++){
            int sum = d0 + d1;
            d0 = d1;
            d1 = sum;
        }
        return d1;
    }
};
```

### 70. 爬楼梯

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```php
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

`dp[i]`： 爬到第`i`层楼梯，有`dp[i]`种方法。

 dp[i] 可以有两个方向推出来：

首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶就是dp[i]。还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶就是dp[i]。那么dp[i]就是 dp[i - 1]与dp[i - 2]之和，所以`dp[i] = dp[i - 1] + dp[i - 2]` 。

不考虑dp[0]如果初始化，只初始化`dp[1] = 1`，`dp[2] = 2`，然后从i = 3开始递推，这样才符合dp[i]的定义。

```php
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 2) return n;
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) { // 注意i是从3开始的
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

优化一下空间复杂度：

```php
class Solution {
public:
    int climbStairs(int n) {
        if(n <= 2) return n;
        int d1 = 1, d2 = 2;
        for(int i = 3; i <= n; i++){
            int sum = d1 + d2;
            d1 = d2;
            d2 = sum;
        }
        return d2;
    }
};
```

### 746. 使用最小花费爬楼梯

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。

```php
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。支付 15 ，向上爬两个台阶，到达楼梯顶部。总花费为 15 。
```

`dp[i]`：到达第`i`个台阶的最低花费为`dp[i]`。（注意：这里认为第一步一定是要花费的）

两个途径得到`dp[i]`，一个是`dp[i-1]` 一个是`dp[i-2]`。一定是选最小的，所以`dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]`。

**初始化**：看一下递归公式，dp[i]由dp[i-1]，dp[i-2]推出，既然初始化所有的dp[i]是不可能的，那么只初始化`dp[0]`和`dp[1]`就够了，其他的最终都是dp[0]和dp[1]推出的。`dp[0] = cost[0]`，`dp[1] = cost[1]`。

```php
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        vector<int> d(n);
        d[0] = cost[0];
        d[1] = cost[1];
        for(int i = 2; i < n; i++){
            d[i] = min(d[i - 1], d[i - 2]) + cost[i];
        }
        // 注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值
        return min(d[n - 1], d[n - 2]);
    }
};
```

优化空间复杂度：

```php
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dp0 = cost[0];
        int dp1 = cost[1];
        for (int i = 2; i < cost.size(); i++) {
            int dpi = min(dp0, dp1) + cost[i];
            dp0 = dp1;
            dp1 = dpi;
        }
        return min(dp0, dp1);
    }
};
```

## 不同路径

### 62. 不同路径

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？

![img](https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205311640706.png)

```php
输入：m = 3, n = 7
输出：28
```

`dp[i][j]`：表示从`(0, 0)` 出发，到 `(i, j)` 有`dp[i][j]`条不同的路径。

想要求`dp[i][j]`，只能有两个方向来推导出来，即`dp[i - 1][j] `和 `dp[i][j - 1]`。`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`，因为`dp[i][j]`只有这两个方向过来。

 初始化：首先`dp[i][0]`一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么`dp[0][j]`也同理。

```php
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

### 63. 不同路径 II

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。现在考虑网格中有障碍物，那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

```php
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

`dp[i][j]`：表示从`(0, 0)` 出发，到 `(i, j)` 有`dp[i][j]`条不同的路径。

想要求`dp[i][j]`，只能有两个方向来推导出来，即`dp[i - 1][j] `和 `dp[i][j - 1]`。`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`，因为`dp[i][j]`只有这两个方向过来。但这里需要注意一点，因为有了障碍，(`i, j)`如果就是障碍的话应该就保持初始状态（初始状态为0）。

初始化：如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的`dp[i][0]`应该还是初始值0。

```php
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) continue; // 跳过障碍物
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

### 64. 最小路径和

给定一个包含非负整数的`m x n`网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。**说明：**每次只能向下或者向右移动一步。

![image-20220531204021142](https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205312040325.png)

```php
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

`dp[i][j]`：表示从`(0, 0)` 出发，到 `(i, j)` 路径上的数字总和最小为`dp[i][j]`。

想要求`dp[i][j]`，只能有两个方向来推导出来，即`dp[i - 1][j] `和 `dp[i][j - 1]`，取最小值。递推公式：`dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid(i)`。

初始化：根据定义有`d[0][0] = grid[0][0]`，而`d[i][0]`表示从原点一直往右走，数字总和逐渐增加`grid[i][0]`，`d[0][j]`同理。

```php
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> d(m, vector<int>(n, 0));
        d[0][0] = grid[0][0];
        for(int i = 1; i < m; i++){
            d[i][0] = d[i - 1][0] + grid[i][0];
        }
        for(int j = 1; j < n; j++){
            d[0][j] = d[0][j - 1] + grid[0][j];
        }
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                d[i][j] = min(d[i - 1][j], d[i][j - 1]) + grid[i][j];
            }
        }
        return d[m - 1][n - 1];
    }
};
```

## 递增子序列

### 300. 最长递增子序列(LIS)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```php
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**数组`dp[i]` 表示以 `nums[i]` 这个数结尾（下标i之前，包括i）的最长递增子序列的长度，`dp` 数组中最大的那个值就是最长的递增子序列长度**。

位置`i`的最长升序子序列等于`j`从`0`到`i-1`各个位置的最长升序子序列 + 1 的最大值，所以：`if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1)`。**注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是要取dp[j] + 1的最大值**。

根据这个定义可以推出 **base case**：`dp[i]` 初始值为 1，因为以 `nums[i]` 结尾的最长递增子序列起码要包含它自己。

```php
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        // base case：dp 数组全都初始化为 1
        vector<int> dp(nums.size(), 1);
        int res = 1;
        for(int i = 1; i < nums.size(); i++){
            for(int j = 0; j < i; j++){
                // 寻找 nums[0..j-1] 中比 nums[i] 小的元素
                if(nums[i] > nums[j]){
                    // 把 nums[i] 接在后面，即可形成长度为 dp[j] + 1，
                    // 且以 nums[i] 为结尾的递增子序列
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            // dp数组中的最大值即为最长的递增子序列长度
            res = max(res, dp[i]);
        }
        return res;
    }
};
```

### 354. 俄罗斯套娃信封问题

给你一个二维整数数组 envelopes ，其中 `envelopes[i] = [wi, hi]` ，表示第 `i `个信封的宽度和高度。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。请计算**最多**能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。注意：不允许旋转信封。

```php
输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出：3
解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
```

这道题目其实是最长递增子序列的一个变种，因为每次合法的嵌套是大的套小的，相当于在二维平面中找一个最长递增的子序列，其长度就是最多能嵌套的信封个数。前面说的标准 LIS 算法只能在**一维数组**中寻找最长子序列，而我们的信封是由 `(w, h)` 这样的二维数对形式表示的，如何把 LIS 算法运用过来呢？

**先对宽度 `w` 进行升序排序，如果遇到 `w` 相同的情况，则按照高度 `h` 降序排序；之后把所有的 `h` 作为一个数组，在这个数组上计算 LIS 的长度就是答案**。

首先，对宽度 `w` 从小到大排序，确保了 `w` 这个维度可以互相嵌套，所以我们只需要专注高度 `h` 这个维度能够互相嵌套即可。

其次，两个 `w` 相同的信封不能相互包含，**所以对于宽度 `w` 相同的信封，对高度 `h` 进行降序排序**，保证 LIS 中不存在多个 `w` 相同的信封（因为题目说了长宽相同也无法嵌套）。

画个图理解一下，先对这些数对进行排序，然后在 `h` 上寻找最长递增子序列，这个子序列就是最优的嵌套方案：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205221612129.png" alt="image-20220522161215045" style="zoom:70%;" /></div>

```php
class Solution {
public:
    static bool comp(vector<int> e1, vector<int> e2){
        if(e1[0] == e2[0]) return e1[1] > e2[1];
        else return e1[0] < e2[0];
    }

    int maxEnvelopes(vector<vector<int>>& envelopes) {
        int n = envelopes.size();
        sort(envelopes.begin(), envelopes.end(), comp);
        int res = 1;
        vector<int> dp(n, 1);
        for(int i = 0; i < n; i++){
            for(int j = 0; j < i; j++){
                if(envelopes[i][1] > envelopes[j][1]){
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            res = max(res, dp[i]);
        }
        return res;
    }
};
```

### 674. 最长连续递增序列

给定一个未经排序的整数数组，找到最长且**连续递增**的子序列，并返回该序列的长度。

```php
输入：nums = [1,3,5,4,7]
输出：3
```

本题相对于**300.最长递增子序列**最大的区别在于“连续”，本题要求的是最长连续递增序列。

**数组`dp[i]`表示**以下标`i`为结尾的数组的连续递增子序列长度为`dp[i]`。注意这里的定义，一定是以下标`i`为结尾，并不是说一定以下标0为起始位置。

如果 `nums[i + 1] > nums[i]`，那么以 `i+1` 为结尾的数组的连续递增的子序列长度一定等于以`i`为结尾的数组的连续递增的子序列长度 + 1，即`dp[i + 1] = dp[i] + 1`（和**300.最长递增子序列**的不同之处），只需要一层for循环。

**初始化**：以下标`i`为结尾的数组的连续递增的子序列长度最少也应该是1，即`nums[i]`这一个元素，所以`dp[i]`应该初始化为1;

 ```php
 class Solution {
 public:
     int findLengthOfLCIS(vector<int>& nums) {
         int n = nums.size(), res = 1;
         vector<int> d(n, 1);
         for(int i = 1; i < n; i++){
             if(nums[i] > nums[i - 1]){
                 d[i] = 1 + d[i - 1];
             }
             res = max(d[i], res);
         }
         return res;
     }
 };
 ```

### 53. 最大子数组和

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。**子数组** 是数组中的一个连续部分。

```php
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

这道题不能用滑动窗口算法，因为数组中的数字可以是负数。

**定义 `dp` 数组：以 `nums[i]` 为结尾（下标i之前，包括i）的最大子数组和**。

`dp[i]` 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组。既然要求「最大子数组和」，当然选择结果更大的那个。

dp[i]只有两个方向可以推出来：

- `dp[i - 1] + nums[i]`，即`nums[i]`加入当前连续子序列和；
- `nums[i]`，即从头开始计算当前连续子数组和；

一定是取最大的，所以`dp[i] = max(dp[i - 1] + nums[i], nums[i])`。

**初始化**：从递推公式可以看出来`dp[i]`是依赖于`dp[i - 1]`的状态的，`dp[0]`就是递推公式的基础。根据`dp[i]`的定义，很明显`dp[0]`应为`nums[0]`，即`dp[0] = nums[0]`。

```php
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int size = nums.size();
        vector<int> dp(size);
        dp[0] = nums[0];
        int res = dp[0];
        for(int i = 1; i < size; i++){
            dp[i] = max(nums[i], nums[i] + dp[i - 1]);
            res = max(res, dp[i]);
        }
        return res;
    }
};
```

### 718. 最长重复子数组

给两个整数数组 `nums1` 和 `nums2` ，返回两个数组中公共的 、长度最长的子数组的长度。

```php
输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 。
```

`dp[i][j]`代表以下标`i - 1`为结尾的`nums1`，和以下标`j - 1`为结尾的`nums2`，最长重复子数组长度为`dp[i][j]`。

当`nums1[i - 1]` 和`nums2[j - 1]`相等的时候，`dp[i][j] = dp[i - 1][j - 1] + 1`。

**初始化**：

根据`dp[i][j]`的定义，`dp[i][0]` 和`dp[0][j]`其实都是没有意义的！但`dp[i][0]` 和`dp[0][j]`要有初始值，因为为了方便递归公式`dp[i][j] = dp[i - 1][j - 1] + 1`，所以`dp[i][0]` 和`dp[0][j]`初始化为0。

> 举个例子：nums1[0]如果和nums2[0]相同的话，`dp[1][1] = dp[0][0] + 1`，只有`dp[0][0]`初始为0，正好符合递推公式逐步累加起来。

```php
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size(), n = nums2.size(), res = 0;
        vector<vector<int>> d(m + 1, vector<int>(n + 1, 0));
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(nums1[i - 1] == nums2[j - 1]){
                    d[i][j] = 1 + d[i - 1][j - 1];
                }
                res = max(res, d[i][j]);
            }
        }
        return res;
    }
};
```

## 子序列问题

### 392. 判断子序列

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

```php
输入：s = "abc", t = "ahbgdc"
输出：true
```

**数组`dp[i][j] `表示**以下标`i-1`为结尾的字符串`s`，和以下标`j-1`为结尾的字符串`t`，相同子序列的长度为`dp[i][j]`。

注意这里是判断s是否为t的子序列，即t的长度是大于等于s的。

两种情况：

- `if (s[i - 1] == t[j - 1])`，t中找到了一个字符在s中也出现了，`dp[i][j] = dp[i - 1][j - 1] + 1`；
- `if (s[i - 1] != t[j - 1])`，相当于t要删除元素，继续匹配，`dp[i][j] = dp[i][j - 1]`；

**初始化**：其实这里只初始化`dp[i][0]`就够了，但一起初始化也方便，所以就一起操作了。

如果`dp[m][n]` 与 字符串`s`的长度相同，则说明s与t的最长相同子序列就是s，那么s 就是 t 的子序列，返回true，否则返回false。

```php
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int m = s.size(), n = t.size();
        vector<vector<int>> d(m + 1, vector<int>(n + 1, 0));
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(s[i - 1] == t[j - 1]){
                    d[i][j] = 1 + d[i - 1][j - 1];
                }else{
                    d[i][j] = d[i][j - 1];
                }
            }
        }
        if(d[m][n] == m) return true;
        else return false;
    }
};
```

### 115. 不同的子序列

给定一个字符串 `s` 和一个字符串 `t` ，计算在 `s` 的子序列中 `t` 出现的个数。

```php
输入：s = "rabbbit", t = "rabbit"
输出：3
```

**数组`dp[i][j]`表示**以`i-1`为结尾的`s`子序列中出现以`j-1`为结尾的`t`的个数为`dp[i][j]`。

 分析两种情况：

当`s[i - 1]` 与 `t[j - 1]`**相等**时，`dp[i][j]`由两部分组成：一部分是用`s[i - 1]`来匹配，那么个数为`dp[i - 1][j - 1]`，一部分是不用`s[i - 1]`来匹配，个数为`dp[i - 1][j]`。所以当`s[i - 1]` 与 `t[j - 1]`相等时，`dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]`；

> 为什么还要考虑 不用s[i - 1]来匹配，都相同了指定要匹配啊。
>
> 例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。

当`s[i - 1]` 与 `t[j - 1]`不相等时，`dp[i][j]`只由一部分组成，不用`s[i - 1]`来匹配，即`dp[i - 1][j]`，所以递推公式为`dp[i][j] = dp[i - 1][j]`。

**初始化**：

`dp[i][0]` 表示以`i-1`为结尾的`s`可以随便删除元素，出现空字符串的个数。那么`dp[i][0]`一定都是1，因为把以`i-1`为结尾的s，删除所有元素，出现空字符串的个数就是1。

`dp[0][j]`表示空字符串s可以随便删除元素，出现以`j-1`为结尾的字符串t的个数。那么`dp[0][j]`一定都是0，s如论如何也变成不了t。

`dp[0][0]`应该是1，空字符串s，可以删除0个元素，变成空字符串t。

```php
class Solution {
public:
    int numDistinct(string s, string t) {
        int m = s.size(), n = t.size();
        vector<vector<uint64_t>> d(m + 1, vector<uint64_t>(n + 1, 0));
        // base case
        for(int i = 0; i <= m; i++){
            d[i][0] = 1;
        }
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(s[i - 1] == t[j - 1]){
                    d[i][j] = d[i - 1][j - 1] + d[i - 1][j];
                }else{
                    d[i][j] = d[i - 1][j];
                }
            }
        }
        return d[m][n];
    }
};
```

### 1143. 最长公共子序列

给定两个字符串 `text1 `和 `text2`，返回这两个字符串的**最长公共子序列**的长度。如果不存在公共子序列 ，返回 0 。

>  一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

```php
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公子序列是 "ace" ，它的长度为 3 。
```

**数组`dp[i][j]` 表示**索引范围为`[0, i - 1]`的字符串`text1`与索引范围为`[0, j - 1]`的字符串`text2`的最长公共子序列为`dp[i][j]`。

有两种情况：

如果`text1[i - 1]` 与` text2[j - 1]`**相同**，那么找到了一个公共元素，所以`dp[i][j] = dp[i - 1][j - 1] + 1`；

如果`text1[i - 1] `与` text2[j - 1]`**不相同**，那就看看`text1[0, i - 2]`与`text2[0, j - 1]`的最长公共子序列和 `text1[0, i - 1]`与`text2[0, j - 2]`的最长公共子序列，取最大的，即`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`。

**初始化**：`test1[0, i-1]`和空串的最长公共子序列自然是0，所以`dp[i][0] = 0`，同理`dp[0][j]`也是0。其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为0。

```php
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size(), n = text2.size();
        // base case: dp[0][..] = dp[..][0] = 0
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                // 现在 i 和 j 从 1 开始，所以要减一
                if(text1[i - 1] == text2[j - 1]){
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                }else{
                    // s1[i-1] 和 s2[j-1] 至少有一个不在 lcs 中
                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }
        return dp[m][n];
    }
};
```

### 1035. 不相交的线

在两条独立的水平线上按给定的顺序写下` nums1` 和 `nums2 `中的整数。现在，可以绘制一些连接两个数字 `nums1[i] `和 `nums2[j]` 的直线，这些直线需要同时满足满足： `nums1[i] == nums2[j]`且绘制的直线不与任何其他连线（非水平线）相交。

请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。以这种方法绘制线条，并返回可以绘制的最大连线数。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205242018036.png" alt="image-20220524201854963" style="zoom:70%;" /></div>

```php
输入：nums1 = [1,4,2], nums2 = [1,2,4]
输出：2
```

直线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，且**这个子序列不能改变相对顺序**，只要相对顺序不改变，链接相同数字的直线就不会相交。**本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！**

```php
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size(), n = nums2.size();
        vector<vector<int>> d(m + 1, vector<int>(n + 1, 0));
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(nums1[i - 1] == nums2[j - 1]){
                    d[i][j] = 1 + d[i - 1][j - 1];
                }else{
                    d[i][j] = max(d[i - 1][j], d[i][j - 1]);
                }
            }
        }
        return d[m][n];
    }
};
```

### 583. 两个字符串的删除操作

给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` **相同**所需的**最小步数**。**每步** 可以删除任意一个字符串中的一个字符。

```php
输入: word1 = "sea", word2 = "eat"
输出: 2
解释: 第一步将 "sea" 变为 "ea" ，第二步将 "eat "变为 "ea"
```

删除的结果不就是它俩的最长公共子序列嘛！要计算删除的次数，就可以通过**最长公共子序列**的长度推导出来。只要求出两个字符串的最长公共子序列长度即可，除了最长公共子序列之外的字符都是必须删除的，最后用两个字符串的总长度减去两个最长公共子序列的长度就是删除的最少步数。

```php
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(word1[i - 1] == word2[j - 1]){
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                }else{
                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }
        return m + n - 2 * dp[m][n];
    }
};
```

### 712. 两个字符串的最小ASCII删除和

给定两个字符串`s1` 和 `s2`，返回使两个字符串相等所需删除字符的 **ASCII** 值的最小和 。

```php
输入: s1 = "sea", s2 = "eat"
输出: 231
解释: 在 "sea" 中删除 "s" 并将 "s" 的值(115)加入总和。
在 "eat" 中删除 "t" 并将 116 加入总和。
结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。
```

删除的 ascii 最小，那么保留的公共子串 ascii 最大，**问题转化为：求最大ascii公共子串**。

**数组 `dp[i][j] `表示** 索引范围为`[0, i - 1]`的字符串`s1`与索引范围为`[0, j - 1]`的字符串`s2`的最大ascii公共子串的ascii值。

有两种情况：

如果`s1[i - 1]` 与` s2[j - 1]`**相同**，那么找到了一个公共元素，所以`dp[i][j] = dp[i - 1][j - 1] + s1[i - 1]`；

如果`s1[i - 1] `与` s2[j - 1]`**不相同**，那就看看`s1[0, i - 2]`与`s2[0, j - 1]`的最大ascii公共子串的ascii值和 `s1[0, i - 1]`与`s2[0, j - 2]`的最大ascii公共子串的ascii值，取最大的，即`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`。

**初始化**：当`i`或`j`为0时，没有公共子串，此时状态为0。

**初始化**：`s1[0, i-1]`和空串的最大ascii公共子串的ascii值自然是0，所以`dp[i][0] = 0`，同理`dp[0][j]`也是0。其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为0。

```php
class Solution {
public:
    int minimumDeleteSum(string s1, string s2) {
        int m = s1.size(), n = s2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(s1[i - 1] == s2[j - 1]){
                    // i - 1位的ascii与[0 ~ i - 1]最小ascii之和
                    dp[i][j] = s1[i - 1] + dp[i - 1][j - 1];
                }else{
                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }
        //计算s1和s2总的ascii
        int ascii1 = 0, ascii2 = 0;
        for(char c : s1) acsii1 += c;
        for(char c : s2) acsii2 += c;
        // 总的ascii减去最大ascii公共子串的ascii值即为所求
        return ascii1 - dp[m][n] + ascii2 - dp[m][n];
    }
};
```

### 72. 编辑距离

给你两个单词 `word1 `和 `word2`， 请返回将 `word1 `转换成 `word2 `所使用的最少操作数。你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。

```php
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**数组`dp[i][j]` 表示**以下标`i-1`为结尾的字符串`word1`，和以下标`j-1`为结尾的字符串`word2`，最近编辑距离为`dp[i][j]`。

在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：

```php
if (word1[i - 1] == word2[j - 1])
    不操作
if (word1[i - 1] != word2[j - 1])
    增
    删
    换
```

`if (word1[i - 1] == word2[j - 1])` 那么说明不用任何编辑，`dp[i][j]` 就应该是 `dp[i - 1][j - 1]`，即`dp[i][j] = dp[i - 1][j - 1]`；

`if (word1[i - 1] != word2[j - 1])`，此时就需要编辑了，如何编辑呢？

**操作一**：word1删除一个元素，那么就是以下标`i - 2`为结尾的word1 与` j-1`为结尾的word2的最近编辑距离 再加上一个操作，即 `dp[i][j] = dp[i - 1][j] + 1;`

**操作二**：word2删除一个元素，那么就是以下标`i - 1`为结尾的word1 与` j-2`为结尾的word2的最近编辑距离 再加上一个操作，即 `dp[i][j] = dp[i][j - 1] + 1;`

怎么都是删除元素，添加元素去哪了？**word2添加一个元素，相当于word1删除一个元素**，例如 `word1 = "ad" ，word2 = "a"`，`word1`删除元素`'d'` 和 `word2`添加一个元素`'d'`，变成`word1="a", word2="ad"`， 最终的操作数是一样！

**操作三**：替换元素，`word1`替换`word1[i - 1]`，使其与`word2[j - 1]`相同，此时不用增加元素，那么以下标`i-2`为结尾的`word1` 与 `j-2`为结尾的`word2`的最近编辑距离 加上一个替换元素的操作，即 `dp[i][j] = dp[i - 1][j - 1] + 1;`

综上，当 `if (word1[i - 1] != word2[j - 1])` 时取最小的，即`dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;`

**初始化**：`dp[i][0]`是`i`，对word1里的元素全部做删除操作，即：`dp[i][0] = i`，同理`dp[0][j] = j`。

```php
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        vector<vector<int>> d(m + 1, vector<int>(n + 1, 0));
        // base case
        // dp[i][0] = i，对word1里的元素全部做删除操作        
        for(int i = 0; i <= m; i++){
            d[i][0] = i;
        }
        for(int j = 0; j <= n; j++){
            d[0][j] = j;
        }
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(word1[i - 1] == word2[j - 1]){
                    d[i][j] = d[i - 1][j - 1];
                }else{
                    d[i][j] = 1 + min({d[i - 1][j - 1], d[i - 1][j], d[i][j - 1]});
                }
            }
        }
        return d[m][n];
    }
};
```

## 回文序列

### 516. 最长回文子序列

给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

 ```php
 输入：s = "bbbab"
 输出：4
 解释：一个可能的最长回文子序列为 "bbbb" 。
 ```

**数组`dp[i][j]`表示**字符串`s`在`[i, j]`范围内的最长回文子序列的长度为`dp[i][j]`。

**如果`s[i]`与`s[j]`相同**，那么`dp[i][j] = dp[i + 1][j - 1] + 2`，即加上 `s[i+1..j-1]` 中的最长回文子序列就是 `s[i..j]` 的最长回文子序列。

**如果`s[i]`与`s[j]`不相同**，说明`s[i]`和`s[j]`同时加入并不能增加`[i,j]`区间内回文子串的长度，那么`dp[i + 1][j - 1]`分别加入`s[i]`、`s[j]`看看哪一个可以组成最长的回文子序列。加入`s[j]`的回文子序列长度为`dp[i + 1][j]`，加入`s[i]`的回文子序列长度为`dp[i][j - 1]`，那么`dp[i][j]`一定是取最大的，即：`dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])`。

**初始化**：

首先要考虑当`i` 和`j` 相同的情况，从递推公式`dp[i][j] = dp[i + 1][j - 1] + 2` 可以看出递推公式是计算不到` i `和`j`相同时候的情况，所以需要手动初始化一下。

当`i`与`j`相同，那么`dp[i][j]`一定是等于1的，即一个字符的回文子序列长度就是1。其他情况`dp[i][j]`初始为0就行，这样递推公式`dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) `中`dp[i][j]`才不会被初始值覆盖。

**遍历顺序**：

从递推公式`dp[i][j] = dp[i + 1][j - 1] + 2` 和 `dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) `可以看出，`dp[i][j]`是依赖于`dp[i + 1][j - 1] `和 `dp[i + 1][j]`，也就是从矩阵的角度来说，`dp[i][j] `下一行的数据。 **所以遍历i的时候一定要从下到上遍历，这样才能保证，下一行的数据是经过计算的**。

```php
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n));
        // base case
        for(int i = 0; i < n; i++){
            dp[i][i] = 1;
        }
        // 反着遍历保证正确的状态转移
        for(int i = n - 1; i >= 0; i--){
            for(int j = i + 1; j < n; j++){
                if(s[i] == s[j]){
                    // 它俩一定在最长回文子序列中
                    dp[i][j] = 2 + dp[i + 1][j - 1];
                }else{
                    // s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长?
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        // 整个 s 的最长回文子串长度
        return dp[0][n - 1];
    }
};
```

### 647. 回文子串

给你一个字符串 `s` ，请你统计并返回这个字符串中**回文子串** 的数目。

回文字符串是正着读和倒过来读一样的字符串，子字符串 是字符串中的由连续字符组成的一个序列。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

```php
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

**布尔类型的`dp[i][j]`表示**区间范围`[i,j] `（注意是左闭右闭）的子串是否是回文子串，如果是`dp[i][j]`为true，否则为false。

当`s[i]`与`s[j]`不相等，`dp[i][j]`一定是false；当`s[i]`与`s[j]`相等时，有如下三种情况：

- 情况一：下标`i` 与 `j`相同，同一个字符例如`a`，当然是回文子串
- 情况二：下标`i` 与 `j`相差为1，例如`aa`，也是回文子串
- 情况三：下标：`i` 与 `j`相差大于1的时候，例如`cabac`，此时`s[i]`与`s[j]`已经相同了，我们看`i`到`j`区间是不是回文子串就看`aba`是不是回文就可以了。`aba`的区间就是` i+1 `与` j-1`区间，这个区间是不是回文就看`dp[i + 1][j - 1]`是否为true。

**初始化**：`dp[i][j]`初始化为false。

**遍历顺序**：首先从递推公式中可以看出，情况三是根据`dp[i + 1][j - 1]`是否为true，再对`dp[i][j]`进行赋值true的。所以一定要从下到上，从左到右遍历，这样保证`dp[i + 1][j - 1]`都是经过计算的。

```php
class Solution {
public:
    int countSubstrings(string s) {
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
        int res = 0, n = s.size();
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                // 三种情况全部包含
                if (s[i] == s[j] && (j - i <= 1 || dp[i + 1][j - 1])) {
                    res++;
                    dp[i][j] = true;
                }
            }
        }
        return res;
    }
};
```

### 1312. 让字符串成为回文串的最少插入次数

给你一个字符串 `s` ，每一次操作你都可以在字符串的任意位置插入任意字符，请你返回让 `s` 成为回文串的 最少操作次数 。「回文串」是正读和反读都相同的字符串。

```php
输入：s = "zzazz"
输出：0
解释：字符串 "zzazz" 已经是回文串了，所以不需要做任何插入操作。
    
输入：s = "mbadm"
输出：2
解释：字符串可变为 "mbdadbm" 或者 "mdbabdm" 。
```

[回文问题终极篇：最小代价构造回文串 - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1880906)

**二维数组`dp[i][j]`表示对字符串`s[i..j]`最少需要进行`dp[i][j]`次插入才能变成回文串**。想求`s`的最少插入次数，也就是求`dp[0][n - 1]`的大小（`n`为`s`的长度）。

当算出`dp[i+1][j-1]`，即知道了`s[i+1..j-1]`成为回文串的最小插入次数，那么也就可以认为`s[i+1..j-1]`已经是一个回文串了，所以通过`dp[i+1][j-1]`推导`dp[i][j]`的**关键就在于`s[i]`和`s[j]`这两个字符**。

如果`s[i] == s[j]`，不需要进行任何插入，只要知道如何把`s[i+1..j-1]`变成回文串即可。

如果`s[i] != s[j]`，有如下步骤：

**步骤一**，做选择，先将`s[i..j-1]`或者`s[i+1..j]`变成回文串。怎么做选择呢？谁变成回文串的插入次数少，就选谁呗。

比如图二的情况，将`s[i+1..j]`变成回文串的操作次数更小，因为它本身就是回文串，根本不需要插入；同理，对于图三，将`s[i..j-1]`变成回文串的操作次数更小。然而，如果 `s[i+1..j]`和`s[i..j-1]`都不是回文串，都至少需要插入一个字符才能变成回文，所以选择哪一个都一样。

**步骤二**，根据步骤一的选择，将`s[i..j]`变成回文串。

如果在步骤一中选择把`s[i+1..j]`变成回文串，那么在`s[i+1..j]`右边插入一个字符`s[i]`一定可以将`s[i..j]`变成回文；同理，如果在步骤一中选择把`s[i..j-1]`变成回文串，在`s[i..j-1]`左边插入一个字符`s[j]`一定可以将`s[i..j]`变成回文。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205241136018.png" alt="image-20220524113611854" style="zoom:70%;" /></div>

**初始化**：当`i == j`时`dp[i][j] = 0`，因为当`i == j`时`s[i..j]`就是一个字符，本身就是回文串，所以不需要进行任何插入操作。

```php
class Solution {
public:
    int minInsertions(string s) {
        int n = s.size();
        // 定义：对 s[i..j]，最少需要插入 dp[i][j] 次才能变成回文
        vector<vector<int>> dp(n, vector<int>(n, 0));
        // base case：i == j 时 dp[i][j] = 0，单个字符本身就是回文
        // 从下向上遍历
        for (int i = n - 2; i >= 0; i--) {
            // 从左向右遍历
            for (int j = i + 1; j < n; j++) {
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1];
                } else {
                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1;
                }
            }
        }
        return dp[0][n - 1];
    }
};
```

## 01背包问题

### 01背包问题理论

有`n`件物品和一个最多能背重量为`w` 的背包，第`i`件物品的重量是`weight[i]`，得到的价值是`value[i] `，**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

**解法一：二维dp数组01背包**

**数组`dp[i][j] `表示**从下标为`[0-i]`的物品里任意取，放进容量为`j`的背包，价值总和最大是多少。

那么可以有两个方向推出来`dp[i][j]`：

**不放物品i**：由`dp[i - 1][j]`推出，即背包容量为`j`，里面不放物品`i`的最大价值，此时`dp[i][j]`就是`dp[i - 1][j]`。(其实就是当物品`i`的重量大于背包`j`的重量时，物品`i`无法放进背包中，所以被背包内的价值依然和前面相同)。

**放物品i**：由`dp[i - 1][j - weight[i]]`推出，`dp[i - 1][j - weight[i]] `为背包容量为`j - weight[i]`的时候不放物品`i`的最大价值，那么`dp[i - 1][j - weight[i]] + value[i] `（物品`i`的价值），就是背包放物品`i`得到的最大价值。

所以**递归公式**为`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`。

**初始化**：

首先从`dp[i][j]`的定义出发，如果背包容量`j`为0的话，即`dp[i][0]`，无论是选取哪些物品，背包价值总和一定为0。

由状态转移方程 `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`可以看出`i` 是由` i-1 `推导出来，那么`i`为0的时候就一定要初始化。`dp[0][j]`，即`i`为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。

当` j < weight[0]`的时候，`dp[0][j]`应该是 0，因为背包容量比编号0的物品重量还小。

当`j >= weight[0]`时，`dp[0][j]`应该是`value[0]`，因为背包容量放足够放编号0物品。

`dp[0][j] `和` dp[i][0] `都已经初始化了，那么其他下标应该初始化多少呢？其实从递归公式可以看出`dp[i][j] `是由左上方数值推导出来了，那么其他下标初始为什么数值都可以，因为都会被覆盖。但只不过一开始就统一把`dp`数组统一初始为0，更方便一些。

**遍历顺序**：01背包中二维dp数组的两个for遍历的先后循序是可以颠倒的。

```php
int bagProblem(vector<int> weight, vector<int> value, int bagweight){
	int m = weight.size();
    vector<vector<int>> dp(m, vector<int>(bagweight + 1, 0));
    for(int j = weight[0]; j <= bagweight; j++){
		dp[0][j] = value[0];
    }
    for(int i = 1; i < m; i++) { // 遍历物品
        for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }
	return dp[m - 1][bagweight];
}
```

🦄**解法二：一维dp数组（滚动数组）**

**数组`dp[j]`表示**容量为`j`的背包，所背的物品价值可以最大为dp[j]。

`dp[j]`可以通过`dp[j - weight[i]]`推导出来，`dp[j - weight[i]]`表示容量为`j - weight[i]`的背包所背的最大价值。

`dp[j - weight[i]] + value[i]` 表示 容量为 `j - 物品i重量` 的背包 加上 物品`i`的价值。（也就是容量为j的背包，放入物品i了之后的价值即`dp[j]`）

此时`dp[j]`有两个选择：一个是取自己`dp[j]`，相当于二维dp数组中的`dp[i-1][j]`，即**不放**物品`i`；一个是取`dp[j - weight[i]] + value[i]`，即**放**物品`i`。取最大的，求最大价值。所以递归公式为`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`。

**初始化**：

`dp[j]`表示：容量为`j`的背包，所背的物品价值可以最大为`dp[j]`，那么`dp[0]`就应该是0，因为背包容量为0所背的物品的最大价值就是0。

那么dp数组除了下标0的位置初始为0，其他下标应该初始化多少呢？

看一下递归公式：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`，dp数组在推导的时候一定是取价值最大的数。如果题目给的价值都是正整数，那么非0下标都初始化为0就可以了，这样才能让dp数组在递归公式的过程中取最大的价值，而不是被初始值覆盖。

那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。

**遍历顺序**：

 遍历背包的顺序要从大到小倒序遍历，**倒序遍历是为了保证物品`i`只被放入一次！**但如果一旦正序遍历了，那么物品0就会被重复加入多次！每一个元素一定是不可重复放入，所以从大到小遍历，可以保证每个物品仅被添加一次。从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。

**再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？**

不可以！因为一维dp的写法，背包容量一定是要倒序遍历，如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即背包里只放入了一个物品。**所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！**

```php
int bagProblem(vector<int> weight, vector<int> value, int bagweight){
	vector<int> dp(bagweight + 1, 0);
	for(int i = 0; i < weight.size(); i++){ // 遍历物品
        for(int j = bagweight; j >= weight[i]; j--){ // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
	return dp[bagweight];
}
```

### 416. 分割等和子集

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

```php
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

找到集合里能够出现 `sum / 2` 的子集总和，就可以分割成两个相同元素和子集了。

**注意：一个商品如果可以重复多次放入是完全背包，而只能放入一次是01背包。**本题中我们要使用01背包，因为每个元素只能用一次。

只有确定了如下四点，才能把01背包问题套到本题上来：

- 背包的容量为 sum / 2
- 背包要放入的商品（集合里的元素）重量为元素的数值，价值也为元素的数值
- **背包如果正好装满**，说明找到了总和为 sum / 2 的子集。
- 背包中每一个元素是不可重复放入。

以上分析完，我们就可以套用01背包，来解决这个问题了。

01背包中，dp[j] 表示容量为`j`的背包，所背的物品价值可以最大为`dp[j]`。套到本题，**数组`dp[j]`表示**背包总容量是`j`，最大可以凑成`j`的子集总和为`dp[j]`。

01背包的递推公式为`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`，本题相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]，所以**递推公式**为`dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])`。

**初始化**：从dp[j]的定义来看，首先dp[0]一定是0。只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了。`dp[i]`中的`i`表示背包内总和，题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200，所以总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了。

**遍历顺序**：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！

```php
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        vector<int> dp(10001, 0);
        for (int num : nums) {
            sum += num;
        }
        // 和为奇数时，不可能划分成两个和相等的集合
        if (sum % 2 == 1) return false;
        int target = sum / 2;
        // 开始 01背包
        for(int i = 0; i < nums.size(); i++) { //遍历物品
            for(int j = target; j >= nums[i]; j--) { //遍历背包容量
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        // 集合中的元素正好可以凑成总和target
        return d[target] == target ? true : false;
    }
};
```

### 1049. 最后一块石头的重量 II

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

```php
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

本题其实就是**尽量让石头分成重量相同的两堆**，相撞之后剩下的石头最小，**这样就化解成01背包问题了**，和416. 分割等和子集非常像。本题物品的重量为`stones[i]` ，物品的价值也为`stones[i]` ，对应着01背包里的物品重量`weight[i] `和 物品价值`value[i]`。

**数组`dp[j]`表示容量为`j`的背包，最多可以背`dp[j]`这么重的石头**。

01背包的递推公式为`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`，本题则是`dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])`。

**初始化**：既然 dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。

因为提示中给出1 <= stones.length <= 30，1 <= stones[i] <= 1000，所以最大重量就是30 * 1000 。而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。

接下来就是如何初始化dp[j]，因为重量都不会是负数，所以`dp[j]`都初始化为0就可以了，这样在递归公式中`dp[j]`才不会被初始值所覆盖。

**遍历顺序**：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！

最后`dp[target]`就是容量为`target`的背包所能背的最大重量。那么分成两堆石头，一堆石头的总重量是`dp[target]`，另一堆就是`sum - dp[target]`。在计算`target`的时候，`target = sum / 2 `因为是向下取整，所以`sum - dp[target] `一定是大于等于`dp[target]`的。所以相撞之后剩下的最小石头重量就是 `(sum - dp[target]) - dp[target]`。

```php
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        vector<int> dp(15001, 0);
        int sum = 0;
        for (int stone : stones) sum += stone;
        int target = sum / 2;
        for (int i = 0; i < stones.size(); i++) { // 遍历物品
            for (int j = target; j >= stones[i]; j--) { // 遍历背包
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - dp[target] - dp[target];
    }
};
```

### 494. 目标和

给你一个整数数组 `nums` 和一个整数 `target` 。向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式**。

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

```php
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

如何转化为01背包问题呢？假设加法的总和为x，那么减法对应的总和就是sum - x。所以我们要求的是 x - (sum - x) = target，x = (target + sum) / 2，**此时问题就转化为装满容量为x背包，有几种方法**。

**数组`dp[j] `表示**填满`j`（包括j）这么大容积的包，有`dp[j]`种方法。

不考虑`nums[i]`的情况下，填满容量为`j - nums[i]`的背包，有`dp[j - nums[i]]`种方法。那么得到`nums[i]`的话，凑成`dp[j]`就有`dp[j - nums[i]]` 种方法，所以**递推公式为**`dp[j] += dp[j - nums[i]]`。

**初始化**：

dp[0] = 1，装满容量为0的背包，有1种方法，就是装0件物品。

dp[j]其他下标对应的数值应该初始化为0，从递归公式也可以看出，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。

```php
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for(int num : nums) sum += num;
        if(abs(target) > sum || (target + sum) % 2 != 0){
            return 0;
        }
        int bag = (sum + target) / 2;
        vector<int> d(bag + 1, 0);
        d[0] = 1;
        for(int i = 0; i < nums.size(); i++){ // 物品
            for(int j = bag; j >= nums[i]; j--){ // 背包
                d[j] += d[j - nums[i]];
            }
        }
        return d[bag];
    }
};
```

### 474.一和零

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集**。

```php
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```

本题是01背包问题，不过这个背包有两个维度，一个是m 一个是n，而不同长度的字符串就是不同大小的待装物品。

**数组`dp[i][j]`代表**最多有`i`个`0`和`j`个`1`的`strs`的最大子集的大小为`dp[i][j]`。

`dp[i][j] `可以由前一个`strs`里的字符串推导出来，strs里的字符串有`zeroNum`个0，`oneNum`个1。`dp[i][j] `就是 `dp[i - zeroNum][j - oneNum] + 1`。然后我们在遍历的过程中，取`dp[i][j]`的最大值，所以递推公式为`dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)`。

此时大家可以回想一下01背包的递推公式：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`。对比一下就会发现，字符串的`zeroNum`和`oneNum`相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。**这就是一个典型的01背包！** 只不过物品的重量有了两个维度而已。

 **初始化**：01背包的dp数组初始化为0就可以。因为物品价值不会是负数，初始为0，保证递推的时候`dp[i][j]`不会被初始值覆盖。

```php
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0));
        for (string str : strs) { // 遍历物品
            int oneNum = 0, zeroNum = 0;
            for (char c : str) {
                if (c == '0') zeroNum++;
                else oneNum++;
            }
            for (int i = m; i >= zeroNum; i--) { // 遍历背包容量
                for (int j = n; j >= oneNum; j--) {
                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```

## 完全背包问题

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

**在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是可以颠倒的！**因为`dp[j] `是根据下标`j`之前所对应的`dp[j]`计算出来的，只要保证下标`j`之前的`dp[j]`都是经过计算的就可以了。

```php
int bagProblem(vector<int> weight, vector<int> value, int bagweight){
    vector<int> dp(bagweight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = weight[i]; j <= bagweight; j++) { // 遍历背包容量
			dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
	return dp[bagweight];
}
```

**遍历顺序**：

若外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。

```cpp
for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
}
```

假设：coins[0] = 1，coins[1] = 5。

那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。**所以这种遍历顺序中dp[j]里计算的是组合数！**

如果把两个for交换顺序：

```text
for (int j = 0; j <= amount; j++) { // 遍历背包容量
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
    }
}
```

背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。**此时dp[j]里算出来的就是排列数！**

**总结**：如果求**组合数**就是外层for循环遍历物品，内层for遍历背包，如果求**排列数**就是外层for遍历背包，内层for循环遍历物品。

### 518. 零钱兑换 II

给你一个整数数组 `coins `表示不同面额的硬币，另给一个整数 `amount `表示总金额。请你计算并返回可以凑成总金额的硬币**组合数**。如果任何硬币组合都无法凑出总金额，返回 0 。**假设每一种面额的硬币有无限个**。 题目数据保证结果符合 32 位带符号整数。

```php
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

这是一道典型的背包问题，一看到钱币数量不限，就知道这是一个**完全背包**。

**数组`dp[j]`表示**凑成总金额`j`的货币组合数为`dp[j]`。

`dp[j]`（考虑coins[i]的组合总和） 就是所有的`dp[j - coins[i]]`（不考虑coins[i]）相加，所以递推公式为`dp[j] += dp[j - coins[i]]`。

**初始化**：首先dp[0]一定要为1，`dp[0] = 1`是 递归公式的基础。从`dp[i]`的含义上来讲就是，凑成总金额0的货币组合数为1。下标非0的dp[j]初始化为0，这样累计加`dp[j - coins[i]]`的时候才不会影响真正的dp[j]。

纯完全背包求得是能否凑成总和，和凑成总和的元素有没有顺序没关系，即有顺序也行，没有顺序也行！而本题要求凑成总和的**组合数**，**元素之间要求没有顺序**。

纯完全背包是能凑成总和就行，不用管怎么凑的。而本题是求凑出来的方案个数，且每个方案个数是组合数。

```php
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
};
```

### 377. 组合总和 Ⅳ

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

```php
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

本题题目描述说是求组合，但又说是可以元素相同顺序不同的组合算两个组合，**其实就是求排列！**

**数组`dp[i]`表示**凑成目标正整数为`i`的排列个数为`dp[i]`。

dp[i]（考虑nums[j]）可以由 dp[i - nums[j]]（不考虑nums[j]） 推导出来，因为只要得到nums[j]，排列个数dp[i - nums[j]]，就是dp[i]的一部分，**递推公式**是`dp[i] += dp[i - nums[j]]`。

**初始化**：

因为递推公式dp[i] += dp[i - nums[j]]的缘故，dp[0]要初始化为1，这样递归其他dp[i]的时候才会有数值基础。

至于dp[0] = 1 有没有意义呢？其实没有意义，所以我也不去强行解释它的意义了，因为题目中也说了：给定目标值是正整数！ 所以dp[0] = 1是没有意义的，仅仅是为了推导递推公式。

至于非0下标的dp[i]应该初始为多少呢？初始化为0，这样才不会影响dp[i]累加所有的dp[i - nums[j]]。

**遍历顺序**：

本题为**排列**问题，所以遍历顺序最终遍历顺序：**target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历**。

 ```php
 class Solution {
 public:
     int combinationSum4(vector<int>& nums, int target) {
         vector<int> dp(target + 1, 0);
         dp[0] = 1;
         for (int i = 0; i <= target; i++) { // 遍历背包
             for (int j = 0; j < nums.size(); j++) { // 遍历物品
                 if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) {
                     dp[i] += dp[i - nums[j]];
                 }
             }
         }
         return dp[target];
     }
 };
 ```

C++测试用例有两个数相加超过int的数据，所以需要在if里加上dp[i] < INT_MAX - dp[i - num]。

### 70. 爬楼梯

假设你正在爬楼梯，需要 `n` 阶你才能到达楼顶。每次你可以爬 `1` 或 `2` 个台阶，你有多少种不同的方法可以爬到楼顶呢？

```php
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

进阶版：一步一个台阶，两个台阶，三个台阶，.......，直到 m个台阶，问有多少种不同的方法可以爬到楼顶呢？每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶，**排列问题**。这是一个**完全背包问题**，和377. 组合总和 Ⅳ基本一样。1阶，2阶，.... m阶就是物品，楼顶就是背包。

**数组`dp[i]`表示**爬到有`i`个台阶的楼顶，有`dp[i]`种方法。**递推公式**为`dp[i] += dp[i - j]`。

**初始化**：

既然递归公式是 dp[i] += dp[i - j]，那么dp[0] 一定为1，dp[0]是递归中一切数值的基础所在，如果dp[0]是0的话，其他数值都是0了。下标非0的dp[i]初始化为0，因为dp[i]是靠dp[i-j]累计上来的，dp[i]本身为0这样才不会影响结果。

```php
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) { // 遍历背包
            for (int j = 1; j <= m; j++) { // 遍历物品
                if (i - j >= 0) dp[i] += dp[i - j];
            }
        }
        return dp[n];
    }
};
```

原题答案：

dp[i]： 爬到第i层楼梯，有dp[i]种方法。

首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。

那么dp[i]就是 dp[i - 1]与dp[i - 2]之和，所以dp[i] = dp[i - 1] + dp[i - 2] 。

初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推。

```php
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n; // 因为下面直接对dp[2]操作了，防止空指针
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) { // 注意i是从3开始的
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

优化：

```php
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n;
        int dp[3];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            int sum = dp[1] + dp[2];
            dp[1] = dp[2];
            dp[2] = sum;
        }
        return dp[2];
    }
};
```

### 322.零钱兑换

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。你可以认为每种硬币的数量是**无限**的。

```php
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
输入：coins = [2], amount = 3
输出：-1
```

题目中说每种硬币的数量是无限的，可以看出是典型的**完全背包**问题。

**数组`dp` 表示**当目标金额为 `i` 时，至少需要 `dp[i]` 枚硬币凑出。

得到dp[j]（考虑coins[i]），只有一个来源，dp[j - coins[i]]（没有考虑coins[i]）。凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]，即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）。所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的，递推公式为`dp[j] = min(dp[j - coins[i]] + 1, dp[j])`。

**初始化**：

首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0;

其他下标对应的数值呢？考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖，所以下标非0的元素都是应该是最大值。

**遍历顺序**：

本题求钱币最小个数，**那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数**。所以本题并不强调集合是组合还是排列。

```php
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                // 如果dp[j - coins[i]]是初始值则跳过
                if (dp[j - coins[i]] == INT_MAX) continue;
                dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
            }
        }
        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};
```

另一个遍历顺序的版本：

```php
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i <= amount; i++) {  // 遍历背包
            for (int j = 0; j < coins.size(); j++) { // 遍历物品
                if (i - coins[j] >= 0 && dp[i - coins[j]] != INT_MAX ) {
                    dp[i] = min(dp[i - coins[j]] + 1, dp[i]);
                }
            }
        }
        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};

```

### 279.完全平方数

给你一个整数 `n` ，返回和为 `n` 的完全平方数的最少数量 。

```php
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

完全平方数就是物品（可以无限件使用），凑个正整数`n`就是背包，问凑满这个背包最少有多少物品？

dp[j]：和为j的完全平方数的最少数量为dp[j]。

dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]，此时我们要选择最小的dp[j]，所以递推公式为`dp[j] = min(dp[j - i * i] + 1, dp[j])`。

dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。非0下标的dp[j]应该是多少呢？从递归公式dp[j] = min(dp[j - i * i] + 1, dp[j])中可以看出每次dp[j]都要选最小的，所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖。

本题是求最小值，遍历顺序无要求。

```php
class Solution {
public:
    int numSquares(int n) {
        vector<int> d(n + 1, INT_MAX);
        d[0] = 0;
        for(int i = 1; i <= sqrt(n); i++){ // 遍历物品
            for(int j = i * i; j <= n; j++){ // 遍历背包
                d[j] = min(d[j], d[j - i * i] + 1);
            }
        }
        return d[n] == INT_MAX ? 0 : d[n];
    }
};
```

### 139.单词拆分

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典，请你判断是否可以利用字典中出现的单词拼接出 `s` 。**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

```php
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。拆分时可以重复使用字典中的单词，说明就是一个**完全背包**！

数组dp[i]：字符串长度为`i`的话，dp[i]为true表示可以拆分为一个或多个在字典中出现的单词。

如果确定dp[j] 是true，且 `[j, i]` 这个区间的子串出现在字典里，那么dp[i]一定是true (j < i)，所以递推公式是` if([j, i] 这个区间的子串出现在字典里 && dp[j]是true) `那么 dp[i] = true。

**初始化**：从递归公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了。

那么dp[0]有没有意义呢？dp[0]表示如果字符串为空的话，说明出现在字典里。但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。

下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。

**遍历顺序**：本题最终要求的是是否都出现过，所以对出现单词集合里的元素是组合还是排列，并不在意！那么本题使用求排列的方式，还是求组合的方式都可以。

但本题还有特殊性，因为是要求子串，最好是遍历背包放在外循环，将遍历物品放在内循环。如果要是外层for循环遍历物品，内层for遍历背包，就需要把所有的子串都预先放在一个容器里。

```php
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i <= s.size(); i++) {   // 遍历背包
            for (int j = 0; j < i; j++) {       // 遍历物品
                string word = s.substr(j, i - j); //substr(起始位置，截取的个数)
                if (wordSet.co(word) && dp[j]) {
                    dp[i] = true;
                }
            }
        }
        return dp[s.size()];
    }
};
```

## 打家劫舍问题

### 198. 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的**非负整数数组**，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

```php
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

`dp[i]`：考虑下标`i`（包括`i`）以内的房屋，最多可以偷窃的金额为`dp[i]`。

决定`dp[i]`的因素就是第`i`房间偷还是不偷：

如果偷第`i`房间，那么`dp[i] = dp[i - 2] + nums[i]` ，即第`i-1`房一定是不考虑的，找出 下标`i-2`（包括`i-2`）以内的房屋，最多可以偷窃的金额为`dp[i-2]` 加上第`i`房间偷到的钱。

如果不偷第`i`房间，那么`dp[i] = dp[i - 1]`，即考虑`i-1`房（**注意这里是考虑，并不是一定要偷`i-1`房**），然后`dp[i]`取最大值，即`dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])`。

**初始化**：从递推公式`dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])`可以看出，递推公式的基础就是`dp[0]` 和 `dp[1]`。从`dp[i]`的定义上来讲，`dp[0]` 一定是` nums[0]`，`dp[1]`就是`nums[0]`和`nums[1]`的最大值，即`dp[1] = max(nums[0], nums[1])`。

**遍历顺序**：dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历。

```php
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.empty()) return 0;
        if(nums.size() == 1) return nums[0];
        vector<int> d(nums.size());
        d[0] = nums[0];
        d[1] = max(nums[0], nums[1]);
        for(int i = 2; i < nums.size(); i++){
            d[i] = max(d[i - 2] + nums[i], d[i - 1]);
        }
        return d[nums.size() - 1];
    }
};
```

### 213. 打家劫舍 II

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都**围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

```php
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

这道题目和**198.打家劫舍**是差不多的，唯一区别就是成环了。

对于一个数组，成环的话主要有如下三种情况：

- 情况一：考虑不包含首尾元素
- 情况二：考虑包含首元素，不包含尾元素
- 情况三：考虑包含尾元素，不包含首元素

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205272041147.png" alt="image-20220527204113996" style="zoom:80%;" /></div>

注意：这里用的是 ⌈**考虑**⌋，例如情况三，虽然是考虑包含尾元素，但不一定要选尾部元素！ 对于情况三，取nums[1] 和 nums[3]就是最大的。**而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了**。

分析到这里，本题其实比较简单了， 剩下的和[198.打家劫舍](https://programmercarl.com/0198.打家劫舍.html)就是一样的了。

```php
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
        int result1 = robRange(nums, 0, nums.size() - 2); // 情况二
        int result2 = robRange(nums, 1, nums.size() - 1); // 情况三
        return max(result1, result2);
    }
    // 198.打家劫舍的逻辑
    int robRange(vector<int>& nums, int start, int end) {
        if (end == start) return nums[start];
        vector<int> dp(nums.size());
        dp[start] = nums[start];
        dp[start + 1] = max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[end];
    }
};
```

### 337. 打家劫舍 III

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root`。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。

给定二叉树的 `root` 。返回 **在不触动警报的情况下** ，小偷能够盗取的最高金额。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205272053588.png" alt="image-20220527205315463" style="zoom:70%;" /></div>

```php
输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
```

定义函数：返回一个节点偷与不偷两个状态所得到的金钱，返回值是一个长度为2的数组，记录当前节点偷与不偷所得到的的最大金钱。

dp数组以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱，本题dp数组就是一个长度为2的数组。

如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：`val1 = max(left[0], left[1]) + max(right[0], right[1])`；如果是偷当前节点，那么左右孩子就不能偷，`val2 = cur->val + left[0] + right[0]`；

最后当前节点的状态就是`{val2, val1}`，即{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}。

**初始化**：在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回。

```php
class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> result = robTree(root);
        return max(result[0], result[1]);
    }
    // 返回长度为2的数组，0：不偷，1：偷
    vector<int> robTree(TreeNode* cur) {
        if (cur == NULL) return {0, 0};
        vector<int> left = robTree(cur->left);
        vector<int> right = robTree(cur->right);
        // 不偷cur
        int val1 = max(left[0], left[1]) + max(right[0], right[1]);
        // 偷cur
        int val2 = cur->val + left[0] + right[0];
        return {val1, val2};
    }
};
```

##  股票买卖问题

### 121. 买卖股票的最佳时机

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润，返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

```php
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

定义：`dp[i][1]` 表示第`i`天**持有**股票所得最多现金 ，`dp[i][0]` 表示第`i`天**不持有**股票所得最多现金。

如果第`i`天**持有**股票即`dp[i][1]`， 那么可以由两个状态推出来：

- 第`i-1`天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金，即`dp[i - 1][1]`；
- 第`i`天买入股票，所得现金就是买入今天的股票后所得现金，即`-prices[i]`；

那么`dp[i][1]`应该选所得现金最大的，所以`dp[i][1] = max(dp[i - 1][1], -prices[i])`。

如果第`i`天**不持有**股票即`dp[i][0]`， 也可以由两个状态推出来：

- 第`i-1`天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金，即`dp[i - 1][0]`；
- 第`i`天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金，即`prices[i] + dp[i - 1][1]`；

同样`dp[i][1]`取最大值，`dp[i][0] = max(dp[i - 1][0], prices[i] + dp[i - 1][1])`。

**初始化**：

由递推公式` dp[i][1] = max(dp[i - 1][1], -prices[i])`和 `dp[i][0] = max(dp[i - 1][0], prices[i] + dp[i - 1][1])`可以看出其基础都是要从`dp[0][0]`和`dp[0][1]`推导出来。

`dp[0][1]`表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能由前一天推出来，所以`dp[0][1] = - prices[0]`。`dp[0][0]`表示第0天不持有股票，不持有股票那么现金就是0，所以`dp[0][0] = 0`。

 ```php
 class Solution {
 public:
     int maxProfit(vector<int>& prices) {
         int len = prices.size();
         if (len == 0) return 0;
         vector<vector<int>> dp(len, vector<int>(2, 0));
         dp[0][1] = - prices[0];
         for (int i = 1; i < len; i++) {
             dp[i][1] = max(dp[i - 1][1], -prices[i]);
             dp[i][0] = max(dp[i - 1][0], prices[i] + dp[i - 1][1]);
         }
         return dp[len - 1][0];
     }
 };
 ```

### 122. 买卖股票的最佳时机 II

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

```php
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
```

本题和**121. 买卖股票的最佳时机**的唯一区别本题股票可以买卖多次了（注意只有一只股票，所以再次购买前要出售掉之前的股票）。

定义：`dp[i][1]` 表示第`i`天**持有**股票所得最多现金 ，`dp[i][0]` 表示第`i`天**不持有**股票所得最多现金。

如果第`i`天**持有**股票即`dp[i][1]`， 那么可以由两个状态推出来：

- 第`i-1`天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金，即`dp[i - 1][1]`；
- 第`i`天买入股票，所得现金就是昨天不持有股票的所得现金减去今天的股票价格，即`dp[i - 1][0] - prices[i]`；

注意这里和121. 买卖股票的最佳时机唯一不同的地方，就是推导`dp[i][1]`的时候，第`i`天买入股票的情况。在121. 买卖股票的最佳时机中，**因为股票全程只能买卖一次**，所以如果买入股票，那么第`i`天持有股票即`dp[i][1]`一定就是` -prices[i]`。

而本题，**因为一只股票可以买卖多次**，所以当第`i`天买入股票的时候，所持有的现金可能有之前买卖过的利润。那么第`i`天持有股票即`dp[i][1]`，如果是第`i`天买入股票，所得现金就是昨天不持有股票的所得现金减去今天的股票价格，即`dp[i - 1][0] - prices[i]`。

如果第`i`天**不持有**股票即`dp[i][0]`的情况， 依然可以由两个状态推出来：

- 第`i-1`天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金，即`dp[i - 1][0]`；
- 第`i`天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金，即`prices[i] + dp[i - 1][1]`；

```php
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        if (len == 0) return 0;
        vector<vector<int>> dp(len, vector<int>(2, 0));
        dp[0][1] = - prices[0];
        for (int i = 1; i < len; i++) {
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] -prices[i]);
            dp[i][0] = max(dp[i - 1][0], prices[i] + dp[i - 1][1]);
        }
        return dp[len - 1][0];
    }
};
```

### 123. 买卖股票的最佳时机 III

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```php
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

本题中至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。

一天一共就有五个状态：0. 没有操作，1. 第一次买入，2. 第一次卖出，3. 第二次买入，4. 第二次卖出。

`dp[i][j]`中 `i`表示第`i`天，`j`为 `[0 - 4] `五个状态，`dp[i][j]`表示第`i`天状态`j`所剩最大现金。

注意：表示的是第`i`天，买入股票的状态，并不是说一定要第`i`天买入股票。

 达到`dp[i][1]`状态，有两个具体操作：

- 操作一：第`i`天买入股票，那么`dp[i][1] = dp[i-1][0] - prices[i]`
- 操作二：第`i`天没有操作，而是沿用前一天买入的状态，即`dp[i][1] = dp[i - 1][1]`

取最大值，所以` dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1])`。

同理`dp[i][2]`也有两个操作：

- 操作一：第`i`天卖出股票了，那么`dp[i][2] = dp[i - 1][1] + prices[i]`
- 操作二：第`i`天没有操作，沿用前一天卖出股票的状态，即`dp[i][2] = dp[i - 1][2]`

所以`dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])`。

同理可推出剩下状态部分：`dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])`，`dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])`。

 **初始化**：

第0天**没有操作**，`dp[0][0] = 0`。

第0天做**第一次买入**的操作，`dp[0][1] = -prices[0]`。

第0天做**第一次卖出**的操作，这个初始值应该是多少呢？首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，从递推公式中可以看出每次是取最大值，那么既然是收获利润，如果比0还小了就没有必要收获这个利润了，所以`dp[0][2] = 0`。

第0天**第二次买入**操作，初始值应该是多少呢？第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。所以第二次买入操作，初始化为`dp[0][3] = -prices[0]`。

同理，第0天**第二次卖出**初始化`dp[0][4] = 0`。

```php
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        if (len == 0) return 0;
        vector<vector<int>> dp(len, vector<int>(5, 0));
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        for (int i = 1; i < len; i++) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[len - 1][4];
    }
};
```

### 188.买卖股票的最佳时机IV

给定一个整数数组 `prices` ，它的第 `i` 个元素 `prices[i]` 是一支给定的股票在第 `i` 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```php
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

本题要求至多有`k`次交易。

二维数组 `dp[i][j]` ：第`i`天的状态为`j`，所剩下的最大现金是`dp[i][j]`。

`j`的状态表示为：0 表示不操作，1 第一次买入，2 第一次卖出，3 第二次买入，4 第二次卖出 .....

发现规律：除了0以外，奇数就是买入，偶数就是卖出。题目要求至多有k笔交易，那么`j`的范围就定义为 `2 * k + 1 `就可以了。

达到`dp[i][1]`状态，有两个具体操作：

- 操作一：第`i`天买入股票了，那么`dp[i][1] = dp[i - 1][0] - prices[i]`
- 操作二：第`i`天没有操作，而是沿用前一天买入的状态，即`dp[i][1] = dp[i - 1][1]`

选最大的，所以 `dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1])`。

同理`dp[i][2]`也有两个操作：

- 操作一：第`i`天卖出股票了，那么`dp[i][2] = dp[i - 1][1] + prices[i]`
- 操作二：第`i`天没有操作，沿用前一天卖出股票的状态，即`dp[i][2] = dp[i - 1][2]`

所以`dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])`。

同理可以类比剩下的状态。

**初始化**：

第0天**没有操作**，`dp[0][0] = 0`。

第0天做**第一次买入**的操作，`dp[0][1] = -prices[0]`。

第0天做**第一次卖出**的操作，这个初始值应该是多少呢？首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0。从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了，所以`dp[0][2] = 0`。

第0天**第二次买入操**作，初始值应该是多少呢？不用管第几次，现在手头上没有现金，只要买入，现金就做相应的减少。第二次买入操作，初始化为`dp[0][3] = -prices[0]`。

可以推出`dp[0][j]`当`j`为奇数的时候都初始化为` -prices[0]`，当`j`为偶数的时候都初始化为0。

 ```php
 class Solution {
 public:
     int maxProfit(int k, vector<int>& prices) {
         int len = prices.size();
         if (len == 0) return 0;
         vector<vector<int>> dp(len, vector<int>(2 * k + 1, 0));
         for (int j = 1; j < 2 * k; j += 2) {
             dp[0][j] = -prices[0];
         }
         for (int i = 1; i < len; i++) {
             for (int j = 0; j < 2 * k - 1; j += 2) {
                 dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                 dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
             }
         }
         return dp[len - 1][2 * k];
     }
 };
 ```

###  309. 最佳买卖股票时机含冷冻期

给定一个整数数组`prices`，其中第 `prices[i]` 表示第 `i` 天的股票价格 。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）：**卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)**。**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```php
输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

`dp[i][j]`：第`i`天状态为`j`，所剩的最多现金为`dp[i][j]`。

可以区分出如下四个状态，（将买出股票状态细分为三个状态：状态0，2，3）：

- 状态0：今天卖出股票
- 状态1：今天为买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）
- 状态2：今天为冷冻期状态，持续一天
- 状态3：今天已经度过冷冻期，一直没操作，今天保持卖出股票状态

`j`的状态为：0：状态0，1：状态1，2：状态2，3：状态3。

达到今天就卖出股票状态（**状态0**），即`dp[i][0] `，只有一种可能：昨天一定是买入股票状态（状态1），今天卖出，`dp[i][0] = dp[i - 1][1] + prices[i]`

达到买入股票状态（**状态1**）即`dp[i][1]`，有如下情况：

- 前一天就是持有股票状态（状态0），`dp[i][1] = dp[i - 1][1]`
- 前一天是冷冻期（状态2），`dp[i - 1][2] - prices[i]`
- 前一天已经度过冷冻期（状态3），`dp[i - 1][3] - prices[i]`

取最大值，那么`dp[i][1] = max(dp[i - 1][1], max(dp[i - 1][2], dp[i - 1][3]) - prices[i])`。

达到冷冻期状态（**状态2**），即`dp[i][2]`，只有一种情况：昨天卖出了股票（状态0），`dp[i][2] = dp[i - 1][0]`。

已经度过冷冻期（**状态3**）即`dp[i][3]`，有两个情况：

- 前一天就是冷冻期（状态2）
- 前一天依然度过了冷冻期（状态3）

`dp[i][3] = max(dp[i - 1][3], dp[i - 1][2])`

**初始化**：

今天卖出了股票（状态0），`dp[0][0]`初始化为0，因为最少收益就是0，绝不会是负数。

如果是持有股票状态（状态1）那么`dp[0][1] = -prices[0]`，买入股票所剩现金为负数。

处在冷冻期（状态2），`dp[0][2]`初始化为0。

保持卖出股票已经度过了冷冻期（状态3），`dp[0][3]`初始化为0。

最后结果是取状态0，状态2，和状态3的最大值。别把状态2忘了，状态2是冷冻期，最后一天如果是冷冻期也可能是最大值。

```php
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        vector<vector<int>> dp(n, vector<int>(4, 0));
        dp[0][1] -= prices[0]; 
        for (int i = 1; i < n; i++) {
            dp[i][0] = dp[i - 1][1] + prices[i];
            dp[i][1] = max(dp[i - 1][1], max(dp[i - 1][2], dp[i - 1][3]) - prices[i]);
            dp[i][2] = dp[i - 1][0];
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2]);
        }
        return max(dp[n - 1][0], max(dp[n - 1][2], dp[n - 1][3]));
    }
};
```

### 714. 买卖股票的最佳时机含手续费

给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

```php
输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
```

本题和动态规划**122.买卖股票的最佳时机II**的区别就是这里需要多一个**减去手续费**的操作。

`dp[i][1]`表示第`i`天**持有**股票所省最多现金，`dp[i][0] `表示第`i`天**不持有**股票所得最多现金。

如果第`i`天**持有**股票即`dp[i][1]`， 那么可以由两个状态推出来：

- 第`i-1`天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金，即`dp[i - 1][1]`
- 第`i`天买入股票，所得现金就是昨天不持有股票的所得现金减去今天的股票价格，即`dp[i - 1][0] - prices[i]`

所以：`dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])`。

如果第`i`天**不持有**股票即`dp[i][0]`的情况， 依然可以由两个状态推出来：

- 第`i-1`天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金，即`dp[i - 1][0]`
- 第`i`天卖出股票，所得现金就是按照今天股票价格卖出后所得现金，**注意这里需要有手续费了**，即`dp[i - 1][1] + prices[i] - fee`

所以：`dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee)`。

```php
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][1] -= prices[0]; 
        for (int i = 1; i < n; i++) {
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);
        }
        return max(dp[n - 1][0], dp[n - 1][1]);
    }
};
```

# 六、贪心算法

## 435. 无重叠区间

给定一个区间的集合 `intervals `，其中 `intervals[i] = [starti, endi]` ，返回需要移除区间的最小数量，使剩余区间互不重叠 。

```php
输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

右边界排序，从左向右记录非交叉区间的个数，最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了。

右边界排序之后，局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。全局最优：选取最多的非交叉区间。局部最优推出全局最优，试试贪心！

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206041059719.png" alt="image-20220604105951584" style="zoom:80%;" /></div>

```php
class Solution {
public:
    // 按照区间右边界排序
    static bool cmp (const vector<int>& a, const vector<int>& b) {
        return a[1] < b[1];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.size() == 0) return 0;
        sort(intervals.begin(), intervals.end(), cmp);
        int count = 1; // 记录非交叉区间的个数
        int end = intervals[0][1]; // 记录区间分割点
        for (int i = 1; i < intervals.size(); i++) {
            if (end <= intervals[i][0]) {
                end = intervals[i][1];
                count++;
            }
        }
        return intervals.size() - count;
    }
};
```

## 452. 用最少数量的箭引爆气球

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points `，其中`points[i] = [xstart, xend] `表示水平直径在 `xstart `和 `xend`之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为` xstart，xend`， 且满足  `xstart ≤ x ≤ xend`，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 `points` ，返回引爆所有气球所必须射出的**最小**弓箭数 。

```php
输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。
```

这道题和**435. 无重叠区间**一模一样，就是求非交叉区间的个数。

```php
class Solution {
public:
    static bool cmp(const vector<int>& a, const vector<int>& b){
        return a[1] < b[1];
    }

    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(), points.end(), cmp);
        int count = 1;
        int end = points[0][1];
        for(int i = 1; i < points.size(); i++){
            if(end < points[i][0]){
                end = points[i][1];
                count++;
            }
        }
        return count;
    }
};
```

**另一种思路**：

局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。为了让气球尽可能的重叠，需要对数组进行排序。如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，只要记录一下箭的数量就可以了。

那么按照气球起始位置排序，还是按照气球终止位置排序呢？其实都可以！只不过对应的遍历顺序不同，我就按照气球的**起始位置**排序了。既然按照起始位置排序，那么就从前向后遍历气球数组，靠左尽可能让气球重复。从前向后遍历遇到重叠的气球了怎么办？如果气球重叠了，重叠气球中右边界的最小值之前的区间一定需要一个弓箭。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206041118110.png" alt="image-20220604111850994" style="zoom:80%;" /></div>

可以看出首先第一组重叠气球，一定是需要一个箭。气球3的左边界大于了第一组重叠气球的最小右边界，所以再需要一支箭来射气球3了。

```php
class Solution {
private:
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        return a[0] < b[0];
    }
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        if (points.size() == 0) return 0;
        sort(points.begin(), points.end(), cmp);
        int result = 1; // points 不为空至少需要一支箭
        for (int i = 1; i < points.size(); i++) {
            if (points[i][0] > points[i - 1][1]) {  // 气球i和气球i-1不挨着，注意这里不是>=
                result++; // 需要一支箭
            } else {  // 气球i和气球i-1挨着
                points[i][1] = min(points[i - 1][1], points[i][1]); // 更新重叠气球最小右边界
            }
        }
        return result;
    }
};
```

注意：题目中说的是满足 `xstart ≤ x ≤ xend`，则该气球会被引爆。那么说明两个气球挨在一起不重叠也可以一起射爆，所以代码中 `if (points[i][0] > points[i - 1][1])` 不能是`>=`。

## 455. 分发饼干

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 `i`，都有一个胃口值`g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果` s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

```php
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。
```

这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱每一个，全局最优就是喂饱尽可能多的小孩。可以尝试使用贪心策略，先将饼干数组和小孩数组排序，然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206041508120.png" alt="image-20220604150855991" style="zoom:80%;" /></div>

```php
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int index = s.size() - 1; // 饼干数组的下标
        int result = 0;
        for (int i = g.size() - 1; i >= 0; i--) {
            if (index >= 0 && s[index] >= g[i]) {
                result++;
                index--;
            }
        }
        return result;
    }
};
```

用了一个`index`来控制饼干数组的遍历，遍历饼干并没有再起一个for循环，而是采用自减的方式。因为一块饼干在分配之后，后面的孩子就要从下一块饼干开始分配了，所以不能采用两层for循环。

## 135. 分发糖果

n 个孩子站成一排。给你一个整数数组 `ratings `表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：每个孩子至少分配到 1 个糖果，相邻两个孩子评分更高的孩子会获得更多的糖果。请你给每个孩子分发糖果，计算并返回需要准备的**最少**糖果数目 。

```php
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

我们可以将「相邻的孩子中，评分高的孩子必须获得更多的糖果」这句话拆分为两个规则，分别处理。

- 左规则：当`ratings[i - 1] < ratings[i]`时，`i`号学生的糖果数量将比`i-1`号孩子的糖果数量多。

- 右规则：当`ratings[i] > ratings[i + 1]`时，`i`号学生的糖果数量将比`i + 1`号孩子的糖果数量多。

我们遍历该数组两次，处理出每一个学生分别满足左规则或右规则时，**最少**需要被分得的糖果数量。每个人最终分得的糖果数量即为这两个数量的**最大值**。

```php
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> candyVec(ratings.size(), 1);
        // 从前向后
        for (int i = 1; i < ratings.size(); i++) {
            if (ratings[i] > ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1;
        }
        // 从后向前
        for (int i = ratings.size() - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1] ) {
                candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1);
            }
        }
        // 统计结果
        int result = 0;
        for (int i = 0; i < candyVec.size(); i++) result += candyVec[i];
        return result;
    }
};
```

## 406.根据身高重建队列

假设有打乱顺序的一群人站成一个队列，数组 `people `表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi `，前面 正好 有 `ki `个身高大于或等于 `hi `的人。

请你重新构造并返回输入数组 `people `所表示的队列，返回的队列应该格式化为数组`queue `，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0] `是排在队列前面的人）。

```php
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
```

一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。

在本题目中，首先对数对进行排序，按照数对的元素 1 降序排序，按照数对的元素 2 升序排序。原因是按照元素 1 进行**降序**排序，对于每个元素，在其之前的元素的个数，就是大于等于他的元素的数量，而按照第二个元素**升序**排序，我们希望 k 大的尽量在后面，减少插入操作的次数。

```php
class Solution {
public:
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        if (a[0] == b[0]) return a[1] < b[1];
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort (people.begin(), people.end(), cmp);
        vector<vector<int>> que;
        for (int i = 0; i < people.size(); i++) {
            int position = people[i][1];
            que.insert(que.begin() + position, people[i]);
        }
        return que;
    }
};
```

## 376. 摆动序列

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

```php
输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
```

局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。

实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）。这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点。

本题代码实现中，还有一些技巧，例如统计峰值的时候，数组最左面和最右面是最不好统计的。例如序列[2,5]，它的峰值数量是2，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。所以可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即preDiff = 0，如图：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206041541717.png" alt="image-20220604154143611" style="zoom:80%;" /></div>

针对以上情形，result初始为1（默认最右面有一个峰值），此时curDiff > 0 && preDiff <= 0，那么result++（计算了左面的峰值），最后得到的result就是2（峰值个数为2即摆动序列长度为2）

```php
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        int curDiff = 0; // 当前一对差值
        int preDiff = 0; // 前一对差值
        int result = 1;  // 记录峰值个数，序默认序列最右边有一个峰值
        for (int i = 0; i < nums.size() - 1; i++) {
            curDiff = nums[i + 1] - nums[i];
            // 出现峰值
            if ((curDiff > 0 && preDiff <= 0) || (preDiff >= 0 && curDiff < 0)) {
                result++;
                preDiff = curDiff;
            }
        }
        return result;
    }
};
```

## 55. 跳跃游戏

给定一个非负整数数组 `nums `，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度，判断你是否能够到达最后一个下标。

```php
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

这道题目关键点在于：不用拘泥于每次究竟跳几步，而是看覆盖范围，覆盖范围内一定是可以跳过来的，不用管是怎么跳的。

这个问题转化为跳跃覆盖范围究竟可不可以覆盖到终点！每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206041600729.png" alt="image-20220604160039587" style="zoom:80%;" /></div>

`i`每次移动只能在cover的范围内移动，每移动一个元素，cover得到该元素数值（新的覆盖范围）的补充，让`i`继续移动下去。而cover每次只取 max (该元素数值补充后的范围, cover本身范围)，如果cover大于等于了终点下标，直接return true就可以了。

```php
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cover = 0;
        if (nums.size() == 1) return true; // 只有一个元素，就是能达到
        for (int i = 0; i <= cover; i++) { // 注意这里是小于等于cover
            cover = max(i + nums[i], cover);
            if (cover >= nums.size() - 1) return true; // 说明可以覆盖到终点了
        }
        return false;
    }
};
```

## 45. 跳跃游戏 II

给你一个非负整数数组 nums ，你最初位于数组的第一个位置，数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置，假设你总是可以到达数组的最后一个位置。

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

本题要计算最小步数，那么就要想清楚什么时候步数才一定要加一呢？贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最小步数。

从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，**以最小的步数增加覆盖范围**，覆盖范围一旦覆盖了终点，得到的就是最小步数！这里需要统计两个覆盖范围，**当前这一步的最大覆盖和下一步最大覆盖**。如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206041611931.png" alt="image-20220604161108806" style="zoom:80%;" /></div>

移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不考虑是不是终点的情况。想要达到这样的效果，只要让移动下标，最大只能移动到`nums.size - 2`的地方就可以了。

```php
class Solution {
public:
    int jump(vector<int>& nums) {
        int curDistance = 0;    // 当前覆盖的最远距离下标
        int ans = 0;            // 记录走的最大步数
        int nextDistance = 0;   // 下一步覆盖的最远距离下标
        for (int i = 0; i < nums.size() - 1; i++) { // 注意这里是小于nums.size() - 1，这是关键所在
            nextDistance = max(nums[i] + i, nextDistance); // 更新下一步覆盖的最远距离下标
            if (i == curDistance) {                 // 遇到当前覆盖的最远距离下标
                curDistance = nextDistance;         // 更新当前覆盖的最远距离下标
                ans++;
            }
        }
        return ans;
    }
};
```

## 1005.K次取反后最大化的数组和

给你一个整数数组 `nums `和一个整数 `k` ，按以下方法修改该数组：选择某个下标 `i `并将 `nums[i]` 替换为 `-nums[i]` 。重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i `。以这种方式修改数组后，返回数组可能的最大和 。

```php
输入：nums = [4,2,3], k = 1
输出：5
解释：选择下标 1 ，nums 变为 [4,-2,3] 。
```

贪心的思路，局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。那么如果将负数都转变为正数了，K依然大于0，此时的问题是一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。那么又是一个贪心：局部最优：只找数值最小的正整数进行反转，当前数值可以达到最大，全局最优：整个 数组和 达到最大。

那么本题的解题步骤为：

- 第一步：将数组按照绝对值大小从大到小排序，**注意要按照绝对值的大小**
- 第二步：从前向后遍历，遇到负数将其变为正数，同时`k--`
- 第三步：如果k还大于0，那么反复转变数值最小的元素，将k用完
- 第四步：求和

```php
class Solution {
static bool cmp(int a, int b) {
    return abs(a) > abs(b);
}
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end(), cmp);       // 第一步
        for (int i = 0; i < nums.size(); i++) { // 第二步
            if (nums[i] < 0 && k > 0) {
                nums[i] *= -1;
                k--;
            }
        }
        if (k % 2 == 1) nums[nums.size() - 1] *= -1; // 第三步
        int result = 0;
        for (int a : nums) result += a;        // 第四步
        return result;
    }
};
```

## 134. 加油站

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。给定两个整数数组 `gas` 和 `cost `，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。

```php
输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
```

首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明各个站点的加油站与剩油量rest[i]相加一定是大于等于零的。

每个加油站的剩余量`rest[i]`为`gas[i] - cost[i]`。`i`从0开始累加`rest[i]`，和记为`curSum`，一旦`curSum`小于零，说明`[0, i]`区间都不能作为起始位置，起始位置从`i + 1`算起，再从0计算`curSum`。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206041643622.png" alt="image-20220604164314694" style="zoom:80%;" /></div>

那么为什么一旦[i，j] 区间和为负数，起始位置就可以是j+1呢，j+1后面就不会出现更大的负数？如果出现更大的负数，就是更新j，那么起始位置又变成新的j+1了。而且j之前出现了多少负数，j后面就会出现多少正数，因为耗油总和是大于零的（前提我们已经确定了一定可以跑完全程）。

那么局部最优：当前累加`rest[j]`的和`curSum`一旦小于0，起始位置至少要是`j + 1`，因为从`j`开始一定不行。全局最优：找到可以跑一圈的起始位置。

```php
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int totalSum = 0;
        int start = 0;
        for (int i = 0; i < gas.size(); i++) {
            curSum += gas[i] - cost[i];
            totalSum += gas[i] - cost[i];
            if (curSum < 0) {   // 当前累加rest[i]和 curSum一旦小于0
                start = i + 1;  // 起始位置更新为i+1
                curSum = 0;     // curSum从0开始
            }
        }
        if (totalSum < 0) return -1; // 说明怎么走都不可能跑一圈了
        return start;
    }
};
```

## 860.柠檬水找零

在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。注意，一开始你手头没有任何零钱。给你一个整数数组 bills ，其中 `bills[i]` 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

```php
输入：bills = [5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。
```

有如下三种情况：

- 情况一：账单是5，直接收下；
- 情况二：账单是10，消耗一个5，增加一个10；
- 情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5；

账单是20的情况，为什么要优先消耗一个10和一个5呢？因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！所以局部最优：遇到账单20，优先消耗美元10，完成本次找零。全局最优：完成全部账单的找零。

```php
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int five = 0, ten = 0;
        for (int bill : bills) {
            // 情况一
            if (bill == 5) five++;
            // 情况二
            if (bill == 10) {
                if (five <= 0) return false;
                ten++;
                five--;
            }
            // 情况三
            if (bill == 20) {
                // 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着
                if (five > 0 && ten > 0) {
                    five--;
                    ten--;
                } else if (five >= 3) {
                    five -= 3;
                } else return false;
            }
        }
        return true;
    }
};
```

## 763. 划分字母区间

字符串 `S `由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

 ```php
 输入：S = "ababcbacadefegdehijhklij"
 输出：[9,7,8]
 解释：
 划分结果为 "ababcbaca", "defegde", "hijhklij"。每个字母最多出现在一个片段中。像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
 ```

在遍历的过程中要找每一个字母的边界，**如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了**。此时前面出现过所有字母，最远也就到这个边界了。可以分为如下两步：

- 统计每一个字符最后出现的位置
- 从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点

```php
class Solution {
public:
    vector<int> partitionLabels(string S) {
        int hash[27] = {0}; // i为字符，hash[i]为字符出现的最后位置
        for (int i = 0; i < S.size(); i++) { // 统计每一个字符最后出现的位置
            hash[S[i] - 'a'] = i;
        }
        vector<int> result;
        int left = 0;
        int right = 0;
        for (int i = 0; i < S.size(); i++) {
            right = max(right, hash[S[i] - 'a']); // 找到字符出现的最远边界
            if (i == right) {
                result.push_back(right - left + 1);
                left = i + 1;
            }
        }
        return result;
    }
};
```

## 56. 合并区间

以数组 `intervals `表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]`。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

```php
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

按照**左边界**排序，排序之后局部最优：每次合并都取最大的右边界，这样就可以合并更多的区间了，整体最优：合并所有重叠的区间。按照左边界从小到大排序之后，如果 `intervals[i][0] < intervals[i - 1][1]` 即`intervals[i]左边界 < intervals[i - 1]右边界`，则一定有重复。

知道如何判断重复之后，剩下的就是合并了，如何去模拟合并区间呢？其实就是用合并区间后左边界和右边界，作为一个新的区间，加入到`result`数组里就可以了，如果没有合并就把原区间加入到`result`数组。

```php
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> result;
        if (intervals.size() == 0) return result;
        sort(intervals.begin(), intervals.end());
        result.push_back(intervals[0]);
        for (int i = 1; i < intervals.size(); i++) {
            if (result.back()[1] >= intervals[i][0]) { // 合并区间
                result.back()[1] = max(result.back()[1], intervals[i][1]);
            } else {
                result.push_back(intervals[i]);
            }
        }
        return result;
    }
};
```

## 738. 单调递增的数字

当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是单调递增的。给定一个整数 `n` ，返回 小于或等于 `n` 的最大数字，且数字呈单调递增 。

```php
输入: n = 10
输出: 9
输入: n = 1234
输出: 1234
输入: n = 332
输出: 299
```

局部最优：遇到`strNum[i - 1] > strNum[i]`的情况，让`strNum[i - 1]--`，然后`strNum[i]`定为9，可以保证这两位变成最大单调递增整数。全局最优：得到小于等于`n`的最大单调递增的整数。

从前向后遍历的话，遇到strNum[i - 1] > strNum[i]的情况，让strNum[i - 1]减一，但此时如果strNum[i - 1]减一了，可能又小于strNum[i - 2]。

>  举个例子，数字：332，从前向后遍历的话，那么就变成了329，此时2又小于了第一位的3了，真正的结果应该是299。

所以从前后向遍历会改变已经遍历过的结果！那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -> 329 -> 299。

```php
class Solution {
public:
    int monotoneIncreasingDigits(int N) {
        string strNum = to_string(N);
        // flag用来标记赋值9从哪里开始
        // 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行
        int flag = strNum.size();
        for (int i = strNum.size() - 1; i > 0; i--) {
            if (strNum[i - 1] > strNum[i] ) {
                flag = i;
                strNum[i - 1]--;
            }
        }
        for (int i = flag; i < strNum.size(); i++) {
            strNum[i] = '9';
        }
        return stoi(strNum);
    }
};
```






# 设计数据结构

## 二叉堆实现优先级队列

二叉堆（Binary Heap）没什么神秘，性质比二叉搜索树 BST 还简单。其主要操作就两个，`sink`（下沉）和 `swim`（上浮），用以维护二叉堆的性质。其主要应用有两个，首先是一种排序方法「**堆排序**」，第二是一种很有用的数据结构「**优先级队列**」。

二叉堆在逻辑上其实是一种**特殊的二叉树**（完全二叉树），只不过**存储在数组里**。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针：

```php
// 父节点的索引
int parent(int root) {
    return root / 2;
}
// 左孩子的索引
int left(int root) {
    return root * 2;
}
// 右孩子的索引
int right(int root) {
    return root * 2 + 1;
}
```

比如 `arr` 是一个字符数组，注意数组的第一个索引 0 空着不用：

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301605385.png" alt="image-20220430160517323" style="zoom:60%;" /></div>

因为这棵二叉树是「**完全二叉树**」，所以把 `arr[1]` 作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。

二叉堆还分为**最大堆**和**最小堆**。**最大堆的性质是：每个节点都大于等于它的两个子节点**。类似的，**最小堆的性质是：每个节点都小于等于它的子节点**。

对于一个最大堆，根据其性质，显然堆顶，也就是 `arr[1]` 一定是所有元素中最大的元素。

**优先级队列**这种数据结构有一个很有用的功能，**插入或者删除元素的时候，元素会自动排序**，底层的原理就是**二叉堆**的操作。

数据结构的功能无非增删查改，优先级队列有两个主要 API，分别是 `insert` 插入一个元素和 `delMax` 删除最大元素（如果底层用最小堆，那么就是 `delMin`）。

有关上浮、下沉以及插入删除操作的具体实现详见：[二叉堆详解实现优先级队列 :: labuladong的算法小抄](https://labuladong.github.io/algo/2/21/63/)

# 补充

## 468. 验证IP地址

给定一个字符串 `queryIP`。如果是有效的 IPv4 地址，返回 "IPv4" ；如果是有效的 IPv6 地址，返回 "IPv6" ；如果不是上述类型的 IP 地址，返回 "Neither" 。

有效的IPv4地址 是 “`x1.x2.x3.x4`” 形式的IP地址。 其中 0 <= xi <= 255 且 xi 不能包含 前导零。例如: “192.168.1.1” 、 “192.168.1.0” 为有效IPv4地址， “192.168.01.1” 为无效IPv4地址; “192.168.1.00” 、 “192.168@1.1” 为无效IPv4地址。

一个有效的IPv6地址 是一个格式为“x1:x2:x3:x4:x5:x6:x7:x8” 的IP地址，其中: 1 <= xi.length <= 4；xi 是一个 十六进制字符串 ，可以包含数字、小写英文字母( 'a' 到 'f' )和大写英文字母( 'A' 到 'F' )；在 xi 中允许前导零。

**示例：**

```php
输入：queryIP = "172.16.254.1"
输出："IPv4"
解释：有效的 IPv4 地址，返回 "IPv4"
```







## 7. 整数反转

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）。

```php
输入：x = 123
输出：321
```





## 42. 接雨水

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。说明：你不能倾斜容器。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206161625752.jpeg" alt="img" style="zoom:80%;" /></div>

```php
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```











## 11. 盛最多水的容器

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。说明：你不能倾斜容器。

<div align=center><img src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206161627294.jpeg" alt="img" style="zoom:80%;" /></div>

```php
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```







## 14. 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 `""`。

```php
输入：strs = ["flower","flow","flight"]
输出："fl"
```



## 16. 最接近的三数之和

给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和，假定每组输入只存在恰好一个解。

```php
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```



## 31. 下一个排列

整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。

例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。给你一个整数数组 nums ，找出 nums 的下一个排列。必须 原地 修改，只允许使用额外常数空间。

```php
输入：nums = [1,2,3]
输出：[1,3,2]
```





## 33. 搜索旋转排序数组

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

```php
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```



## 38. 外观数列

给定一个正整数 n ，输出外观数列的第 n 项。「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。你可以将其视作是由递归公式定义的数字字符串序列：

countAndSay(1) = "1"，countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。前五项如下：

```php
1.     1
2.     11
3.     21
4.     1211
5.     111221
       第一项是数字 1 
       描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
       描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
       描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
       描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"
```

```php
输入：n = 1
输出："1"
```







## 49. 字母异位词分组

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

```php
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```







## 50. Pow(x, n)

实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，x^n ）。

```php
输入：x = 2.00000, n = 10
输出：1024.00000
```



## 66. 加一

给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。你可以假设除了整数 0 之外，这个整数不会以零开头。

```php
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```



## 75. 颜色分类

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。必须在不使用库的sort函数的情况下解决这个问题。

```php
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```





## 79. 单词搜索





## 212. 单词搜索 II







## 91. 解码方法





## 118. 杨辉三角

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行，在「杨辉三角」中，每个数是它左上方和右上方的数的和。

```php
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```





## 119. 杨辉三角 II



## 146. LRU 缓存



## 155. 最小栈



## 152. 乘积最大子数组



## 162. 寻找峰值



## 169. 多数元素



## 229. 多数元素 II





## 171. Excel 表列序号

给你一个字符串 `columnTitle` ，表示 Excel 表格中的列名称。返回 *该列名称对应的列序号* 。

```php
A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
```

```php
输入: columnTitle = "A"
输出: 1
```



## 172. 阶乘后的零



## 793. 阶乘函数后 K 个零



## 179. 最大数





## 187. 重复的DNA序列



## 217. 存在重复元素



## 219. 存在重复元素 II



## 220. 存在重复元素 III



## 221. 最大正方形



## 225. 用队列实现栈



## 232. 用栈实现队列





## 224. 基本计算器



## 227. 基本计算器 II



## 238. 除自身以外数组的乘积



## 74. 搜索二维矩阵



## 240. 搜索二维矩阵 II



## 242. 有效的字母异位词



## 258. 各位相加



## 剑指 Offer 53 - II. 0～n-1中缺失的数字



## 287. 寻找重复数



## 292. Nim 游戏



## 313. 超级丑数



## 326. 3 的幂



## 334. 递增的三元子序列





## 338. 比特位计数



## 347. 前 K 个高频元素



## 349. 两个数组的交集



## 371. 两整数之和



## 378. 有序矩阵中第 K 小的元素



## 394. 字符串解码



## 402. 移掉 K 位数字



## 409. 最长回文串



## 412. Fizz Buzz



## 415. 字符串相加





## 448. 找到所有数组中消失的数字



## 461. 汉明距离



## 476. 数字的补数



## 560. 和为 K 的子数组



## 581. 最短无序连续子数组



## 717. 1 比特与 2 比特字符



## 728. 自除数



## 739. 每日温度



## 767. 重构字符串



## 771. 宝石与石头



## 剑指 Offer 03. 数组中重复的数字



## 剑指 Offer 04. 二维数组中的查找



## 剑指 Offer 10- II. 青蛙跳台阶问题



## 剑指 Offer 11. 旋转数组的最小数字



## 剑指 Offer 14- I. 剪绳子



## 剑指 Offer 14- II. 剪绳子 II



## 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面



## 剑指 Offer II 003. 前 n 个数字二进制中 1 的个数



## 剑指 Offer 16. 数值的整数次方



## 剑指 Offer 40. 最小的k个数



## 剑指 Offer 30. 包含min函数的栈



## 剑指 Offer 31. 栈的压入、弹出序列



## 剑指 Offer 39. 数组中出现次数超过一半的数字



## 剑指 Offer 50. 第一个只出现一次的字符



## 剑指 Offer 56 - I. 数组中数字出现的次数



## 剑指 Offer 57. 和为s的两个数字



## 剑指 Offer 45. 把数组排成最小的数



## 剑指 Offer 57 - II. 和为s的连续正数序列



## 剑指 Offer 47. 礼物的最大价值



## 剑指 Offer 58 - I. 翻转单词顺序



## 剑指 Offer 53 - I. 在排序数组中查找数字 I



## 263. 丑数



## 264. 丑数 II



## 剑指 Offer 65. 不用加减乘除做加法



## 剑指 Offer 59 - I. 滑动窗口的最大值



## 剑指 Offer 66. 构建乘积数组



## 剑指 Offer 61. 扑克牌中的顺子



## 剑指 Offer 64. 求1+2+…+n




































# 参考资料

[labuladong 的算法小抄 :: labuladong的算法小抄](https://labuladong.github.io/algo/)

[代码随想录 (programmercarl.com)](https://programmercarl.com/)

[题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台 (leetcode-cn.com)](https://leetcode-cn.com/problemset/all/)













