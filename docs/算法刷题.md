# 🔥算法刷题

# 一、二叉树

## 解题方法

1️⃣ 遇到二叉树的题目，如何去思考？或者说有没有思考的框架呢？

- **是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

- **是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「**分解问题**」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

2️⃣ 如何正确地理解**前中后序遍历**呢？

**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：

- 前序位置的代码在刚刚进入一个二叉树节点的时候执行；
- 后序位置的代码在将要离开一个二叉树节点的时候执行；
- 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204170940278.png" alt="image-20220417094016966" style="zoom:50%;" /></div>

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204170942506.png" alt="image-20220417094235414" style="zoom:60%;" /></div>

3️⃣前序位置和后序位置的代码有什么区别？后序位置有什么特殊之处？

前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到**子树**通过函数返回值传递回来的数据。

🔥总结：二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，**你只需要单独思考每一个节点应该做什么**，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

## 二叉树深度

### 104、求二叉树最大深度

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数，叶子节点是指没有子节点的节点。

**示例：** 
给定二叉树`[3,9,20,null,null,15,7]`，

```php
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3。

**解法一**：递归遍历二叉树，回溯算法思路

遍历一遍二叉树，用一个外部变量记录**每个节点**所在的深度，取最大值就可以得到最大深度。

```php
class Solution {
public:
    int depth = 0;
    int res = 0;
    int maxDepth(TreeNode* root) {
        traverse(root);
        return res;
    }
    //遍历二叉树
    void traverse(TreeNode* root){
		if(root == nullptr){
            return;
        }
        //前序遍历位置
        depth++;
        //遍历过程中记录最大深度
        res = max(depth, res);
        traverse(root->left);
        traverse(root->right);
        //后序遍历位置
        depth--;
    }
};
```

**解法二**：分解成子树问题，动态规划思路

```php
class Solution {
public:
    // 定义：输入一个节点，返回以该节点为根的二叉树的最大深度
    int maxDepth(TreeNode* root) {
		if(root == nullptr){
            return 0;
        }
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        // 根据左右子树的最大深度推出原二叉树的最大深度
        return max(leftDepth, rightDepth) + 1;
    }
};
```

**解法三**：层序遍历

```php
class Solution {
public:
    int maxDepth(TreeNode* root) {
		int depth = 0;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth++;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

求二叉树的最大深度可以延伸到求二叉树的直径：

### 543、二叉树直径

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**
给定二叉树

```php
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

每一条二叉树的「**直径**」长度，就是一个节点的左右子树的**最大深度之和**。把计算「直径」的逻辑放在**后序位置**，准确说应该是放在 `maxDepth` 的后序位置，因为 `maxDepth` 的后序位置是知道左右子树的最大深度的。

```php
class Solution {
public:
    int maxDiameter = 0;
    int diameterOfBinaryTree(TreeNode* root) {
		maxDepth(root);
        return maxDiameter;       
    }
    
    //定义：输入一个节点，返回以该节点为根节点的二叉树的深度
    int maxDepth(TreeNode* root){
		if(root == nullptr){
            return 0;
        }
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        // 后序位置，顺便计算最大直径
        maxDiameter = max(leftDepth + rightDepth, maxDiameter);
        return max(leftDepth, rightDepth) + 1;
    }
};
```

### 111、二叉树的最小深度

给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**示例**：给定二叉树`[3，9，20，null，null，15，7]`：

```php
      3
     / \
    9  20
       / \     
      15  7    
```

返回它的最小深度2。

**解法一**：分解成子树问题，动态规划思想

```php
class Solution {
public:
    //定义：输入一个节点，返回以该节点为根节点的二叉树的最小深度
    int minDepth(TreeNode* root) {
		if(!root) {
            return 0;
        }
        int leftDepth = minDepth(root->left);
        int rightDepth = minDepth(root->right);
        return min(leftDepth, rightDepth) + 1;        
    }    
};
```

❓**上面的算法对吗？为什么？**

❎错误！这个代码就犯了此图中的误区：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171128504.png" alt="111.二叉树的最小深度" style="zoom:50%;" /></div>

如果这么求的话，**没有左孩子的分支会算为最短深度**。

所以，如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度；

反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度；

最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。

✅**正确的解法一**：分解成子树问题，动态规划思想

```php
class Solution {
public:
    int minDepth(TreeNode* root) {
		if(!root){
            return 0;
        }
        int leftDepth = minDepth(root->left);
        int rightDepth = minDepth(root->right);
        if(!root->left){
            return rightDepth + 1;
        }
        if(!root->right){
            return leftDepth + 1;
        }
        return min(leftDepth, rightDepth) + 1;
    }
};
```

**解法二**：层序遍历

```php
class Solution {
public:
    int minDepth(TreeNode* root) {
		int depth = 0;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth++;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(!node->left && !node->right) return depth;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

### 110、平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

**示例 ：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202031331.jpeg" alt="img" style="zoom: 60%;" /></div>

```php
输入：root = [3,9,20,null,null,15,7]
输出：true
```

本题依然是二叉树深度相关的题目，依然是把计算「高度差」的逻辑放在**后序位置**，准确说应该是放在 `maxDepth` 的后序位置，因为 `maxDepth` 的后序位置是知道左右子树的最大深度的。

只计算一次最大深度，计算的过程中在**后序遍历位置**顺便判断二叉树是否平衡：对于每个节点，先算出来左右子树的最大高度，然后在后序遍历的位置根据左右子树的最大高度判断平衡性。

```php
class Solution {
public:
    // 记录二叉树是否平衡
    bool balance = true;

    bool isBalanced(TreeNode* root) {
        maxDepth(root);
        return balance;
    }
	// 定义：输入一个节点，返回以该节点为根的二叉树的最大深度
    int maxDepth(TreeNode* root){
        if(!root) return 0;
        int leftDepth= maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        if(abs(leftDepth - rightDepth) > 1) balance = false;
        return max(leftDepth, rightDepth) + 1;
    }
};
```

## 翻转二叉树

**226、翻转二叉树**

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171844420.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**解法一**：递归遍历，回溯算法的思想

遍历二叉树的每个节点，每个节点的左、右子树交换位置。

```php
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
		traverse(root);
        return root;
    }
    // 二叉树遍历函数
    void traverse(TreeNode* root){
        if(!root){
            return;
        }
        // 每一个节点需要做的事就是交换它的左右子节点
        TreeNode* tmp = root->left;
        root->left = root->right;
        root->right = tmp;
        // 遍历框架，去遍历左右子树的节点
        traverse(root->left);
        traverse(root->right);
    }
};
```

**解法二**：分解为子树的问题，动态规划思想

用 `invertTree(x.left)` 先把 `x` 的左子树翻转，再用 `invertTree(x.right)` 把 `x` 的右子树翻转，最后把 `x` 的左右子树交换，这恰好完成了以 `x` 为根的整棵二叉树的翻转，即完成了 `invertTree(x)` 的定义。

```php
class Solution {
public:
    //定义：输入一个节点，将以该节点为根节点的二叉树进行翻转，返回其根节点
    TreeNode* invertTree(TreeNode* root) {
		if(!root) {
            return root;
        }
        // 利用函数定义，先翻转左右子树
        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);
        // 然后交换左右子节点
		root->left = right;
        root->right = left;
        return root;
    }    
};
```

**解法三**：层序遍历

```php
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();              // 中
            st.pop();
            swap(node->left, node->right);
            if(node->right) st.push(node->right);   // 右
            if(node->left) st.push(node->left);     // 左
        }
        return root;
    }
};
```

## 路径总和

### 112、路径总和

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221122861.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**解法一**：递归遍历，回溯算法思想

前部遍历位置（进入节点）`sum += root->val`，顺便判断是否到达叶子节点且和为`targetSum`；后序遍历位置（离开节点）`sum -= root->val`。

```php
class Solution {
public:
    bool res = false;
    int sum = 0;
    bool hasPathSum(TreeNode* root, int targetSum) {
        traverse(root, targetSum);
        return res;
    }

    void traverse(TreeNode* root, int targetSum){
        if(!root) return;
        //前序遍历位置
        sum += root->val;
        // 到达叶子节点且和为targetSum
        if(!root->left && !root->right && sum == targetSum) res = true;
        traverse(root->left, targetSum);
        traverse(root->right, targetSum);
        //后序遍历位置
        sum -= root->val;
    }
};
```

**解法二**：分解成子树问题，动态规划思想

遍历到一个节点，继续遍历左孩子和右孩子，且targetSum减去节点的数值。

```php
class Solution {
    
public:
    // 定义：输入一个根节点，返回该根节点到叶子节点是否存在一条和为 targetSum 的路径
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return false;
        if(!root->left && !root->right && root->val == targetSum) return true;
        // 左子树或者右子树有一个满足即可
        return hasPathSum(root->left, targetSum - root->val) ||
                hasPathSum(root->right, targetSum - root->val);
    }
};
```

### 113、路径总和ii

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221122861.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
```

相对于⌈**112、路径总和**⌋来说，前序和后序位置不仅要维护`sum`，还要维护路径`path`。

```php
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    int sum = 0;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        traverse(root, targetSum);
        return res;
    }

    void traverse(TreeNode* root, int targetSum){
        if(!root) return;
        //前序遍历位置
        sum += root->val;
        path.push_back(root->val);
        if(!root->left && !root->right && sum == targetSum) res.push_back(path);
        traverse(root->left, targetSum);
        traverse(root->right, targetSum);
        //后序遍历位置
        sum -= root->val;
        path.pop_back();
    }
};
```

### 437、路径总和iii

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221609909.jpeg" alt="img" style="zoom: 50%;" /></div>

```php
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示
```

这题及要求你准确理解二叉树的前序后序遍历，还要熟悉前缀和技巧，把前缀和技巧用到二叉树上。

这道题涉及到数组的技巧，暂定先不做。





## 二叉树是否对称/相等

**101、对称二叉树**和**100、相同的树**结合起来看，两道题方法和代码上非常相似。

### 100、相同的树

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201830207.jpeg" alt="img" style="zoom:60%;" /></div>

```php
输入：p = [1,2,3], q = [1,2,3]
输出：true
```

解法一：分解成子树问题

```php
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p || !q) return p == q;
        if(p->val != q->val) return false;
        bool left = isSameTree(p->left, q->left);	//比较左子树
        bool right = isSameTree(p->right, q->right);//比较右子树
        return left && right;
    }
};
```

代码简化为：

```php
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // 判断一对节点是否相同
        if(!p || !q) return p == q;
        if(p->val != q->val) return false;
        // 判断其他节点是否相同
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

**解法二**：迭代法

```php
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        queue<TreeNode*> que;
        que.push(p);
        que.push(q);
        //注意不能加上写成如下代码，否则会报错
        //if(p) que.push(p);   
        //if(q) que.push(q);  
        while (!que.empty()) {  // 接下来就要判断这两颗树是否相等
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是相等的
                continue;
            }
            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   
            que.push(rightNode->left); 
            que.push(leftNode->right);  
            que.push(rightNode->right); 
        }
        return true;
    }
};
```

**注意**：

```php
que.push(p);
que.push(q);
```

不能写为：

```
if(p) que.push(p);   
if(q) que.push(q);  
```

否则会报错：

```php
执行出错信息：
Line 15: Char 74: runtime error: member access within misaligned address 0xbebebebebebebebe for type 'TreeNode', which requires 8 byte alignment (solution.cpp)
0xbebebebebebebebe: note: pointer points here
<memory cannot be printed>
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:74
最后执行的输入：
[]
[0]
```

加上`if`判断后，若输入当中有为空的，则无法加入到队列当中，影响后序的代码逻辑运行。

### 101、对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251941296.png" alt="101. 对称二叉树" style="zoom:55%;" /></div>

**解法一**：分解成子树问题

对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了**其实我们要比较的是两颗树（这两颗树是根节点的左右子树）**，所以在递归遍历的过程中，也是要同时遍历两棵树。

正是因为要遍历两棵树而且要**比较内侧和外侧节点**，所以准确的来说是一个树的遍历顺序是**左右中**，一个树的遍历顺序是**右左中**，只有内侧和外侧节点分别对应相等，这两棵树才是对称的。

**返回条件**：

- 左节点为空，右节点不为空，不对称，return false；
- 左不为空，右为空，不对称 return false；
- 左右都为空，对称，返回true；
- 左右都不为空，比较节点数值，不相同就return false；
- 左右节点相等的话，再递归判断子节点；

代码如下：

```
if (left == NULL && right != NULL) return false;
else if (left != NULL && right == NULL) return false;
else if (left == NULL && right == NULL) return true;
else if (left->val != right->val) return false;
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return compare(root->left, root->right);
    }
    //定义：输入左、右节点，返回分别以这两节点为根节点的二叉树是否对称
    bool compare(TreeNode* left, TreeNode* right){
        // 注意这里终止条件的代码
        if(!left || !right) return left == right;
        if(left->val != right->val) return false;
        bool outside = compare(left->left, right->right);   //外侧节点比较
        bool inside = compare(left->right, right->left);    //内侧节点比较
        return outside && inside;   //左右子节点需要对称相同
    }
};
```

代码简化为：

```
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return compare(root->left, root->right);
    }
    //定义：输入左、右节点，返回分别以这两节点为根节点的二叉树是否对称
    bool compare(TreeNode* left, TreeNode* right){
        // 该对节点是否对称
        if(!left || !right) return left == right;
        if(left->val != right->val) return false;
        // 其他节点是否对称
        return compare(left->left, right->right) && compare(left->right, right->left);
    }
};
```

**解法二**：迭代法，不是层序遍历，这里我们可以使用**队列**来比较两个树（根节点的左右子树）是否相互翻转。

把左右两个子树要比较的元素顺序放进一个容器，然后**成对**的取出来进行比较，那么其实使用**栈**也是可以的。

```
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        
        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }
            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```

### 572、另一个树的子树

给你两棵二叉树 `root` 和 `subRoot` ，检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。

二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点，`tree` 也可以看做它自身的一棵子树。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201953856.jpeg" alt="img" style="zoom:50%;" /></div>

```
输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
```

遍历以 `root` 为根的这棵二叉树的所有节点，用 ⌈**100、相同的树**⌋ 中的 `isSameTree` 函数判断以该节点为根的子树是否和以 `subRoot` 为根的那棵树相同。

```php
class Solution {
public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
		if(!root) return root == subRoot;
        // 判断以 root 为根的二叉树是否和 subRoot 相同
        if(isSameTree(root, subRoot)) return true;
        // 去左右子树中判断是否有和 subRoot 相同的子树
        return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);
    }
    // 定义：输入两个节点，判断以两个节点为根节点的二叉树是否一样，返回结果
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // 判断一对节点是否相同
        if(!p || !q) return p == q;
        if(p->val != q->val) return false;
        // 判断其他节点是否相同
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

## 左叶子/左下角问题

### 404、左叶子之和

给定二叉树的根节点 `root` ，返回所有左叶子之和。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202035803.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

**首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。**

本题遍历二叉树即可，问题是如何判断节点是**左叶子**呢？

**如果左节点不为空，且左节点没有左右孩子，那么这个节点的左节点就是左叶子**，必须要通过节点的父节点来判断其左孩子是不是左叶子：

```php
if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) {
    左叶子节点处理逻辑
}
```

```php
class Solution {
public:
    int sum = 0;
    
    int sumOfLeftLeaves(TreeNode* root) {
        traverse(root);
        return sum;
    }
    
    void traverse(TreeNode* root){
        if(!root) return;
        // 找到左侧的叶子节点，记录累加值
        if(root->left && !root->left->left && !root->left->right){
            sum += root->left->val;
        }
        traverse(root->left);
        traverse(root->right);
    }
};
```

### 513、找树左下角的值

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204212053339.jpeg" alt="img" style="zoom:60%;" /></div>

```
输入: root = [2,1,3]
输出: 1
```

**解法一**：递归遍历二叉树

二叉树递归框架代码是先递归左子树，后递归右子树，所以**到最大深度时第一次遇到的节点就是左下角的节点**。

```php
class Solution {
public:
    int depth;		// 记录 traverse 递归遍历到的深度
    int maxDepth;	// 记录二叉树的最大深度
    TreeNode* res;

    int findBottomLeftValue(TreeNode* root) {
        traverse(root);
        return res->val;
    }

    void traverse(TreeNode* root){
        if(!root) return;
        depth++;
        // 到最大深度时第一次遇到的节点就是左下角的节点
        if(depth > maxDepth){
            maxDepth = depth;
            res = root;
        }
        traverse(root->left);
        traverse(root->right);
        depth--;
    }
};
```

**解法二**：层序遍历，很好理解

```php
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        int result = 0;	//后续循环会不断刷新result的值
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (i == 0) result = node->val; // 记录最后一行第一个元素
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

找树左下角的值会做了，找树右下角的值自然也会做了，也就是把遍历的顺序改变一下：先遍历右子树，再遍历左子树。



## 完全二叉树

### [BM35 判断是不是完全二叉树](https://www.nowcoder.com/practice/8daa4dff9e36409abba2adbe413d6fae?tpId=295&tqId=2299105&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

给定一个二叉树，确定他是否是一个**完全二叉树**。

**完全二叉树**的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）

样例图1：叶子节点出现在最后一层

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205012041648.png" alt="img" style="zoom:80%;" /></div>

样例图2：叶子节点出现在最后一次和倒数第二层

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205012050113.png" alt="img" style="zoom:60%;" /></div>

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。

本道题的解题关键就是要紧紧抓住**完全二叉树的定义**，使用**层序遍历**。如果遇到某个节点为空，进行标记，代表访问到完全二叉树的最下层，若是后续还有访问，则不符合完全二叉树的定义。

注意：

```php
que.push(node->left);
que.push(node->right);
```

不能写成：

```php
if(node->left) push(node->left);
if(node->right) que.push(node->right);
```

否则， 完全二叉树最后一层的空节点是访问不到的。


```php
class Solution {
  public:
    bool isCompleteTree(TreeNode* root) {
        //空树一定是完全二叉树
        if(root == NULL)  return true;
        queue<TreeNode*> que;
        if(root) que.push(root); 
        //定义一个首次出现的标记位
        bool flag = false; 
        while(!que.empty()){ 
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                //标记第一次遇到空节点
                if (!node) 
                    flag = true; 
                else{
                    //后续访问已经遇到空节点了，说明经过了叶子
                    if (flag) return false;
                    que.push(node->left);
                    que.push(node->right);
                }
            }
        }
        return true;
    }
};
```

### 222、完全二叉树的节点个数

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202028146.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,3,4,5,6]
输出：6
```

首先要搞清楚什么是 ⌈**完全二叉树**⌋ 和 ⌈**满二叉树**⌋ ：

**完全二叉树**如下图，每一层都是紧凑靠左排列的，除了最底层节点可能没填满外，其余每层节点数都达到最大值：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211628453.png" alt="img" style="zoom:50%;" /></div>

**满二叉树**如下图，是一种特殊的完全二叉树，每层都是是满的，像一个稳定的三角形：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211629053.png" alt="img" style="zoom:80%;" /></div>

如果是一个**普通**二叉树，显然只要向下面这样遍历一边即可，时间复杂度 O(N)：

```php
int countNodes(TreeNode* root) {
    if (root == null) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}
```

那如果是一棵**满**二叉树，节点总数就和树的高度呈指数关系：

```php
int countNodes(TreeNode* root) {
    int h = 0;
    // 计算树的高度
    while (root != null) {
        root = root->left;
        h++;
    }
    // 节点总数就是 2^h - 1
    return (2 << h) - 1;
}
```

**完全**二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版。

完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。

对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。

对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211649576.png" alt="image-20220421164919517" style="zoom:60%;" /></div>

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211652510.png" alt="image-20220421165226452" style="zoom:40%;" /></div>

可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。

```php
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (!root) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        // 这里初始为0是有目的的，为了下面求指数方便
        int leftHeight = 0;
        int rightHeight = 0; 
        // 记录左、右子树的高度
        while (left) {
            left = left->left;
            leftHeight++;
        }
        while (right) {
            right = right->right;
            rightHeight++;
        }
        // 如果左右子树的高度相同，则是一棵满二叉树
        if (leftHeight == rightHeight) {
            return (2 << leftHeight) - 1; // 注意(2<<1) 相当于2^2，所以leftHeight初始为0
        }
        // 如果左右高度不同，则按照普通二叉树的逻辑计算
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

这个算法的时间复杂度是 `O(logN*logN)`，但直觉感觉好像最坏情况下是 O(N*logN) ，因为之前的 while 需要 logN 的时间，最后要 O(N) 的时间向左右子树递归：

```php
return 1 + countNodes(root.left) + countNodes(root.right);
```

**关键点在于，这两个递归只有一个会真的递归下去，另一个一定会触发 `leftHeight == rightHeight` 而立即返回，不会递归下去**。

所以，算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logN*logN)。

## 二叉树展开为链表

**114、二叉树展开为链表**

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 前序遍历 顺序相同。

**示例 ：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171905704.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**解法一**：递归遍历

对整棵树进行前序遍历，一边遍历一边构造出一条「链表」。

```php
class Solution {
public:
    // 虚拟头节点，res->right 就是结果
    TreeNode* res = new TreeNode(-1);
    // 用来构建链表的指针
    TreeNode* p = res;
    TreeNode* flatten(TreeNode* root) {
        traverse(root);
        return res->right;
    }
    
    void traverse(TreeNode* root){
		if(!root) return;
        p = new TreeNode(root->val);
        p = p->right;
        traverse(root->left);
        traverse(root->right);
    }
};
```

但是注意 `flatten` 函数的签名，返回类型为 `void`，也就是说题目希望我们在原地把二叉树拉平成链表。

这样一来，没办法通过简单的二叉树遍历来解决这道题了。

**解法二**：分解成子树的问题

对于一个节点 `x`，可以执行以下流程：

1、先利用 `flatten(x.left)` 和 `flatten(x.right)` 将 `x` 的左右子树拉平。

2、将 `x` 的右子树接到左子树下方，然后将整个左子树作为右子树。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171948600.png" alt="image-20220417194832538" style="zoom:50%;" /></div>

这样，以 `x` 为根的整棵二叉树就被拉平了，恰好完成了 `flatten(x)` 的定义。

```php
class Solution {
public:
    //定义：输入一个节点，将以该节点为根节点的二叉树展开成单链表
    void flatten(TreeNode* root) {
		if(!root) return;
        // 利用定义，把左右子树拉平
        flatten(root->left);
        flatten(root->right);
        // 1、左右子树已经被拉平成一条链表
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        // 2、将左子树作为右子树
        root->left =  nullptr;
        root->right = left;
        // 3、将原先的右子树接到当前右子树的末端
        TreeNode* p = root;
        // 注意这里的条件是 p->right，而不是 p ，即有右孩子则移动指针
        while(p->right){
            p = p->right;
        }
        p->right = right;
    }
};
```

## 填充每个节点的下一个右侧节点指针

**116、填充每个节点的下一个右侧节点指针**

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```php
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171958858.png" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
```

这道题若使用**常规的**遍历二叉树的话，只能将一个节点的左子树指向右子树，**不同节点的子树之间无法建立联系**，所以要改变遍历的方式。传统的 `traverse` 函数是遍历二叉树的所有节点，但现在我们想遍历的其实是两个相邻节点之间的「**空隙**」，所以可以在二叉树的基础上进行抽象，把图中的每一个方框看做一个节点：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204172004189.png" alt="img" style="zoom:30%;" /></div>

**解法一**：递归遍历二叉树

**这样，一棵二叉树被抽象成了一棵三叉树，三叉树上的每个节点就是原先二叉树的两个相邻节点**。

现在，我们只要实现一个 `traverse` 函数来遍历这棵三叉树，每个「三叉树节点」需要做的事就是把自己内部的两个二叉树节点穿起来。这样，`traverse` 函数遍历整棵「三叉树」，将所有相邻节的二叉树节点都连接起来，也就避免了我们之前出现的问题，把这道题完美解决。

```php
class Solution {
public:
    Node* connect(Node* root) {
        if(!root) return root;
        traverse(root->left, root->right);
        return root;
    }
    // 三叉树遍历框架
    void traverse(Node* node1, Node* node2){
        if(!node1 || !node2){
            return;
        }
        node1->next = node2;
        traverse(node1->left, node1->right);
        traverse(node2->left, node2->right);
        traverse(node1->right, node2->left);
    }
};
```

**解法二**：层序遍历

在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204182056966.png" alt="填充每个节点的下一个右侧节点指针.drawio.png" style="zoom:70%;" /></div>

核心代码逻辑为：

- 遍历到每一层的第一个节点时，用pre记录该节点，然后节点出队，node记录pre；

- 向后每遍历一个节点，用node记录该节点，然后节点出队，**pre指向node**，pre指针向后移动一位；

- 该层最后一个节点指向nullptr；

```php
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if (root != NULL) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            Node* pre;
            Node* node;
            for (int i = 0; i < size; i++) {
                if (i == 0) {
                    pre = que.front(); // 取出一层的头结点
                    que.pop();
                    node = pre;
                } else {
                    node = que.front();
                    que.pop();
                    pre->next = node; // 本层前一个节点next指向本节点
                    pre = pre->next;
                }
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            pre->next = NULL; // 本层最后一个节点指向NULL
        }
        return root;
    }
};
```

二刷：

```php
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            Node* pre;
            for(int i = 0; i < size; i++){
                Node* node = que.front();
                que.pop();
                if(i == 0){
                    pre = node;
                }else{
                    pre->next = node;
                    pre = node;
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            pre->next = NULL;
        }
        return root;
    }
};
```

## 二叉树序列化

### 297. 二叉树的序列化与反序列化

**序列化**是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205012111971.jpeg" alt="img" style="zoom:40%;" /></div>

```php
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

使用**拼接字符串**的方式把二叉树**序列化**。

```php
class Codec {
public:

    // 序列化
    string serialize(TreeNode* root) {
        if(!root) return "#";
        return to_string(root->val) + " " + serialize(root->left) + " " + serialize(root->right);
    }

     TreeNode* build(istringstream& iss){
        string tmp;
        iss>>tmp;
        if(tmp == "#") return NULL;
        TreeNode* root = new TreeNode(stoi(tmp));
        root->left = build(iss);
        root->right = build(iss);
        return root;
    }
    // 反序列化
    TreeNode* deserialize(string data) {
        istringstream iss(data);
        return build(iss);
    }
};
```

### 652、寻找重复的子树

给定一棵二叉树 root，返回所有重复的子树。

对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。

如果两棵树具有相同的结构和相同的结点值，则它们是重复的。

**示例**：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204172024286.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,3,4,null,2,4,null,null,4]
输出：[[2,4],[4]]
```

如何知道以某个节点为根的子树是不是重复的，是否应该加入结果列表中，需要知道什么信息呢？

**你需要知道以下两点**：

1、以我为根的这棵二叉树（子树）长啥样？——**后序遍历**

2、以其他节点为根的子树都长啥样？——利用哈希表存起来做比较

现在，明确了要用后序遍历，那应该怎么描述一棵二叉树的模样呢？二叉树的前序/中序/后序遍历结果可以描述二叉树的结构。所以，可以通过**拼接字符串**的方式把二叉树**序列化**。

```php
class Solution {
public:
    unordered_map<string, int> map;
    vector<TreeNode*> res;
    
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
		traverse(root);
        return res;
    }
    //定义：输入一个节点，将以该节点为根节点的二叉树序列化，返回序列化后的字符串
    string traverse(TreeNode* root){
		if(!root) return "#";
        string left = traverse(root->left);
        string right = traverse(root->right);
        // 后序位置获取二叉树序列化后的字符串
        string str = left + "," + right + "," + to_string(root->val);
        if(map[str] == 1){
            res.push_back(root);
        }
        map[str]++;
        return str;
    }
};
```

## 构造二叉树

😶‍🌫️二叉树的构造问题一般都是使用「**分解问题**」的思路：**构造整棵树 = 根节点 + 构造左子树 + 构造右子树**。

### 617、合并二叉树

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221505893.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
```

```php
class Solution {
public:
    //定义：输入两二叉树根节点，返回二叉树处理后的根节点
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(!root1) return root2;
        if(!root2) return root1;
        root1->val += root2->val; 
        root1->left = mergeTrees(root1->left, root2->left);
        root1->right = mergeTrees(root1->right, root2->right);
        return root1;
    }
};
```

### 654、构造最大二叉树

给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 `nums` 构建的**最大二叉树**。

**示例**：

```php
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
               6
             /  \
            3    5
             \   /      
              2 0   
               \
                1
```

首先遍历数组把找到最大值 `maxVal`，从而把根节点 `root` 构造出来，然后对 `maxVal` 左边的数组和右边的数组进行递归构建，作为 `root` 的左、右子树。

```php
//定义二叉树
struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x):val(x), left(nullptr), right(nullptr){}
}

class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
		return build(nums, 0, nums.size() - 1);
    }
    
    //定义：输入数组和区间左右端点，返回构造的最大二叉树的根节点
    TreeNode* build(vector<int>& nums, int lo, int hi){
        if(lo > hi){
            return nullptr;
        }
        // 找到数组中的最大值和对应的索引
        // 注意不能写成 int rootVal = 0;
        int rootVal = INT32_MIN;
        int index = 0;
        for(int i = lo; i <= hi; i++){
			if(rootVal < nums[i]){
                rootVal = nums[i];
                index = i;
            }
        }
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(nums, lo, index - 1);
        root->right = build(nums, index + 1, hi);
        return root;
    }
};
```

### 105、从前序与中序遍历序列构造二叉树

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

```php
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171505952.jpeg" alt="img" style="zoom: 67%;" /></div>

前序遍历`preorder` 和 中序遍历`inorder` 数组中的元素分布有如下特点：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171510562.png" alt="image-20220417151011413" style="zoom:80%;" /></div>

找到根节点是很简单的，前序遍历的第一个值 `preorder[0]` 就是根节点的值。关键在于如何通过根节点的值，将 `preorder` 和 `postorder` 数组划分成两半，构造根节点的左右子树？

**暴力**方法是利用for循环遍历整个数组找出`index`，但是通过 for 循环遍历的方式去确定 `index` 效率不算高，可以进一步优化：采用**哈利表**的查到 `rootVal` 对应的 `index`，数组元素无序且不重复，故采用 `unordered_map`来实现，底层由**哈希表**实现。

本道题的一大**难点**在于如何确定左右数组对应的起始索引和终止索引，这个可以通过左子树的节点数推导出来，假设左子树的节点数为 `leftSize`，那么 `preorder` 数组上的索引情况是这样的：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171511724.png" alt="image-20220417151152530" style="zoom:60%;" /></div>

做这种题目一定要画示意图，选择闭区间，若索引填错了，就会引起栈溢出的错误。

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
		int size = inorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[inorder[i]] = i;
        }
        return build(preorder, 0, size - 1, inorder, 0, size - 1);
    }
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd, 
                    vector<int>& inorder, int inStart, int inEnd){
    	if(preStart > preEnd){
            return nullptr;
        }
        //根节点的值，注意不能写成 int rootVal = preorder[0];
        int rootVal = preorder[preStart];
        //利用哈希表查询到 rootVal 在 inorder 中的索引 index
        int index = map[rootVal];
        
        int leftSize = index - inStart;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(preorder, preStart + 1, preStart + leftSize, 
                          inorder, inStart, index - 1);
    	root->right = build(preorder, preStart + leftSize + 1, preEnd,
                           inorder, index + 1, inEnd);
    	return root;
    }
};
```

### 106、从中序与后序遍历序列构造二叉树

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。

```php
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
```

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171505952.jpeg" alt="img" style="zoom: 67%;" /></div>

 `postoder` 和 `inorder` 对应的状态如下：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171615448.png" alt="image-20220417161545340" style="zoom:60%;" /></div>

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
		int size = inorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[inorder[i]] = i;
        }
        return build(inorder, 0, size - 1, postorder, 0, size - 1);
    }
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& inorder, int inStart, int inEnd, 
                    vector<int>& postorder, int postStart, int postEnd){
    	if(postStart > postEnd){
            return nullptr;
        }
        //根节点的值
        int rootVal = postorder[postEnd];
        //利用哈希表查询到 rootVal 在 inorder 中的索引 index
        int index = map[rootVal];
        
        int leftSize = index - inStart;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(inorder, inStart, index - 1, 
                          postorder, postStart, postStart + leftSize - 1);
    	root->right = build(inorder, index + 1, inEnd,
                           postorder, postStart + leftSize, postEnd - 1);
    	return root;
    }
};
```

### 889、根据前序和后序遍历构造二叉树

给定两个整数数组，`preorder` 和 `postorder` ，其中 `preorder` 是一个具有 **无重复** 值的二叉树的前序遍历，`postorder` 是同一棵树的后序遍历，重构并返回二叉树。

如果存在多个答案，您可以返回其中 **任何** 一个。

```php
输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
输出：[1,2,3,4,5,6,7]
```

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171628354.jpeg" alt="img" style="zoom:60%;" /></div>

这道题和前两道题有一个本质的区别：

**通过前序中序，或者后序中序遍历结果可以确定一棵原始二叉树，但是通过前序后序遍历结果无法确定原始二叉树**。这道题，你可以确定根节点，但是无法确切的知道左右子树有哪些节点，以下是一种构造方法：

1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值。

2、然后把前序遍历结果的第二个元素作为左子树的根节点的值。

3、在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可。

假设前序遍历的第二个元素是左子树的根节点，但实际上左子树有可能是空指针，那么这个元素就应该是右子树的根节点。由于这里无法确切进行判断，所以导致了最终答案的不唯一。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171639321.png" alt="image-20220417163947215" style="zoom:70%;" /></div>

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {
		int size = postorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[postorder[i]] = i;
        }
        return build(preorder, 0, size - 1, postorder, 0, size - 1);
    }
    
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd, 
                    vector<int>& postorder, int postStart, int postEnd){
    	if(postStart > postEnd){
            return nullptr;
        }
        if(postStart == postEnd){
            return new TreeNode(postorder[postStart]);
        }
        //根节点的值
        int rootVal = preorder[preStart];
        int leftRootVal = preorder[preStart + 1];
        //利用哈希表查询到左子树根节点 leftRoot 在 postorder 中的索引 index
        int index = map[leftRootVal];
        
        int leftSize = index - postStart + 1;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(preorder, preStart + 1, preStart + leftSize, 
                          postorder, postStart, index);
    	root->right = build(preorder, preStart + leftSize + 1, preEnd,
                           postorder, index + 1, postEnd - 1);
    	return root;
    }
};
```



## 层序遍历

### 102、二叉树的层序遍历

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181828285.png" alt="102.二叉树的层序遍历" style="zoom:50%;" /></div>

需要借用一个辅助数据结构即**队列**来实现，队列**先进先出**，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。

while循环用来从上到下遍历二叉树的每一层，for循环用来从左到右遍历每一层当中的节点。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181834096.png" alt="image-20220418183400018" style="zoom:50%;" /></div>

```php
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

### 107、二叉树的层次遍历II

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181838870.png" alt="107.二叉树的层次遍历II" style="zoom:55%;" /></div>

相对于102.二叉树的层序遍历，就是最后把`result`数组反转一下就可以了。

```php
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        reverse(result.begin(), result.end()); // 在这里反转一下数组即可
        return result;
    }
};
```

### 103、 二叉树的锯齿形层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 

**示例：**

<img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251142392.jpeg" alt="img" style="zoom:60%;" />

```php
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
```

这题和 ⌈[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal)⌋ 类似，只是要控制遍历方向，另外使用**双向队列**`deque`来记录遍历路径`path。

**解法一**：使用数组的**深度奇偶变化**来控制遍历顺序

```php
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        if(root) que.push(root);
        int depth = 0;
        while(!que.empty()){
            int size = que.size();
            // 双向队列记录遍历路径
            deque<int> path;
            depth++;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                // 深度为奇数则从左到右
                if(depth % 2 != 0) path.push_back(node->val);
                // 深度为偶数则从右到左
                else path.push_front(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(vector<int>{path.begin(), path.end()});
        }
        return res;
    }
};
```

**解法二**：用一个**布尔变量** `flag` 控制遍历方向

```php
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        bool flag = true;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            // 双向队列记录遍历路径
            deque<int> path;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                // flag为true则从左到右
                if(flag == true) path.push_back(node->val);
                // flag为
                else path.push_front(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            flag = !flag;
            res.push_back(vector<int>{path.begin(), path.end()});
        }
        return res;
    }
};
```

### 515、在每个树行中找最大值

给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204190917513.png" alt="515.在每个树行中找最大值" style="zoom:60%;" /></div>

**解法一**：递归遍历二叉树

我们先来思考这样一个问题：如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？

`traverse`遍历函数的参数当中只包含`TreeNode* root `可以吗？**不行！**还要加上节点所在的层数`level`，因为在递归遍历的过程中，遍历左子树接着遍历右子树，层数leve并不是一直增加，同一层的节点level是一样的，所以不能定义全局变量，而是要放在`traverse`函数参数当中维护。

**如果要在遍历二叉树的过程中获取每个节点所在的层数，则要在`traverse`遍历函数的参数当中添加层数`level`。**

```php
// 定义：二叉树遍历函数，输入一个节点和该节点所在的层数
void traverse(TreeNode root, int level) {
    if (root == null) {
        return;
    }
    // 前序位置
    printf("节点 %s 在第 %d 层", root, level);
    //注意如下代码中的 level + 1
    traverse(root.left, level + 1);
    traverse(root.right, level + 1);
}

// 人为设定根节点位于第1层
traverse(root, 1);
```

回到本题当中，本质上是一个求节点最大值的问题，但问题是**如何保证参与比大小求最值的节点来自于同一层呢**？

🥳在遍历二叉树的过程中获取每一个节点所在的层数，比较层数就可以了呀，也就是说**这是一个涉及二叉树层数的问题，要在`traverse`遍历函数的参数当中添加层数`level`。**

假设二叉树的层数从第0层开始算，res数组所以默认从0开始：

- 假设数组遍历到二叉树第2层某节点，而res数组当中只有**2**个元素（已获取前两层的最大值），即`level == res.size()`，表示res数组当中无该层任何节点，**将该节点添加到res数组中**；

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191022409.png" alt="image-20220419102205366" style="zoom:60%;" /></div>

- 假设数组遍历到二叉树第2层某节点，而res数组当中只有**3**个元素（已获取前三层的最大值），表示该层已经有节点被访问了，则**比大小取最值**；

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191022406.png" alt="image-20220419102248364" style="zoom:60%;" /></div>

所以也就是说，核心代码逻辑要使用`if`语句分以上两种情况讨论。

版本一：

```php
class Solution {
public:
	vector<int> res;
    void traverse(TreeNode* root,int level){
        if(root == NULL){
            return;
        }
        if(level == res.size()){//每层第一个节点
            res.push_back(root->val);
        } else{					//每层第一个节点之外的节点
            res[level] = max(res[level], root->val);
        } 
        traverse(root->left, level + 1);
        traverse(root->right, level + 1);
    }
    vector<int> largestValues(TreeNode* root) {
        //二叉树层数从第0层开始算
        traverse(root,0);
        return res;
    }
};
```

版本二：

```php
class Solution {
public:
    vector<int> res;
    int depth = 0;
    vector<int> largestValues(TreeNode* root) {
        traverse(root);
        return res;
    }

    void traverse(TreeNode* root){
        if(!root) return;
        if(depth == res.size()) res.push_back(root->val);
        else{
            res[depth] = max(res[depth], root->val);
        }
        depth++;
        traverse(root->left);
        traverse(root->right);
        depth--;
    }
};
```

**注意**：这个版本的代码会把根节点当成第一层，但是本题是要将根节点当作第0层，所以主要代码逻辑要写在`depth++;`前面，或者初始化`int depth = -1`。

**解法二**：层序遍历

层序遍历，取每一层的最大值。

- while循环开始遍历每一层时，创建最大值`maxValue`；
- for循环遍历该层每一个节点，顺便更新`maxValue`；
- 退出for循环，该层所有节点遍历完成，`maxValue`放入结果数据`result`中；

```php
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<int> result;
        while (!que.empty()) {
            int size = que.size();
            int maxValue = INT_MIN; // 取每一层的最大值
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                maxValue = node->val > maxValue ? node->val : maxValue;
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(maxValue); // 把最大值放进数组
        }
        return result;
    }
};
```

### 199、二叉树的右视图

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191815468.png" alt="199.二叉树的右视图" style="zoom:55%;" /></div>

**解法一**：递归遍历

要找到每一层最右边的节点，涉及**二叉树节点所在层数**的问题，还是使用 ⌈**515、在每个树行中找最大值**⌋ 中的遍历框架。

**注意**：由于本题是要找每层最右侧节点，所以**先遍历右子树再遍历左子树**，这样每层遍历时首先访问到的就是要求的节点。

```php
class Solution {
public:
    vector<int> res;

    vector<int> rightSideView(TreeNode* root) {
        traverse(root, 0);
        return res;
    }

    void traverse(TreeNode* root, int level){
        if(!root) return;
		//这一层还没有记录值，说明 root 就是右侧视图的第一个节点
        if(res.size() == level){
            res.push_back(root->val);
        }
		// 注意，这里反过来，先遍历右子树再遍历左子树
        // 这样，首先遍历的一定是右侧节点
        traverse(root->right, level + 1);
        traverse(root->left, level + 1);
    }
};
```

那如果是要求二叉树的**左视图**呢，那就**先遍历左子树再遍历右子树**呗，又AC了一题😜。

**解法二**：层序遍历

```php
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
		queue<TreeNode*> que;
        vector<int> res;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(i == (size - 1)){
                    res.push_back(node->val);
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return res;
    }
};
```

### 637、二叉树的层平均值

给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。

**示例 ：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201555469.jpeg" alt="img" style="zoom:60%;" /></div>

```php
输入：root = [3,9,20,null,null,15,7]
输出：[3.00000,14.50000,11.00000]
```

层序遍历轻松完成，**注意**：先求一层所有节点的和，最后再作除法。


```php
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> res;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            // 记录当前层所有节点之和
            double sum = 0;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                sum += node->val;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            // 记录当前行的平均值
            res.push_back(sum / size);
        }
        return res;
    }
};
```



## 二叉树的所有路径

**257、二叉树的所有路径**

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202033263.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

遍历二叉树，这道题和 ⌈**515、在每个树行中找最大值**⌋ 在思路上很相似——回溯，遍历函数 `traverse `的参数中还需要加入路径 `path`。再说的通俗一点儿就是，左右子树都需要对路径`path`进行操作，所以左子树操作完需要**回溯**，右子树才能再操作，不然右子树操作的就是左子树操作完的结果。

```php
class Solution {
public:
    // 记录所有从根节点到叶子节点的路径
    vector<string> res;
	string path;
    vector<string> binaryTreePaths(TreeNode* root) {
        // 记录 traverse 函数递归时的路径
        traverse(root, path);
        return res;
    }
    
    void traverse(TreeNode* root, string path){
        if(!root) return;
        path += to_string(root->val);
        //遍历到叶子节点，路径path加入res数组
        if(!root->left && !root->right){
            res.push_back(path);
        }
        traverse(root->left, path + "->");
        traverse(root->right, path + "->");
    }
};
```

## 最近公共祖先

何为最近公共祖先呢？

**如果一个节点能够在它的左右子树中分别找到`p`和`q`，则该节点为`LCA`节点**。

先来实现一个简单的算法：输入一棵**没有重复元素**的二叉树根节点`root`和目标值`val1`，`val2`，写一个函数寻找树中值为`val1`**或**`val2`的节点。

```php
//定义：在以 root 为根的二叉树中寻找值为 val1 或 val2 的节点
TreeNode* find(TreeNode* root, int val1, int val2){
    if(!root) return nullptr;
    // 前序位置，在每一个节点处判断
    if(root->val == val1 || root->val == val2) return root;
    //左右子树寻找
    TreeNode* left = find(root->left, val1, val2);
    TreeNode* right = find(root->right, val1, val2);
    // 后序位置，已经知道左右子树是否存在目标值
	return left != nullptr ? left : right;
}
```

**最近公共祖先系列问题的解法都是把这个函数作为框架的**。

### 236、二叉树的最近公共祖先

给你输入一棵**不含重复值**的二叉树，以及**存在于树中的**两个节点`p`和`q`，请你计算`p`和`q`的最近公共祖先节点。

最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241139188.jpg" alt="640" style="zoom:40%;" /></div>

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241140957.jpg" alt="640 (1)" style="zoom:40%;" /></div>

在`find`函数的后序位置，如果发现`left`和`right`都非空，就说明当前节点是`LCA`节点，即解决了第一种情况；

在`find`函数的前序位置，如果找到一个值为`val1`或`val2`的节点则直接返回，恰好解决了第二种情况。

```php
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return find(root, p->val, q->val);
    }
    // 在二叉树中寻找 val1 和 val2 的最近公共祖先节点
    TreeNode* find(TreeNode* root, int val1, int val2){
        if(!root) return nullptr;
        // 前序位置，在每一个节点处判断，遇到目标值立即返回
        if(root->val == val1 || root->val == val2) return root;
        //左右子树寻找
        TreeNode* left = find(root->left, val1, val2);
        TreeNode* right = find(root->right, val1, val2);
        // 后序位置，已经知道左右子树是否存在目标值
        if(left && right) return root;
        return left != nullptr ? left : right;
    }
};
```

因为题目说了`p`和`q`一定存在于二叉树中(这点很重要），所以即便我们遇到`q`就直接返回，根本没遍历到`p`，也依然可以断定`p`在`q`底下，`q`就是`LCA`节点。

### 1676、二叉树的最近公共祖先 IV

给定一棵[二叉树](https://so.csdn.net/so/search?q=二叉树&spm=1001.2101.3001.7020)的根节点 `root `和 TreeNode 类对象的数组（列表） `nodes`，返回 `nodes `中所有节点的最近公共祖先（LCA）。数组（列表）中所有节点都**存在于该二叉树中**，且二叉树中所有节点的值都是互不相同的。

**示例 3:**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241156790.png" alt="在这里插入图片描述" style="zoom:100%;" /></div>

```php
输入: root = [3,5,1,6,2,0,8,null,null,7,4], nodes = [7,6,2,4]
输出: 5
解释: 节点 7、6、2 和 4 的最近公共祖先节点是 5。
```

依然给你输入一棵不含重复值的二叉树，但这次不是给你输入`p`和`q`两个节点了，而是给你输入一个包含若干节点的列表`nodes`（这些节点都存在于二叉树中），其实换汤不换药，还是使用这个框架。

为了高效地查找数组`nodes`中的元素，使用**哈希表**来装载数组元素，`unordered_set` 来实现。

```php
class Solution {
public:
	unordered_set<int> set; 
    TreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*> &nodes) {
    	for(TreeNode* node: nodes){
            set.insert(node->val);
        }
        return find(root);
    }
    
    // 在二叉树中寻找 val 的最近公共祖先节点
    TreeNode* find(TreeNode* root){
        if(!root) return nullptr;
        // 前序位置，在每一个节点处判断，遇到目标值立即返回
        if(set.count(root->val)) return root;
        //左右子树寻找
        TreeNode* left = find(root->left);
        TreeNode* right = find(root->right);
        // 后序位置，已经知道左右子树是否存在目标值
        if(left && right) return root;
        return left != nullptr ? left : right;
    }
};
```

不过需要注意的是，这两道题的题目都明确告诉我们**这些节点必定存在于二叉树中**，如果没有这个前提条件，就需要修改代码了。

### 1644、二叉树的最近公共祖先 II

给定一棵二叉树的根节点 root，返回给定节点 p 和 q 的最近公共祖先（LCA）节点。如果 p 或 q 之一**不存在于该二叉树中**，返回 null。树中的每个节点值都是互不相同的。

在解决标准的最近公共祖先问题时，我们在`find`函数的前序位置有这样一段代码：

```php
// 前序位置
if (root.val == val1 || root.val == val2) {
    // 如果遇到目标值，直接返回
    return root;
}
```

因为`p`和`q`都存在于树中，所以这段代码恰好可以解决最近公共祖先的第二种情况：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241140957.jpg" alt="640 (1)" style="zoom:40%;" /></div>

但对于这道题来说，`p`和`q`不一定存在于树中，所以不能遇到一个目标值就直接返回，而应该对二叉树进行**完全搜索**（遍历每一个节点），如果发现`p`或`q`不存在于树中，那么是不存在`LCA`的。

哪种写法能够对二叉树进行完全搜索呢？只需要**把前序位置的判断逻辑放到后序位置**即可：

```php
TreeNode find(TreeNode root, int val) {
    if (root == null) {
        return null;
    }
    // 先去左右子树寻找
    TreeNode left = find(root.left, val);
    TreeNode right = find(root.right, val);
    // 后序位置，判断 root 是不是目标节点
    if (root.val == val) {
        return root;
    }
    // root 不是目标节点，再去看看哪边的子树找到了
    return left != null ? left : right;
}
```

同时还要使用`bool`变量记录一下`p` 和 `q `是否存在于二叉树中，若有一个不存在，则返回NULL；若两者都存在，则找到了`LCA`。

```php
class Solution{
    // 用于记录 p 和 q 是否存在于二叉树中
    bool findP = false;
    bool findQ = false;
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
		if(!findP || !findQ) return nullptr;
        // p 和 q 都存在二叉树中，才有公共祖先
        return find(root, p->val, q->val);
	}
	
	// 在二叉树中寻找 val1 和 val2 的最近公共祖先节点
	TreeNode* find(TreeNode* root, int val1, int val2){
        if(!root) return nullptr;
        TreeNode* left = find(root->left, val1, val2);
        TreeNode* right = find(root->right, val1, val2);
		// 后序位置，判断当前节点是不是 LCA 节点
        if(left && right) return root;
        // 后序位置，判断当前节点是不是目标值
        if(root->val == val1 || root->val == val2){
            if(root->val == val1) findP = true;
            if(root->val == val2) findQ = true;
            return root;
        }
        return left != nullptr ? left : right;
    }
};
```

### 235、二叉搜索树的最近公共祖先

输入一棵不含重复值的**二叉搜索树**，以及**存在于树中**的两个节点`p`和`q`，请计算`p`和`q`的最近公共祖先节点。

把之前的解法代码复制过来肯定也可以解决这道题，但没有用到 BST「**左小右大**」的性质，显然效率不是最高的。

在标准的最近公共祖先问题中，我们要在**后序位置**通过左右子树的搜索结果来判断当前节点是不是`LCA`：

```php
TreeNode left = find(root.left, val1, val2);
TreeNode right = find(root.right, val1, val2);

// 后序位置，判断当前节点是不是 LCA 节点
if (left != null && right != null) {
    return root;
}
```

但对于 BST 来说，根本不需要老老实实去遍历子树，由于 BST 左小右大的性质，**将当前节点的值与`val1`和`val2`作对比**，即可判断当前节点是不是`LCA`：

- 假设`val1 < val2`，那么`val1 <= root->val <= val2`，则说明当前节点就是`LCA`；

- 若`root->val`比`val1`还小，则需要去值更大的右子树寻找`LCA`；

- 若`root->val`比`val2`还大，则需要去值更小的左子树寻找`LCA`。

```php
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 保证 val1 较小，val2 较大
        int val1 = min(p->val, q->val);
        int val2 = max(p->val, q->val);
        return find(root, val1, val2);
    }
    // 在 BST 中寻找 val1 和 val2 的最近公共祖先节点
	TreeNode* find(TreeNode* root, int val1, int val2){
        if(!root) return nullptr;
        // 当前节点太大，去左子树找
        if(root->val > val2) return find(root->left, val1, val2);
        // 当前节点太小，去右子树找
        if(root->val < val1) return find(root->right, val1,val2);
        // val1 <= root.val <= val2
    	// 则当前节点就是最近公共祖先
        return root;
    }
};
```

### 1650、二叉树的最近公共祖先 III

给定一棵二叉树中的两个节点 `p` 和 `q`，返回它们的最近公共祖先节点（LCA）。每个节点都包含其父节点的引用（指针），`Node `的定义如下：

```php
class Node {
    int val;
    Node* left;
    Node* right;
    Node* parent;
};
```

**这道题其实不是公共祖先的问题，而是单链表相交的问题**，你把`parent`指针想象成单链表的`next`指针，题目就变成了：给你输入两个单链表的头结点`p`和`q`，这两个单链表必然会相交，请你返回相交点。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241502457.png" alt="image-20220424150259400" style="zoom:60%;" /></div>

**解法一**：双指针法

```php
class Solution {
public:
    Node* lowestCommonAncestor(Node* p, Node * q) {
		// 链表双指针技巧
    	node* a = p;
        node* b = q;
        while(a != b){
            // a 走一步，如果走到根节点，转到 q 节点
            if(!a) a = q;
            else a = a->parent;
            // b 走一步，如果走到根节点，转到 p 节点
            if(!b) b = p;
            else b = b->parent;
        }
        return a;
    };
```

**解法二**：哈希表

```php
class Solution {
public:
    Node* lowestCommonAncestor(Node* p, Node * q) {
        unordered_set<int> sign;
        // 将节点p的元素存入哈希表
        while(p!=NULL){
            sign.insert(p->val);
            p=p->parent;
        }
        // 节点q的元素在哈希表中查询，第一次出现的即LCA
        while(q!=NULL){
            if(sign.count(q->val)){
                return q;
            }
            q=q->parent;
        }
        return NULL;
    }
};
```

## 二叉搜索树

二叉搜索树（Binary Search Tree，后文简写 BST）有如下特性：

1、对于 BST 的每一个节点 `node`，左子树节点的值都比 `node` 的值要小，右子树节点的值都比 `node` 的值大。

2、对于 BST 的每一个节点 `node`，它的左侧子树和右侧子树都是 BST。

二叉搜索树并不算复杂，它可以算是数据结构领域的半壁江山，直接基于 BST 的数据结构有**AVL 树**，**红黑树**等等，拥有了自平衡性质，可以提供 **logN**级别的增删查改效率；还有 **B+** 树，线段树等结构都是基于 BST 的思想来设计的。

从做算法题的角度来看 BST，除了它的定义，还有一个重要的性质：**BST 的中序遍历结果是有序的（升序）**。

也就是说，如果输入一棵 BST，以下代码可以将 BST 中每个节点的值升序打印出来：

```php
void traverse(TreeNode* root) {
    if (!root) return;
    traverse(root->left);
    // 这里添加中序遍历代码
    traverse(root->right);
}
```

那么根据这个性质，我们来做两道算法题。

BST 相关的问题，要么利用 **BST 左小右大**的特性提升算法效率，要么利用**中序遍历**的特性满足题目的要求。

### 230. 二叉搜索树中第K小的元素

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251501802.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [3,1,4,null,2], k = 1
输出：1
```

最直接的思路就是**升序排序**，然后找第 `k` 个元素，BST 的中序遍历其实就是升序排序的结果。

```php
class Solution {
public:
    // 记录当前元素的排名
    int count = 0;
    int res;
    int kthSmallest(TreeNode* root, int k) {
        // 利用 BST 的中序遍历特性
        traverse(root, k);
        return res;
    }

    void traverse(TreeNode* root, int k){
        if(!root) return;
        traverse(root->left, k);
        /* 中序遍历代码位置 */
        count++;
        // 找到第 k 小的元素
        if(count == k){
            res = root->val;
            return;
        }
        traverse(root->right, k);
    }
};
```

### 538. 把二叉搜索树转换为累加树

给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251517895.png" alt="img" style="zoom:50%;" /></div>

```php
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

 BST 的中序遍历代码可以升序打印节点的值，那降序打印节点的值怎么办呢？

只要把递归顺序改一下就行了：

```php
void traverse(TreeNode* root) {
    if (!root) return;
    traverse(root->right);
    // 这里添加中序遍历代码
    traverse(root->left);
}
```

这段代码可以降序打印 BST 节点的值，如果维护一个外部累加变量 `sum`，然后把 `sum` 赋值给 BST 中的每一个节点，不就将 BST 转化成累加树了吗？

```php
class Solution {
public:
    //记录累加和
    int sum = 0;
    TreeNode* convertBST(TreeNode* root) {
        traverse(root);
        return root;
    }

    void traverse(TreeNode* root){
        if(!root) return;
        traverse(root->right);
        // 维护累加和
        sum += root->val;
        // 将 BST 转化成累加树
        root->val = sum;
        traverse(root->left);
    }
};
```

### 530. 二叉搜索树的最小绝对差

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271647211.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [4,2,6,1,3]
输出：1
```

中序遍历会有序遍历 BST 的节点，遍历过程中计算最小差值即可。因为要做差，所以需要维护一个`pre`指针来记录上一个节点。

```php
class Solution {
public:
    int res = INT_MAX;
    TreeNode* pre = nullptr;
    int getMinimumDifference(TreeNode* root) {
        traverse(root);
        return res;
    }

    void traverse(TreeNode* root){
        if(!root) return;
        traverse(root->left);
        //这里的if(pre)判断条件不能掉
        if(pre) res = min(root->val - pre->val, res);
        pre = root;
        traverse(root->right);
    }
};
```

### 501. 二叉搜索树中的众数

给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有众数（即出现频率最高的元素）。

如果树中有不止一个众数，可以按 **任意顺序** 返回。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271843086.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,null,2,2]
输出：[2]
```

首先，需要统计节点出现的频率，维护一个`pre`指针：

- 若`pre`为空，则为第一个节点；
- 若`pre->val == root->val`，则频率加1；
- 若`pre->val != root->val`，则出现新的节点，频率为1；

然后，与最大频率作比较：

- 若频率等于最大频率，节点加入数组；
- 若频率大于最大频率，则更新最大数值，清空数组后加入该节点；

```php
class Solution {
public:
    int count = 0;
    int maxCount = 0;
    TreeNode* pre = nullptr;
    vector<int> res;

    vector<int> findMode(TreeNode* root) {
        traverse(root);
        return res;
    }

    void traverse(TreeNode* root){
        if(!root) return;
        traverse(root->left);
        // 统计root节点出现的频率
        if(!pre) count = 1;						//第一个节点
        else if(pre->val == root->val) count++;	//与前一个节点值相等
        else count = 1;							//与前一个节点值不等
        pre = root;
        
        // 和最大频率作比较，判断是否加入数组
        if(count == maxCount) res.push_back(root->val);
        else if(count > maxCount){
            maxCount = count;
            res.clear();
            res.push_back(root->val);
        }
        traverse(root->right);
    }
};
```

### 剑指 Offer 36. 二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

以下面的二叉搜索树为例：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301207350.png" alt="img" style="zoom:40%;" /></div>

我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。

![img](https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png)

特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。

1. **排序链表：** 节点应从小到大排序，因此应使用 **中序遍历** “从小到大”访问树的节点。
2. **双向链表：** 在构建相邻节点的引用关系时，设前驱节点 `pre` 和当前节点 `cur` ，不仅应构建 `pre->right = cur` ，也应构建 `cur->left = pre` 。
3. **循环链表：** 设链表头节点 `head` 和尾节点 `tail` ，则应构建 `head->left = tail` 和 `tail->right = head` 。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301210130.png" alt="Picture1.png" style="zoom:50%;" /></div>

```php
class Solution {
public:
    Node* head = NULL;
    Node* pre = NULL;
    Node* treeToDoublyList(Node* root) {
        if(!root) return head;
        traverse(root);
        head->left = pre;
        pre->right = head;
        return head;
    }

    void traverse(Node* root){
        if(!root) return;
        traverse(root->left);
        if(pre){
            pre->right = root;
            root->left = pre;
        }else{
            head = root;
        }
        pre = root;
        traverse(root->right);
    }
};
```



------

BST 的完整定义如下：

1、BST 中任意一个节点的左子树所有节点的值都小于该节点的值，右子树所有节点的值都大于该节点的值。

2、BST 中任意一个节点的左右子树都是 BST。

有了 BST 的这种特性，就可以在二叉树中做类似**二分搜索**的操作，搜索一个元素的效率很高。

比如下面这就是一棵合法的二叉树：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251601659.png" alt="img" style="zoom:18%;" /></div>

对于 BST 相关的问题，经常会看到类似下面这样的代码逻辑：

```php
void BST(TreeNode* root, int target) {
    if (root->val == target)
        // 找到目标，做点什么
    if (root->val < target) 
        BST(root->right, target);
    if (root->val > target)
        BST(root->left, target);
}
```

这个代码框架其实和二叉树的遍历框架差不多，无非就是利用了 BST **左小右大**的特性而已。

### 98. 验证二叉搜索树

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251606314.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [2,1,3]
输出：true
```

**解法一**：中序遍历，需要比较节点和上一个节点的大小关系，所以引入指针`pre`。

```php
class Solution {
public:
    TreeNode* pre = nullptr; //记录前一个节点
    bool isValidBST(TreeNode* root) {
        // 二叉搜索树也可以为空
        if(!root) return true;
        bool left = isValidBST(root->left);
        if(pre && pre->val >= root->val) return false;
        pre = root;
        bool right = isValidBST(root->right);
        return left && right;
    }
};
```

**解法二**：二叉树定义，左小右大

这里有一个陷阱：BST 不是左小右大么，那我只要检查 `root->val > root->left->val` 且 `root->val < root->right->val` 不就行了？

这样是**错误**的，因为 BST**左小右大**的特性是指 `root->val` 要比左子树的所有节点都更大，要比右子树的所有节点都小，只检查左右两个子节点当然是不够的。

**正确解法**是通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉搜索树算法的一个小技巧吧。

```php
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return valid(root, nullptr, nullptr);
    }

    bool valid(TreeNode* root, TreeNode* min, TreeNode* max){
        if(!root) return true;
        if(min && root->val <= min->val) return false;
        if(max && root->val >= max->val) return false;
        return valid(root->left, min, root) && valid(root->right, root, max);
    }
};
```

### 669. 修剪二叉搜索树

给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271918176.jpeg" alt="img" style="zoom:40%;" /></div>

```php
输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]
```

明确了递归函数的定义之后进行思考，如果一个节点的值没有落在 `[lo, hi]` 中，有两种情况：

1、`root.val < lo`，这种情况下 `root` 节点本身和 `root` 的左子树全都是小于 `lo` 的，都需要被剪掉，返回`root` 的右子树；

2、`root.val > hi`，这种情况下 `root` 节点本身和 `root` 的右子树全都是大于 `hi` 的，都需要被剪掉， 返回`root` 的左子树；

```php
class Solution {
public:
    // 定义：删除 BST 中小于 low 和大于 high 的所有节点，返回结果 BST
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if(!root) return root;
        // 直接返回 root.right，等于删除 root 以及 root 的左子树
        if(root->val < low) return trimBST(root->right, low,high);
        // 直接返回 root.left，等于删除 root 以及 root 的右子树
        if(root->val > high) return trimBST(root->left, low, high);
        // 闭区间 [lo, hi] 内的节点什么都不做
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
};
```

### 700. 二叉搜索树中的搜索

给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204270954033.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [4,2,7,1,3], val = 2
输出：[2,1,3]
```

解法一：二叉树定义，左小右大

```php
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root) return root;
        //比目标值大，到左子树寻找
        if(root->val > val) return searchBST(root->left, val);
        //比目标值小，到右子树找
        if(root->val < val) return searchBST(root->right, val);
        //等于目标值，返回节点
        return root;
    }
};
```

解法二：中序遍历

```php
class Solution {
public:
    TreeNode* res;
    TreeNode* searchBST(TreeNode* root, int val) {
        traverse(root, val);
        return res;
    }

    void traverse(TreeNode* root, int val){
        if(!root) return;
        traverse(root->left, val);
        if(root->val == val){
            res = root;
            return;
        }
        traverse(root->right, val);
    }
};
```

### 701. 二叉搜索树中的插入操作

给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树，返回插入后二叉搜索树的根节点。 输入数据 **保证**新值和原始二叉搜索树中的任意节点值都不同。

**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271015149.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
```

如果要递归地插入或者删除二叉树节点，递归函数一定要有返回值，而且返回值要被正确的接收。

插入的过程可以分两部分：

1、寻找正确的插入位置，类似 [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree)。

2、把元素插进去，这就要把新节点以返回值的方式接到父节点上。

```php
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        // 找到空位置插入新节点
        if(!root) return new TreeNode(val);
        if(root->val > val) root->left = insertIntoBST(root->left, val);
        if(root->val < val) root->right = insertIntoBST(root->right, val);
        return root;
    }
};
```

### 450. 删除二叉搜索树中的节点

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变，返回二叉搜索树（有可能被更新）的根节点的引用。

跟插入操作类似，先「找」再「改」，先把框架写出来：

```php
TreeNode* deleteNode(TreeNode* root, int key) {
    if (root->val == key) {
        // 找到啦，进行删除
    } else if (root->val > key) {
        // 去左子树找
        root->left = deleteNode(root->left, key);
    } else if (root.val < key) {
        // 去右子树找
        root->right = deleteNode(root->right, key);
    }
    return root;
}
```

删除比插入和搜索都要复杂一些，分三种情况：

**情况 1**：`A` 恰好是末端节点，两个子节点都为空，那么直接删除：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271044120.png" alt="img" style="zoom:25%;" /></div>

```php
if (root->left == null && root->right == null)
    return null;
```

**情况 2**：`A` 只有一个非空子节点，那么它要让这个孩子接替自己的位置。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271044561.png" alt="img" style="zoom:48%;" /></div>

```php
// 排除了情况 1 之后
if (root->left == null) return root->right;
if (root->right == null) return root->left;
```

**情况 3**：`A` 有两个子节点，麻烦了，为了不破坏 BST 的性质，`A` 必须找到**左子树中最大的那个节点**，或者**右子树中最小的那个节点**来接替自己，下列为第二种方式。

![img](https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271046754.png)

```php
if (root->left != null && root->right != null) {
    // 找到右子树的最小节点
    TreeNode* minNode = getMin(root->right);
    // 把 root 改成 minNode
    root->val = minNode->val;
    // 转而去删除 minNode
    root->right = deleteNode(root->right, minNode->val);
}
```

三种情况分析完毕，填入框架，简化一下代码：

```php
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(!root) return root;
        if(root->val == key){
        	// 这两个 if 把情况 1 和 2 都正确处理了
            if(!root->left) return root->right;
            if(!root->right) return root->left;
        	// 处理情况 3
        	// 获得右子树最小的节点
            TreeNode* minNode = getMin(root->right);
            // 删除右子树最小的节点
            root->right = deleteNode(root->right, minNode->val);
            // 用右子树最小的节点替换 root 节点
            minNode->left = root->left;
            minNode->right = root->right;
            root = minNode;
        }else if(root->val > key){
            root->left = deleteNode(root->left, key);
        }else if(root->val < key){
            root->right = deleteNode(root->right, key);
        }
        return root;
    }

    TreeNode* getMin(TreeNode* root){
        // BST 最左边的就是最小的
        while(root->left) root = root->left;
        return root;
    }
};
```

### 96. 不同的二叉搜索树

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271115456.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：n = 3
输出：5
```

所以如果固定`3`作为根节点，左子树节点就是`{1,2}`的组合，右子树就是`{4,5}`的组合。

**左子树的组合数和右子树的组合数乘积**就是`3`作为根节点时的 BST 个数。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271138633.png" alt="image-20220427113801523" style="zoom:50%;" /></div>

那么 `{1,2}` 和 `{4,5}` 的组合有多少种呢？只要合理定义递归函数，这些可以交给递归函数去做。

```php
class Solution {
public:
    int numTrees(int n) {
        // 计算闭区间 [1, n] 组成的 BST 个数
        return count(1, n);
    }
	//定义：计算闭区间 [lo, hi] 组成的 BST 个数 
    int count(int lo, int hi){
        if(lo > hi) return 1;
        int res = 0;
        for(int i = lo; i <= hi; i++){
            // i 的值作为根节点 root
            int left = count(lo, i - 1);
            int right = count(i + 1, hi);
            // 左右子树的组合数乘积是 BST 的总数
            res += left * right;
        }
        return res;
    }
};
```

另外，这题存在**重叠**子问题，可以通过**备忘录**的方式消除冗余计算，动态规划思想。

（以下为java代码，暂时不知道如何去转化成cpp代码）

```php
// 备忘录
int[][] memo;

int numTrees(int n) {
    // 备忘录的值初始化为 0
    memo = new int[n + 1][n + 1];
    return count(1, n);
}

int count(int lo, int hi) {
    if (lo > hi) return 1;
    // 查备忘录
    if (memo[lo][hi] != 0) {
        return memo[lo][hi];
    }

    int res = 0;
    for (int mid = lo; mid <= hi; mid++) {
        int left = count(lo, mid - 1);
        int right = count(mid + 1, hi);
        res += left * right;
    }
    // 将结果存入备忘录
    memo[lo][hi] = res;

    return res;
}
```

### 95. 不同的二叉搜索树 II

给你一个整数 `n` ，请你生成并返回所有由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的不同 **二叉搜索树** ，可以按 **任意顺序** 返回答案。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271559371.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：n = 3
输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
```

想要构造出所有合法 BST，分以下三步：

1、穷举 `root` 节点的所有可能；

2、递归构造出左右子树的所有合法 BST；

3、给 `root` 节点穷举所有左右子树的组合。

```php
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        if(n == 0) return {};
        return build(1, n);
    }
    //定义：构造闭区间 [lo, hi] 组成的 BST
    vector<TreeNode*> build(int lo, int hi){
        vector<TreeNode*> res;
        if(lo > hi){
            res.push_back(nullptr);
            return res;
        }
        //1、穷举root节点所有可能
        for(int i = lo; i <= hi; i++){
            // 2、递归构造出左右子树的所有合法 BST
            vector<TreeNode*> leftTree = build(lo, i - 1);
            vector<TreeNode*> rightTree = build(i + 1, hi);
            // 3、给 root 节点穷举所有左右子树的组合
            for(TreeNode* left: leftTree){
                for(TreeNode* right: rightTree){
                    // i 作为根节点 root 的值
                    TreeNode* root = new TreeNode(i);
                    root->left = left;
                    root->right = right;
                    res.push_back(root);
                }
            }
        }
        return res;
    }
};
```

### 108. 将有序数组转换为二叉搜索树

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271942183.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
```

二叉树的构建问题很简单，说白了就是：构造根节点，然后构建左右子树。

一个有序数组对于 BST 来说就是**中序遍历**结果，根节点在数组中心，数组左侧是左子树元素，右侧是右子树元素。

```php
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return build(nums, 0, nums.size() - 1);
    }

    TreeNode* build(vector<int>& nums, int left, int right){
        if(left > right) return nullptr;
        int mid = (left + right + 1) / 2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = build(nums, left, mid - 1);
        root->right = build(nums, mid + 1, right);
        return root;
    }
};
```

### 109、有序链表转换二叉搜索树

给定一个单链表的头节点  `head` ，其中的元素 **按升序排序** ，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差不超过 1。

**示例:**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301023724.jpeg" alt="img" style="zoom:40%;" /></div>

```php
输入: head = [-10,-3,0,5,9]
输出: [0,-3,9,-10,null,5]
```

链表和数组相比的一个关键差异是无法通过索引快速访问元素，所以这题有几个思路：

1、把链表转化成数组，然后直接复用 [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree) 的解法。

2、稍微改写 [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree) 的解法，用 [单链表的六大解题套路](https://labuladong.github.io/article/fname.html?fname=链表技巧) 说到的双指针方法获取链表的中点，时间复杂度略高一些。

3、如果深刻理解二叉树算法，可以利用中序遍历的特点写出最优化的解法。

**解法一**：中序遍历，分冶的思想

```php
class Solution {
public:
    TreeNode* buildTree(ListNode* &p, int left, int right) {
        if (left > right) {
            return nullptr;
        }
        int mid = (left + right + 1) / 2;
        TreeNode* leftTree = buildTree(p, left, mid - 1);
        TreeNode* root = new TreeNode(p->val);
        p = p->next;
        TreeNode* rightTree = buildTree(p, mid + 1, right);
        root->left = leftTree;
        root->right = rightTree;
        return root;
    }

    TreeNode* sortedListToBST(ListNode* head) {
        int len = 0;
        for(ListNode* ptr = head; ptr != nullptr; ptr = ptr->next){
            len++;
        }
        return buildTree(head, 0, len - 1);
    }
};
```

**解法二**：**双指针**获取链表的中点

```php
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        return build(head, nullptr);
    }

    // 把链表左闭右开区间 [begin, end) 的节点构造成 BST
    TreeNode* build(ListNode* begin, ListNode* end){
        if(begin == end) return nullptr;
        ListNode* mid = getMid(begin, end);
        TreeNode* root = new TreeNode(mid->val);
        root->left = build(begin, mid);
        root->right = build(mid->next, end);
        return root;
    }

    // 获取链表左闭右开区间 [begin, end) 的中心节点
    ListNode* getMid(ListNode* begin, ListNode* end){
        ListNode* slow = begin;
        ListNode* fast = begin;
        while(fast != end && fast->next != end){
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

### 剑指 Offer 33. 二叉搜索树的后序遍历序列

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

参考以下这颗二叉搜索树：

```
     5
    / \
   2   6
  / \
 1   3
```

**示例：**

```php
输入: [1,6,3,2,5]
输出: false
```

- 利用二叉搜索树**左大右小**的性质划分左右子树：

  遍历后序遍历的`[start, end]`区间的元素，寻找第一个大于根节点的节点，索引记为 `midIndex `。此时，可划分出左子树区间 `[start, midIndex - 1]`，右子树区间` [midIndex, end - 1] `、根节点索引 `end`。

- 判断是否为二叉搜索树：
  左子树区间 `[start, midIndex - 1]`内的所有节点都应 `< postorder[end]` 。而第 1.划分左右子树 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。
  右子树区间 ` [midIndex, end - 1] ` 内的所有节点都应 `> postorder[j]` 。实现方式为遍历，当遇到 `≤postorder[j]`的节点则跳出；则可通过`index == end`判断是否为二叉搜索树。

- 返回值： 

  所有子树都需正确才可判定正确，因此使用 与逻辑符 && 连接。
  

```php
class Solution {
public:
    bool traversal(vector<int>& postorder, int start, int end) {
        /* 递归终止条件 */
        if(start > end) return true;
        int index = start;
        /* 中间处理逻辑 */
        while(postorder[index] < postorder[end]) index++;
        /* 记录分割点 */
       int midIndex = index;
        while(postorder[index] > postorder[end]) index++;
        /* 递归左右子树 */
        bool left = traversal(postorder, start, midIndex - 1);
        bool right = traversal(postorder, midIndex, end - 1);
        return index == end && left && right;
    }

    bool verifyPostorder(vector<int>& postorder) {
        return traversal(postorder, 0, postorder.size() - 1);
    }
};
```



# 二、链表

## 合并链表

### 21、合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301513096.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

用指针分别访问两个链表，根据题意比较节点的大小，赋值到新的链表。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301537463.gif" alt="1" style="zoom:50%;" /></div>

这个算法的逻辑类似于「拉拉链」，`l1, l2` 类似于拉链两侧的锯齿，指针 `p` 就好像拉链的拉索，将两个有序链表合并。合并后 list1 和 list2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可。

**代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 `dummy` 节点**，它相当于是个占位符，可以避免处理空指针的情况，降低代码的复杂性。

```php
struct ListNode{
    int val;
    ListNode* next;
    ListNode(int x): val(x), next(nullptr){}
}

class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        //虚拟头节点
        ListNode* dummy = new ListNode(-1);
        ListNode* p = dummy, *p1 = list1, *p2 = list2;
        while(p1 && p2){
            // 比较 p1 和 p2 两个指针，将值较小的的节点接到 p 指针
            if(p1->val > p2->val){
                p->next = p2;
                p2 = p2->next;
            }else{
                p->next = p1;
                p1 = p1->next;
            }
            p = p->next;
        }
        p->next = !p1 ? p2 : p1;
        return dummy->next;
    }
};
```

### 23、合并 k 个有序链表

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例：**

```php
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

本题是上一道题目[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists) 的延伸，利用 [优先级队列（二叉堆）](https://labuladong.github.io/article/fname.html?fname=二叉堆详解实现优先级队列) 进行节点排序即可。

**具体步骤**

1.  新建虚拟节点`dummy`，指向合并后的链表， 新建一个优先级队列`priority_queue` ；
2.  将所有的链表的第一个元素加入队列；
3.  将队列的第一元素出队列，插入到新链表的尾部；
4.  将第一元素的下一个元素入队，比较剩下的链表的第1个元素和第i个链表的第2个元素；
5.  重复3-4步, 得到新的队列。

```php
class Solution {
public:
    struct Comp{
        //小根堆，从小到大排序
        bool operator()(ListNode* l1,ListNode* l2){
            return l1->val > l2->val;
        }
    }; 
    
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        //优先级队列，最小堆
        priority_queue<ListNode*, vector<ListNode*>, Comp> pq;
        //虚拟节点
		ListNode* dummy = new ListNode(-1);
        ListNode* p = dummy;
        // 将所有的链表的第一个元素加入队列
        for(ListNode* head : lists){
            if(head) pq.push(head);
        }
        while(!pq.empty()){
            // 获取最小节点，接到结果链表中
            ListNode *node = pq.top(); pq.pop();
            p->next = node;
            p = p->next;
            if(node->next) pq.push(node->next);
        }
        return dummy->next;
    }
};
```

这个算法是面试常考题，它的时间复杂度是多少呢？

优先级队列 `pq` 中的元素个数最多是 `k`，所以一次 `poll` 或者 `add` 方法的时间复杂度是 `O(logk)`；所有的链表节点都会被加入和弹出 `pq`，**所以算法整体的时间复杂度是 `O(Nlogk)`，其中 `k` 是链表的条数，`N` 是这些链表的节点总数**。

### 86. 分隔链表

给你一个链表的头节点 `head `和一个特定值 `x` ，请你对链表进行分隔，使得所有小于` x` 的节点都出现在 大于或等于 `x` 的节点之前。

你应当 保留 两个分区中每个节点的初始相对位置。

**示例**：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101321822.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```

只需要遍历链表的所有节点，小于`x`的放到一个小的链表中，大于等于`x`的放到一个大的链表中，最后再把这两个链表串起来即可。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101328225.png" alt="image.png" style="zoom:80%;" /></div>

```php
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode* small = new ListNode(0);
        ListNode* smallHead = small;
        ListNode* large = new ListNode(0);
        ListNode* largeHead = large;
        ListNode* p = head;
        while(p){
            if(p->val < x){
                small->next = p;
                small = small->next;
            }else{
                large->next = p;
                large = large->next;
            }
            p = p->next;
        }
        large->next = nullptr;
        small->next = largeHead->next;
        return smallHead->next;
    }
};
```

### 328. 奇偶链表

给定单链表的头节点 `head `，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。第一个节点的索引被认为是奇数 ， 第二个节点的索引为偶数 ，以此类推。

请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。

**示例**：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205111119176.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入: head = [1,2,3,4,5]
输出: [1,3,5,2,4]
```

分别维护两个链表，一个链表接入索引为奇数的节点，另一个链表接入索引为偶数的节点，然后组合两个链表。

```php
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        int count = 1;
        ListNode* l1 = new ListNode(0);
        ListNode* l2 = new ListNode(0);
        ListNode* head1 = l1, * head2 = l2;
        while(head){
            if(count % 2 !=0){
                l1->next = head;
                l1 = l1->next;
            }else{
                l2->next = head;
                l2 = l2->next;
            }
            head = head->next;
            count++;
        }
        l1->next = head2->next;
        l2->next = nullptr;
        return head1->next;
    }
};
```

## 倒数第K个节点

### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 `6` 个节点，从头节点开始，它们的值依次是 `1、2、3、4、5、6`。这个链表的倒数第 `3` 个节点是值为 `4` 的节点。

**示例：**

```php
给定一个链表: 1->2->3->4->5, 和 k = 2.
返回链表 4->5.
```

如何**只遍历一次链表**，就算出倒数第 `k` 个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出**只需遍历一次链表**的解法。

首先，我们先让一个指针 `p1` 指向链表的头节点 `head`，然后走 `k` 步：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051454870.png" alt="image-20220505145454803" style="zoom:70%;" /></div>

趁这个时候，再用一个指针 `p2` 指向链表头节点 `head`，此时若把`p1`当作链表尾部的`NULL`，则`p2` 就是倒数第`k`个节点。：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051459242.png" alt="image-20220505145900194" style="zoom:65%;" /></div>

那如何让`p1`成为真正的尾节点而且`p1`和`p2`之间的位置关系保持不变呢？俩指针一同向后移动呗，直到`p1 == NULL`为止，此时`p1`就是真正的倒数第`k`个节点。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051501166.png" alt="image-20220505150130107" style="zoom:60%;" /></div>

这道题目重点在于理解双指针移动的原理与方法，方法理解了，代码实现就非常简单了。

```php
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode* p1 = head;
        //p1 移动 k 步
        for(int i = 0; i < k; i++){
            p1 = p1->next;
        }
        ListNode* p2 = head;
        //p1 和 p2 一同向后移动
        while(p1){
            p1 = p1->next;
            p2 = p2->next;
        }
        return p2;
    }
};
```

### 19. 删除链表的倒数第 N 个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051516856.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

要删除倒数第 `n` 个节点，就得获得倒数第 `n + 1` 个节点的指针。获取单链表的倒数第 `k` 个节点，就是想考察 [双指针技巧](https://labuladong.github.io/article/fname.html?fname=链表技巧) 中快慢指针的运用，一般都会要求**只遍历一次链表**，就算出倒数第 `k` 个节点。

**注意**：使用了**虚拟头结点**的技巧，也是**为了防止出现空指针**的情况。比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点，但第一个节点前面已经没有节点了，这就会出错。但有了虚拟头节点 `dummy` 的存在，就避免了这个问题，能够对这种情况进行正确的删除。

```php
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        // 删除倒数第 n 个，要先找倒数第 n + 1 个节点
        ListNode* p = find(dummy, n + 1);
        // 删掉倒数第 n 个节点
        p->next = p->next->next;
        return dummy->next;
    }

    ListNode* find(ListNode* head, int n){
        ListNode* p1 = head;
        for(int i = 0; i < n; i++){
            p1 = p1->next;
        }
        ListNode* p2 = head;
        while(p1){
            p1 = p1->next;
            p2 = p2->next;
        }
        return p2;
    }
};
```

## 中间节点 && 环形链表

### 876. 链表的中间结点

**题目**：给定一个头结点为 `head` 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。

如果想一次遍历就得到中间节点，就要使用「快慢指针」的技巧：

我们让两个指针 `slow` 和 `fast` 分别指向链表头结点 `head`。**每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步，这样当 `fast` 走到链表末尾时，`slow` 就指向了链表中点**。

上述思路的代码实现如下：

```php
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* fast = head, * slow = head;
        // 快指针走到末尾时停止
        while(fast && fast->next){
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
};
```

需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。另外，这段代码稍加修改就可以直接用到**判断链表成环**的算法题上。

### 141. 环形链表

给你一个链表的头节点 `head` ，判断链表中是否有环。如果链表中存在环，则返回 `true` ； 否则，返回 `false` 。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051537983.png" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

经典题目了，要使用双指针技巧中的**快慢指针**，每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。

如果 `fast` 最终遇到空指针，说明链表中没有环；如果 `fast` 最终和 `slow` 相遇，那肯定是 `fast` 超过了 `slow` 一圈，说明链表中含有环。

```php
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* fast = head, * slow = head;
        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
            // 快慢指针相遇，说明含有环
            if(fast == slow) return true;
        }
        // 不含有环
        return false;
    }
};
```

### 142. 环形链表 II

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。**不允许修改** 链表。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051547660.png" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。**为什么要这样呢？

假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051554426.png" alt="image-20220505155433363" style="zoom:60%;" /></div>

`fast` 一定比 `slow` 多走了 `k` 步，这多走的 `k` 步其实就是 `fast` 指针在环里转圈圈，所以 `k` 的值就是环长度的「整数倍」。

假设相遇点距环的起点的距离为 `m`，那么结合上图的 `slow` 指针，环的起点距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点。

巧的是，如果从相遇点继续前进 `k - m` 步，也恰好到达环起点。因为结合上图的 `fast` 指针，从相遇点开始走k步可以转回到相遇点，那走 `k - m` 步肯定就走到环起点了：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051555842.png" alt="image-20220505155537778" style="zoom:65%;" /></div>

所以，只要我们把快慢指针中的任一个重新指向 `head`，然后两个指针同速前进，`k - m` 步后一定会相遇，相遇之处就是环的起点了。

```php
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head, * slow = head;
        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
            if(fast == slow) break;
        }
        // fast 遇到空指针说明没有环
        if(!fast || !fast->next) return NULL;
        // 重新指向头结点
        slow = head;
        // 快慢指针同步前进，相交点就是环起点
        while(slow != fast){
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
```



## 翻转链表

### 206. 反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080908373.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```
**解法一**：递归法

```php
class Solution {
public:
    //定义：将以head为起点的链表反转，并返回反转之后的头结点
    ListNode* reverseList(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode* last = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return last;
    }
};
```

**对于递归算法，最重要的就是明确递归函数的定义**。具体来说，我们的 `reverse` 函数定义是这样的：

**输入一个节点 `head`，将「以 `head` 为起点」的链表反转，并返回反转之后的头结点**。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080927213.png" alt="image-20220508092702168" style="zoom:70%;" /></div>

那么输入 `reverse(head)` 后，会在这里进行递归：

```php
ListNode* last = reverseList(head->next);
```

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080928389.png" alt="image-20220508092851331" style="zoom:60%;" /></div>

`reverseList(head->next)` 执行完成后，整个链表就成了这样：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080930542.png" alt="image-20220508093035486" style="zoom:80%;" /></div>

并且根据函数定义，`reverse` 函数会返回反转之后的头结点，我们用变量 `last` 接收了。

现在再来看下面的代码：

```php
head->next->next = head;
```

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080931640.png" alt="image-20220508093159593" style="zoom:70%;" /></div>

接下来：

```php
head->next = NULL;
return last;
```

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080933837.png" alt="image-20220508093304789" style="zoom:70%;" /></div>

这样整个链表就反转过来了！递归代码就是这么简洁优雅，不过其中有两个地方需要注意：

1、递归函数要有 base case，也就是这句：

```php
if(!head || !head->next) return head;
```

意思是如果链表为空或者只有一个节点的时候，反转结果就是它自己，直接返回即可。

2、当链表递归反转之后，新的头结点是 `last`，而之前的 `head` 变成了最后一个节点，别忘了链表的末尾要指向 null：

```php
head->next = NULL;
```

理解了这两点后，我们就可以进一步深入了，接下来的问题其实都是在这个算法上的扩展。

**解法二**：迭代法，双指针法

```php
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr, * cur = head, * tmp = head;
        while(cur){
            tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
};
```

注意：

- `pre`和`cur`指针都要向后移动，所以还要记录`cur`后一个节点的指针`tmp`，因为`cur->next = pre`改变了`cur`的指向，`cur`下一个节点无法获得，所以要在该语句之前用`tmp`提前记录；
- `while`循环结束后，`cur`指向`NULL`，`pre`指向翻转后链表的头节点，所以要返回`pre`；
- 还可理解为在`[head, NULL)`区间（左闭右开）内翻转链表。

### 92. 反转链表 II

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080949720.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

首先思考一下：**如何反转链表前 N 个节点**？

比如说对于下图链表，执行 `reverseN(head, 3)`：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080941826.png" alt="image-20220508094103751" style="zoom:60%;" /></div>

解决思路和反转整个链表差不多，只要稍加修改即可：

```php
ListNode* successor = NULL; // 后驱节点

// 定义：反转以 head 为起点的 n 个节点，返回新的头结点
ListNode* reverseN(ListNode* head, int n) {
    if (n == 1) {
        // 记录第 n + 1 个节点
        successor = head->next;
        return head;
    }
    // 以 head->next 为起点，需要反转前 n - 1 个节点
    ListNode* last = reverseN(head->next, n - 1);
    head->next->next = head;
    // 让反转之后的 head 节点和后面的节点连起来
    head->next = successor;
    return last;
}
```

具体的区别：

1、base case 变为 `n == 1`，反转一个元素，就是它本身，同时**要记录后驱节点**。

2、刚才我们直接把 `head->next` 设置为 NULL，因为整个链表反转后原来的 `head` 变成了整个链表的最后一个节点。但现在 `head` 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 `successor`（第 `n + 1` 个节点），反转之后将 `head` 连接上。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205080944191.png" alt="image-20220508094450123" style="zoom:60%;" /></div>

这个函数能看懂，就离实现「**反转一部分链表**」不远了。

首先，如果 `left == 1`，就相当于反转链表开头的 `right` 个元素，也就是我们刚才实现的功能；

如果 `right != 1` 怎么办？如果我们把 `head` 的索引视为 1，那么我们是想从第 `left` 个元素开始反转；如果把 `head->next` 的索引视为 1 呢？那么相对于 `head->next`，反转的区间应该是从第 `left - 1` 个元素开始的；那么对于 `head->next->next` 呢……

```php
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if(left == 1) return reverseN(head, right);
        // 前进到反转的起点触发 base case
        head->next = reverseBetween(head->next, left - 1, right - 1);
        return head;
    }
    
    ListNode* successor = nullptr;
    ListNode* reverseN(ListNode* head, int n){
        if(n == 1){
            successor = head->next;
            return head;
        }
        ListNode* last = reverseN(head->next, n - 1);
        head->next->next = head;
        head->next = successor;
        return last;
    }
};
```

### 24. 两两交换链表中的节点

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例**：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205091351001.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**解法一**：递归法

```php
class Solution {
public:
    // 定义：返回链表节点两两交换后的头节点
    ListNode* swapPairs(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode* newHead = head->next;
        head->next = swapPairs(newHead->next);
        newHead->next = head;
        return newHead;
    }
};
```

**解法二**：迭代法

初始时，`cur`指向虚拟头结点，然后进行如下三步：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101114825.png" alt="image-20220510111404759" style="zoom:80%;" /></div>

打羊胎素展开链表：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101115513.png" alt="image-20220510111531466" style="zoom:80%;" /></div>

```php
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        ListNode* p = dummy;
        while(p->next && p->next->next){
            ListNode* tmp1 = p->next;
            ListNode* tmp2 = tmp1->next;
            ListNode* tmp3 = tmp2->next;
            p->next = tmp2;
            tmp2->next = tmp1;
            tmp1->next = tmp3;
            p = tmp1;
        }
        return dummy->next;
    }
};
```

### 25. K 个一组翻转链表

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205081042731.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

输入 `head`，`reverseKGroup` 函数能够把以 `head` 为头的这条链表进行翻转。我们要充分利用这个递归函数的定义，把原问题分解成规模更小的子问题进行求解。

**1、先反转以 `head` 开头的 `k` 个元素**。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205081131992.png" alt="image-20220508113128936" style="zoom:60%;" /></div>

**2、将第 `k + 1` 个元素作为 `head` 递归调用 `reverseKGroup` 函数**。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205081133011.png" alt="image-20220508113301946" style="zoom:65%;" /></div>

**3、将上述两个过程的结果连接起来**。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205081134446.png" alt="image-20220508113408376" style="zoom:70%;" /></div>

**4、最后函数递归完成之后就是这个结果，完全符合题意：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205081135250.png" alt="image-20220508113522192" style="zoom:70%;" /></div>

```php
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(!head) return nullptr;
        ListNode* a = head, * b = head;
        // 区间 [a, b) 包含 k 个待反转元素
        for(int i = 0; i < k; i++){
            // 不足 k 个，不需要反转，base case
            if(!b) return head;
            b = b->next;
        }
        // 反转前 k 个元素
        ListNode* newHead = reverse(a, b);
        // 递归反转后续链表并连接起来
        a->next = reverseKGroup(b, k);
        return newHead;
    }
	// 定义：反转区间 [a, b) 的元素，注意是左闭右开
    ListNode* reverse(ListNode* a, ListNode* b){
        ListNode* pre =nullptr, * cur = a, * nxt = a;
        while(cur != b){
            nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }
};
```

这里使用迭代法来写翻转链表reverse函数，其中三个指针的移动过程如图所示：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205081154922.gif" alt="8" style="zoom:40%;" /></div>

### 61. 旋转链表

给你一个链表的头节点 `head `，旋转链表，将链表每个节点向右移动 `k `个位置。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101131379.jpeg" alt="img" style="zoom:50%;" /></div>

**示例**：

```php
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

假设链表的长度为`len`，为了将链表每个节点向右移动 `k` 个位置，只需要将链表的后` k % len`个节点移动到链表的最前面，然后将链表的后`k % len`个节点和前 `len - k`个节点连接到一块即可。

1、首先遍历整个链表，求出链表的长度`n`，并找出链表的尾节点`tail`。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101146039.png" alt="image-20220510114658985" style="zoom:60%;" /></div>

2、由于`k`可能很大，所以我们令 `k = k % n`，然后再次从头节点`head`开始遍历，找到第`n - k`个节点p，那么1 ~ p是链表的前 `n - k`个节点，p+1 ~ n是链表的后`k`个节点。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101148095.png" alt="image-20220510114840024" style="zoom:60%;" /></div>

3、接下来就是依次执行 `tail->next = head`，`head = p->next`，`p->next = nullptr`，将链表的后`k`个节点和前 `n - k`个节点拼接到一块，并让`head`指向新的头节点`p->next`，新的尾节点即p节点的`next`指针指向`null`。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101152961.png" alt="image-20220510115248903" style="zoom:60%;" /></div>

4、最后返回链表的新的头节点`head`。

```php
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head || !k) return head;
        int len = 1;
        ListNode* tail = head;
        while(tail->next){
            tail = tail->next;
            len++;
        }
        k = k % len;
        ListNode* p = head;
        for(int i = 1; i < len - k; i++){
            p = p->next;
        }
        tail->next = head;
        head = p->next;
        p->next = nullptr;
        return head;
    }
};
```

## 链表重排

### 143. 重排链表

给定一个单链表 L 的头节点 head ，单链表 L 表示为：`L0 → L1 → … → Ln - 1 → Ln`
请将其重新排列后变为：`L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …`
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

**示例**：

```php
输入：head = [1,2,3,4]
输出：[1,4,2,3]
```

注意观察链表是怎么变化的，方法：**寻找链表中点 + 链表逆序 + 合并链表**

目标链表即为将原链表的左半端和反转后的右半端合并后的结果，这样我们的任务即可划分为三步：

- 找到原链表的中点（参考「876. 链表的中间结点」），使用快慢指针来 O(N) 地找到链表的中间节点。
- 将原链表的右半端反转（参考「206. 反转链表」），使用迭代法实现链表的反转。
- 将原链表的两端合并，因为两链表长度相差不超过 1，因此直接合并即可。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205102108369.png" alt="image-20220510210809294" style="zoom:70%;" /></div>

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205102110174.png" alt="image-20220510211017122" style="zoom:70%;" /></div>

```php
class Solution {
public:
    void reorderList(ListNode* head) {
        if(!head) return;
        ListNode* mid = middleNode(head);
        ListNode* l1 = head;
        ListNode* l2 = mid->next;
        mid->next = nullptr;
        l2 = reverse(l2);
        merge(l1, l2);
    }

    ListNode* middleNode(ListNode* head){
        ListNode* slow = head, * fast = head->next;
        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }

    ListNode* reverse(ListNode* head){
        ListNode* pre = nullptr, * cur = head;
        while(cur){
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }

    void merge(ListNode* l1, ListNode* l2){
        ListNode* p1, * p2;
        while(l1 && l2){
            p1 = l1->next;
            p2 = l2->next;
            l1->next = l2;
            l1 = p1;
            l2->next = l1;
            l2 = p2;
        }
    }
};
```

### 148. 排序链表

给你链表的头结点 `head `，请将其按 **升序** 排列并返回排序后的链表 。

**示例**：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205102114649.jpeg" alt="img" style="zoom:40%;" /></div>

```php
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

通过递归实现链表**归并排序**，有以下两个环节：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205111006447.png" alt="Picture2.png" style="zoom:40%;" /></div>



```php
class Solution {
public:
    // 定义：排序链表
    ListNode* sortList(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode* mid = middleNode(head);
        ListNode* l1 = head, * l2 = mid->next;
        mid->next = nullptr;
        // 注意：两链表排序之后再合并
        return merge(sortList(l1), sortList(l2));
    }
	// 定义：找链表的中心节点
    ListNode* middleNode(ListNode* head){
        // 注意 fast = head->next，若有两个中心节点则找到靠左的那个
        ListNode* fast = head->next, * slow = head;
        while(fast && fast->next){
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
	// 定义：合并两个链表
    ListNode* merge(ListNode* list1, ListNode* list2) {
        if(!list1 && !list2) return list1;
        ListNode* dummy = new ListNode(-1);
        ListNode* p = dummy, *p1 = list1, *p2 = list2;
        while(p1 && p2){
            if(p1->val > p2->val){
                p->next = p2;
                p2 = p2->next;
            }else{
                p->next = p1;
                p1 = p1->next;
            }
            p = p->next;
        }
        p->next = !p1 ? p2 : p1;
        return dummy->next;
    }
};
```

### 234. 回文链表

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205081046989.jpeg" alt="img" style="zoom:60%;" /></div>

```php
输入：head = [1,2,2,1]
输出：true
```

[双指针技巧](https://labuladong.github.io/algo/2/18/23/)，从两端向中间逼近即可：

```cpp
bool isPalindrome(string s) {
    int left = 0, right = s.length - 1;
    while (left < right) {
        if (s[left] != s[right]) return false;
        left++; right--;
    }
    return true;
}
```

以上代码很好理解，**因为回文串是对称的，所以正着读和倒着读应该是一样的，这一特点是解决回文串问题的关键**。

**解法一**：利用后序遍历

如果想正序打印链表中的 `val` 值，可以在前序遍历位置写代码；反之，如果想倒序遍历链表，就可以在后序遍历位置操作。

```php
class Solution {
public:
    ListNode* left;
    bool res = true;
    bool isPalindrome(ListNode* head) {
        left = head;
        traverse(head);
        return res;
    }

    void traverse(ListNode* right){
        if(!right) return;
        traverse(right->next);
        // 后序遍历位置
        if(left->val != right->val) res = false;
        left = left->next;
    }
};
```

利用后序遍历，算法的时间和空间复杂度都是 O(N)。能不能不用额外的空间，解决这个问题呢？

**解法二**：优化空间复杂度

1、先通过 ⌈双指针技巧⌋ 中的快慢指针来找到链表的中点：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205091153464.png" alt="image-20220509115340350" style="zoom:60%;" /></div>

2、如果`fast`指针没有指向`null`，说明链表长度为奇数，`slow`还要再前进一步：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205091155968.png" alt="image-20220509115524911" style="zoom:60%;" /></div>

3、从`slow`开始反转后面的链表，现在就可以开始比较回文串了：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205091156704.png" alt="image-20220509115621642" style="zoom:50%;" /></div>

```php
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* left = head;
        ListNode* right = middleNode(head);
        right = reverseList(right);
        while(right){
            if(left->val != right->val) return false;
            left = left->next;
            right = right->next;
        }
        return true;
    }

    ListNode* middleNode(ListNode* head){
        ListNode* slow = head, * fast = head;
        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
        }
        // 链表长度为奇数，`slow还要再前进一步
        if(fast) slow = slow->next;
        return slow;
    }

    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr, * cur = head, * tmp = head;
        while(cur){
            tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
};
```

算法总体的时间复杂度 O(N)，空间复杂度 O(1)，已经是最优的了。

另一个版本，找中间节点函数`middleNode`另一种写法：

```php
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* mid = middleNode(head);
        ListNode* left = head, * right = mid->next;
        mid->next = nullptr;
        right = reverse(right);
        while(right){
            if(left->val != right->val) return false;
            left = left->next;
            right = right->next;
        }
        return true;
    }
    
    ListNode* middleNode(ListNode* head){
        ListNode* fast = head->next, * slow = head;
        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }

    ListNode* reverse(ListNode* head){
        ListNode* pre = nullptr, * cur = head, * tmp;
        while(cur){
            tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
};
```

## 删除链表元素

### 203. 移除链表元素

给你一个链表的头节点 `head `和一个整数 `val `，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 新的头节点 。

**示例**：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205091330784.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

```php
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode* pre = dummy;
        while(pre->next){
            if(pre->next->val == val){
                pre->next = pre->next->next;
            }else{
                pre = pre->next;
            }
        }
        return dummy->next;
    }
};
```

### 83. 删除排序链表中的重复元素

给定一个已排序的链表的头 `head` ， 删除所有重复的元素，使每个元素只出现一次 ，返回 已排序的链表 。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205101206051.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：head = [1,1,2,3,3]
输出：[1,2,3]
```

```php
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head) return nullptr;
        ListNode* pre = head;
        while(pre->next){
            if(pre->val == pre->next->val){
                pre->next = pre->next->next;
            }else{
                pre = pre->next;
            }
        }
        return head;
    }
};
```

## 445. 两数相加 II

给定两个 非空链表 `l1`和 `l2 `来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。可以假设除了数字 0 之外，这两个数字都不会以零开头。

**示例**：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205111138200.png" alt="img" style="zoom:50%;" /></div>

```php
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
```

本题的主要难点在于链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，可以使用**栈**：把所有数字压入栈中，再依次取出相加，**计算过程中需要注意进位的情况**。

```php
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        stack<int> s1, s2;
        while(l1){
            s1.push(l1->val);
            l1 = l1->next;
        }
        while(l2){
            s2.push(l2->val);
            l2 = l2->next;
        }
        int carry = 0, cur = 0; //进位，本位
        ListNode* res = nullptr;
        while(!s1.empty() || !s2.empty() || carry){
            int a = s1.empty() ? 0 : s1.top();
            int b = s2.empty() ? 0 : s2.top();
            if(!s1.empty()) s1.pop();
            if(!s2.empty()) s2.pop();
            int sum = a + b + carry;
            carry = sum / 10;
            cur = sum % 10;
            ListNode* node = new ListNode(cur);
            node->next = res;
            res = node;
        }
        return res;
    }
};
```

## 160. 相交链表

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null`。图示两个链表在节点 `c1` 开始相交。题目数据 **保证** 整个链式结构中不存在环。**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051608009.png" alt="img" style="zoom:50%;" /></div>



这题难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051844252.png" alt="image-20220505184443179" style="zoom:50%;" /></div>

如果用两个指针 `p1` 和 `p2` 分别在两条链表上前进，并不能**同时**走到公共节点，也就无法得到相交节点 `c1`。

**解决这个问题的关键是，通过某些方式，让 `p1` 和 `p2` 能够同时到达相交节点 `c1`。**

**解法一**：使用双指针

如果用两个指针 `p1` 和 `p2` 分别在两条链表上前进，我们可以让 `p1` 遍历完链表 `A` 之后开始遍历链表 `B`，让 `p2` 遍历完链表 `B` 之后开始遍历链表 `A`，这样相当于「逻辑上」两条链表接在了一起。

如果这样进行拼接，就可以让 `p1` 和 `p2` 同时进入公共部分，也就是同时到达相交节点 `c1`：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205051848637.png" alt="image-20220505184819556" style="zoom:50%;" /></div>

那如果两个链表没有相交点，是否能够正确的返回 null 呢？这个逻辑可以覆盖这种情况的，相当于 `c1` 节点是 null 空指针嘛，可以正确返回 null。

```php
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* p1 = headA, * p2 = headB;
        while(p1 != p2){
            if(!p1) p1 = headB;
            else p1 = p1->next;
            if(!p2) p2 = headA;
            else p2 = p2->next;
        }
        return p1;
    }
};
```

运用了相同方法的题目：**1650、二叉树的最近公共祖先 III**

## 剑指 Offer 06. 从尾到头打印链表

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

**示例：**

```php
输入：head = [1,3,2]
输出：[2,3,1]
```

利用链表后序遍历位置即可得到倒序遍历的结果。

```php
class Solution {
public:
    vector<int> res;
    vector<int> reversePrint(ListNode* head) {
        traverse(head);
        return res;
    }

    void traverse(ListNode* head){
        if(!head) return;
        traverse(head->next);
        res.push_back(head->val);
    }
};
```



# 三、数组

## 双指针

### 26. 删除有序数组中的重复项

给你一个 **升序排列** 的数组 `nums `，请你原地删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新长度。元素的相对顺序 应该保持 一致 。

示例：

```php
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

有序序列去重的通用解法就是我们前文 [双指针技巧](https://labuladong.github.io/article/fname.html?fname=双指针技巧) 中的快慢指针技巧。

让慢指针 `slow` 走在后面，快指针 `fast` 走在前面探路，找到一个不重复的元素就告诉 `slow` 并让 `slow` 前进一步。这样当 `fast` 指针遍历完整个数组 `nums` 后，`nums[0..slow]` 就是不重复元素。

```php
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(!nums.size()) return 0;
        int slow = 0, fast = 0;
        while(fast < nums.size()){
            if(nums[fast] != nums[slow]){
                slow++;
                nums[slow] = nums[fast];
            }
            fast++;
        }
        // 数组长度为 索引 + 1
        return slow + 1;
    }
};
```

### 27. 移除元素

给你一个数组 `nums` 和一个值 `val`，你需要原地移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

```php
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
```

题目要求我们把 `nums` 中所有值为 `val` 的元素原地删除，依然需要使用快慢指针技巧：如果 `fast` 遇到值为 `val` 的元素，则直接跳过，否则就赋值给 `slow` 指针，并让 `slow` 前进一步。

注意这里和有序数组去重的解法有一个细节差异，我们这里是先给 `nums[slow]` 赋值然后再给 `slow++`，这样可以保证`nums[0..slow-1]` 是不包含值为 `val` 的元素的，最后的结果数组长度就是 `slow`。

```php
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int fast = 0, slow = 0;
        while(fast < nums.size()){
            if(nums[fast] != val){
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```

### 283. 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

示例：

```php
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

可以直接复用 [27. 移除元素](https://leetcode.cn/problems/remove-element) 的解法，先移除所有 0，然后把最后的元素都置为 0，就相当于移动 0 的效果。

```php
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // 去除nums中的所有0
        int len = remove(nums, 0);
        // 将len之后的所有元素赋值为 0
        while(len < nums.size()){
            nums[len] = 0;
            len++;
        }
    }
	// 定义：在数组nums中移除值为val的元素，返回数组长度
    int remove(vector<int>& nums, int val){
        int fast = 0, slow = 0;
        while(fast < nums.size()){
            if(nums[fast] != val){
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```

## NSUM 问题

### 167. 两数之和-输入有序数组

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。

```php
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
```

只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 `left` 和 `right` 就可以调整 `sum` 的大小：

```php
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0, right = numbers.size() - 1;
        while(left < right){
            int sum = numbers[left] + numbers[right];
            if(sum == target){
                return {left + 1, right + 1}; 
            }else if(sum < target){
                left++;
            }else{
                right--;
            }
        }
        return {};
    }
};
```

### 1. 两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

```php
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
```

若要求返回数组元素，则可以可将数组排序后使用双指针：

```php
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int left = 0, right = nums.size() - 1;
        while(left < right){
            int sum = nums[left] + nums[right];
            if(sum == target){
                return {nums[left], nums[right]};
            }else if(sum < target){
                left++;
            }else{
                right--;
            }
        }
        return {};
    }
};
```

若要求返回数组元素的索引，则无法使用上述的双指针，因为排序后数组元素的索引有变动，可使用哈希表：

```php
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> map;
        for(int i = 0; i < nums.size(); i++){
            auto it = map.find(target - nums[i]);
            if(it != map.end()) return {it->second, i};
            map[nums[i]] = i;
        }
        return {};
    }
};
```

魔改题目：

`nums` 中可能有多对元素之和都等于 `target`，请你的算法返回所有和为 `target` 的元素对，**其中不能出现重复**。

```php
vector<vector<int>> twoSumTarget(vector<int>& nums, int target) {
    // nums 数组必须有序
    sort(nums.begin(), nums.end());
    int lo = 0, hi = nums.size() - 1;
    vector<vector<int>> res;
    while (lo < hi) {
        int sum = nums[lo] + nums[hi];
        // 记录索引 lo 和 hi 最初对应的值
        int left = nums[lo], right = nums[hi];
        if (sum < target) {
            while (lo < hi && nums[lo] == left) lo++;
        } else if (sum > target) {
            while (lo < hi && nums[hi] == right) hi--;
        } else {
            res.push_back({left, right});
            // 跳过所有重复的元素
            while (lo < hi && nums[lo] == left) lo++;
            while (lo < hi && nums[hi] == right) hi--;
        }
    }
    return res;
}
```

### 15. 三数之和

给你一个包含 `n` 个整数的数组 `nums`，判断 `nums `中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且**不重复**的三元组。

```php
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

这个问题怎么解决呢？**很简单，穷举呗**。现在我们想找和为 `target` 的三个数字，那么对于第一个数字，可能是什么？`nums` 中的每一个元素 `nums[i]` 都有可能！

那么，确定了第一个数字之后，剩下的两个数字可以是什么呢？其实就是和为 `target - nums[i]` 的两个数字呗，那不就是 `twoSum` 函数解决的问题么🤔。

**关键点在于，不能让第一个数重复，至于后面的两个数，我们复用的 `twoSum` 函数会保证它们不重复**。所以代码中必须用一个 while 循环来保证 `3Sum` 中第一个元素不重复。

```php
class Solution {
public:

    /* 计算数组 nums 中所有和为 target 的三元组 */
    vector<vector<int>> threeSum(vector<int>& nums) {
        // 数组得排个序
        sort(nums.begin(), nums.end());
        int n = nums.size();
        vector<vector<int>> res;
        // 穷举 threeSum 的第一个数
        for (int i = 0; i < n; i++) {
            // 对 target - nums[i] 计算 twoSum
            vector<vector<int>> tuples = twoSumTarget(nums, i + 1, - nums[i]);
            // 如果存在满足条件的二元组，再加上 nums[i] 就是结果三元组
            for (vector<int>& tuple : tuples) {
                tuple.push_back(nums[i]);
                res.push_back(tuple);
            }
            // 跳过第一个数字重复的情况，否则会出现重复结果
            while (i < n - 1 && nums[i] == nums[i + 1]) i++;
        }
        return res;
    }
    vector<vector<int>> twoSumTarget(vector<int>& nums, int start, int target) {
        // nums 数组必须有序
        sort(nums.begin(), nums.end());
        int lo = start, hi = nums.size() - 1;
        vector<vector<int>> res;
        while (lo < hi) {
            int sum = nums[lo] + nums[hi];
            // 记录索引 lo 和 hi 最初对应的值
            int left = nums[lo], right = nums[hi];
            if (sum < target) {
                while (lo < hi && nums[lo] == left) lo++;
            } else if (sum > target) {
                while (lo < hi && nums[hi] == right) hi--;
            } else {
                res.push_back({left, right});
                // 跳过所有重复的元素
                while (lo < hi && nums[lo] == left) lo++;
                while (lo < hi && nums[hi] == right) hi--;
            }
        }
        return res;
    }    
};
```

代码优化一下：

再比如 LeetCode 的 `3Sum` 问题，找 `target == 0` 的三元组：

```php
vector<vector<int>> threeSum(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    // n 为 3，从 nums[0] 开始计算和为 0 的三元组
    return nSumTarget(nums, 3, 0, 0);        
}
```

`nSumTarget`函数实现见下一题。

### 18. 四数之和

给你一个由 `n `个整数组成的数组 `nums `，和一个目标值 `target `。请你找出并返回满足下述全部条件且不重复的四元组` [nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

- 0 <= a, b, c, d < n

- a、b、c 和 d 互不相同

- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按任意顺序返回答案 。

```php
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

都到这份上了，`4Sum` 完全就可以用相同的思路：穷举第一个数字，然后调用 `3Sum` 函数计算剩下三个数，最后组合出和为 `target` 的四元组。总结 `nSum` 函数：

```php
/* 注意：调用这个函数之前一定要先给 nums 排序 */
// n为整数个数，start为双指针初始值，target为目标值
vector<vector<int>> nSumTarget(vector<int>& nums, int n, int start, int target) {
    int size = nums.size();
    vector<vector<int>> res;
    // 至少是 2Sum，且数组大小不应该小于 n
    if (n < 2 || size < n) return res;
    // 2Sum 是 base case
    if (n == 2) {
        // 双指针那一套操作
        int lo = start, hi = size - 1;
        while (lo < hi) {
            int left = nums[lo], right = nums[hi];
            int sum = left + right;                
            if (sum < target) {
                while (lo < hi && nums[lo] == left) lo++;
            } else if (sum > target) {
                while (lo < hi && nums[hi] == right) hi--;
            } else {
                res.push_back({left, right});
                while (lo < hi && nums[lo] == left) lo++;
                while (lo < hi && nums[hi] == right) hi--;
            }
        }
    } else {
        // n > 2 时，递归计算 (n-1)Sum 的结果
        for (int i = start; i < size; i++) {
            vector<vector<int>> sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
            for (vector<int>& arr : sub) {
                // (n-1)Sum 加上 nums[i] 就是 nSum
                arr.push_back(nums[i]);
                res.push_back(arr);
            }
            while (i < size - 1 && nums[i] == nums[i + 1]) i++;
        }
    }
    return res;
}
```

实际上就是把之前的题目解法合并起来了，`n == 2` 时是 `twoSum` 的双指针解法，`n > 2` 时就是穷举第一个数字，然后递归调用计算 `(n-1)Sum`，组装答案。

**需要注意的是，调用这个 `nSum` 函数之前一定要先给 `nums` 数组排序**，因为 `nSum` 是一个递归函数，如果在 `nSum` 函数里调用排序函数，那么每次递归都会进行没有必要的排序，效率会非常低。

比如说现在我们写 LeetCode 上的 `4Sum` 问题：

```php
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    sort(nums.begin(), nums.end());
    // n 为 4，从 nums[0] 开始计算和为 target 的四元组
    return nSumTarget(nums, 4, 0, target);
}
```

那么，如果让你计算 `100Sum` 问题，直接调用这个函数就完事儿了。

## 二分搜索

### 704. 二分查找

给定一个 `n `个元素有序的（升序）整型数组 `nums `和一个目标值 `target  `，写一个函数搜索 `nums `中的 `target`，如果目标值存在返回下标，否则返回 -1。

```php
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
```

版本一：

```php
//闭区间[left, right]
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right)
        {
            int mid = left + (right - left) / 2;
            if (nums[mid] > target)  right = mid - 1;
            else if (nums[mid] < target)  left = mid + 1;
            else return mid;
        }
        return -1;
    }
};
```

版本二：

```php
//左闭右开区间[left, right)
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size();
        while (left < right)
        {
            int mid = left + (right - left) / 2;
            if (nums[mid] > target) right = mid;
            else if (nums[mid] < target) left = mid + 1;
            else return mid;
        }
        return -1;
   }
};
```

🔥while 循环的条件是 <=还是 <？

`right = nums.size() - 1`相当于两端都闭区间 `[left, right]`，`right = nums.size()`相当于左闭右开区间 `[left, right)`，因为索引大小为 `nums.length` 是越界的。

什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：

```php
if(nums[mid] == target) return mid; 
```

但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？**搜索区间为空的时候应该终止**，意味着你没得找了，就等于没找到嘛。

版本一：

`while(left <= right)` 的终止条件是 `left == right + 1`，写成区间的形式就是 `[right + 1, right]`，或者带个具体的数字进去 `[3, 2]`，可见**这时候区间为空**，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。

版本二：

`while(left < right)` 的终止条件是 `left == right`，写成区间的形式就是 `[right, right)`，或者带个具体的数字进去 `[2, 2)`，**这时候区间为空**，所以这时候 while 循环终止是正确的，直接返回 -1 即可。

### 367. 有效的完全平方数

给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。

```php
输入：num = 16
输出：true
```

可使用二分查找，因为`num`是正整数，所以若正整数`a`满足`axa= num`，则z一定满足`1<a<num`，于是我们可以将`1`和`num`作为二分查找搜索区间的初始边界。

```php
class Solution {
public:
    bool isPerfectSquare(int num) {
        int left = 0, right = num;
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            long square = (long) mid * mid;
            if (square < num) {
                left = mid + 1;
            } else if (square > num) {
                right = mid - 1;
            } else {
                return true;
            }
        }
        return false;
    }
};
```

### 34. 在排序数组中查找元素的第一个和最后一个位置

给定一个按照**升序**排列的整数数组 `nums`，和一个目标值 `target`，找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。

```php
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

1. **寻找左侧边界的二分查找**：

因为初始化 `right = nums.size()`，所以决定了「搜索区间」是 `[left, right)`，所以决定了 `while (left < right)`，同时也决定了 `left = mid + 1` 和 `right = mid`。因为需找到 `target `的最左侧索引，所以当 `nums[mid] == target `时不要立即返回，而要收紧右侧边界以锁定左侧边界。

2. **寻找右侧边界的二分查找**：

因为初始化 `right = nums.size()`，所以决定了「搜索区间」是 `[left, right)`，所以决定了 `while (left < right)`，同时也决定了 `left = mid + 1` 和 `right = mid`。因为需找到 target 的最右侧索引，所以当 `nums[mid] == target` 时不要立即返回，而要收紧左侧边界以锁定右侧边界。又因为收紧左侧边界时必须 left = mid + 1，所以最后无论返回 left 还是 right，必须减一。


```php
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = leftBound(nums, target);
        int right = rightBound(nums, target);
        // [left, right)
        if(left == right) return {-1, -1};
        return {left, right - 1};
    }
	// 找左边界
    int leftBound(vector<int>& nums, int target){
        int left = 0, right = nums.size();
        while(left < right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) right = mid;
            else if(nums[mid] > target) right = mid;
            else left = mid + 1;
        }
        return left;
    }
	//找右边界
    int rightBound(vector<int>& nums, int target){
        int left = 0, right = nums.size();
        while(left < right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) left = mid + 1;
            else if(nums[mid] > target) right = mid;
            else left = mid + 1;
        }
        return right;
    }
};
```

### 35. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

```php
输入: nums = [1,3,5,6], target = 5
输出: 2
```

当目标元素 `target` 不存在数组 `nums` 中时，搜索左侧边界的二分搜索的返回值可以做以下几种解读：

1、返回的这个值是 `nums` 中大于等于 `target` 的最小元素索引。

2、返回的这个值是 `target` 应该插入在 `nums` 中的索引位置。

3、返回的这个值是 `nums` 中小于 `target` 的元素个数。

比如在有序数组 `nums = [2,3,5,7]` 中搜索 `target = 4`，**搜索左边界**的二分算法会返回 2，带入上面的说法，都是对的。

所以以上三种解读都是等价的，可以根据具体题目场景灵活运用，显然这里我们需要的是第二种。

```php
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size();
        while(left < right){
            int mid = left + (right - left) / 2;
            if(nums[mid] >= target) right = mid;
            else left = mid + 1;
        }
        return left;
    }
};
```

## 滑动窗口

### 3. 无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

```
输入: s = "abcabcbb"
输出: 3 
```

这就是变简单了，连 `need` 和 `valid` 都不需要，而且更新窗口内数据也只需要简单的更新计数器 `window` 即可。当 `window[c]` 值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动 `left` 缩小窗口了。

唯一需要注意的是，在哪里更新结果 `res` 呢？我们要的是最长无重复子串，哪一个阶段可以保证窗口中的字符串是没有重复的呢？

这里和之前不一样，要在收缩窗口完成后更新 `res`，因为窗口收缩的 `while `条件是存在重复元素的，换句话说收缩完成后一定保证窗口中没有重复。

```php
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> window;
        int left = 0, right = 0, res = 0;
        while(right < s.size()){
            char c = s[right];
            right++;
            window[c]++;
            while(window[c] > 1){
                char d = s[left];
                left++;
                window[d]--;
            }
            res = max(res, right - left);
        }
        return res;
    }
};
```

### 209. 长度最小的子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` ，找出该数组中满足其和` ≥ target` 的长度最小的 连续子数组` [numsl, numsl+1, ..., numsr-1, numsr] `，并返回其长度。如果不存在符合条件的子数组，返回 0 。

```php
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
```

不过需要强调的是，**题目说了 `nums` 数组中的元素都是正数，有了这个前提才能使用滑动窗口算法**，因为窗口扩大时窗口内元素之和必然增大，窗口缩小时窗口内元素之和必然减小。

如果 `nums` 数组中包含负数，则窗口扩大时元素和不见得就增大，窗口缩小时元素和不见得就减小，这种情况就不能单纯使用滑动窗口技巧了，可能需要混合动态规划和单调队列来做。

```php
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left = 0, right = 0, sum = 0, res = INT_MAX;
        while(right < nums.size()){
            sum += nums[right];
            right++;
            while(sum >= target && left < right){
                res = min(res, right - left);
                sum -= nums[left];
                left++;
            }
        }
        return res == INT_MAX ? 0 : res;

    }
};
```

### 76. 最小覆盖子串

给你一个字符串 `s` 、一个字符串 `t `，返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串`""` 。

```php
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

滑动窗口的思路：

1、我们在字符串 `S` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个「窗口」。

2、我们先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T` 中的所有字符）。

3、此时，我们停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了）。同时，每次增加 `left`，我们都要更新一轮结果。

4、重复第 2 和第 3 步，直到 `right` 到达字符串 `S` 的尽头。

这个思路其实也不难，**第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解**，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「**滑动窗口**」这个名字的来历。

初始状态：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205201152976.png" alt="image-20220520115217917" style="zoom:80%;" /></div>

增加 `right`，直到窗口 `[left, right)` 包含了 `T` 中所有字符：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205201153833.png" alt="image-20220520115349776" style="zoom:80%;" /></div>

现在开始增加 `left`，缩小窗口 `[left, right)`：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205201154016.png" alt="image-20220520115450943" style="zoom:80%;" /></div>

直到窗口中的字符串不再符合要求，`left` 不再继续移动：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205201155927.png" alt="image-20220520115526871" style="zoom:80%;" /></div>

之后重复上述过程，先移动 `right`，再移动 `left`…… 直到 `right` 指针到达字符串 `S` 的末端，算法结束。

首先，初始化 `window` 和 `need` 两个哈希表，记录窗口中的字符和需要凑齐的字符：

```php
unordered_map<char, int> need, window;
for (char c : t) need[c]++;
```

然后，使用 `left` 和 `right` 变量初始化窗口的两端，不要忘了，区间 `[left, right)` 是**左闭右开**的，所以初始情况下窗口没有包含任何元素：

```php
int left = 0, right = 0;
int valid = 0; 
while (right < s.size()) {
    // 开始滑动
}
```

**其中 `valid` 变量表示窗口中满足 `need` 条件的字符个数**，如果 `valid` 和 `need.size` 的大小相同，则说明窗口已满足条件，已经完全覆盖了串 `T`。

如果一个字符进入窗口，应该增加 `window` 计数器；如果一个字符将移出窗口的时候，应该减少 `window` 计数器；当 `valid` 满足 `need` 时应该收缩窗口；应该在收缩窗口的时候更新最终结果。

```php
string minWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t){
        need[c]++;
    }
    int left = 0, right = 0, valid = 0; // valid表示窗口中满足 need 条件的字符个数
    // 记录最小覆盖子串的起始索引及长度
    int start = 0, len = INT_MAX;
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 扩大窗口
        right++;
        // 进行窗口内数据的一系列更新
        if (need.count(c)) {
            window[c]++;
            if (window[c] == need[c]) valid++;
        }

        // 判断左侧窗口是否要收缩
        while (valid == need.size()) {
            // 在这里更新最小覆盖子串
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            // d 是将移出窗口的字符
            char d = s[left];
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            if (need.count(d)) {
                if (window[d] == need[d]) valid--;
                window[d]--;
            }                    
        }
    }
    // 返回最小覆盖子串
    return len == INT_MAX ? "" : s.substr(start, len);
}
```

需要注意的是，当我们发现某个字符在 `window` 的数量满足了 `need` 的需要，就要更新 `valid`，表示有一个字符已经满足要求，而且两次对窗口内数据的更新操作是完全对称的。

当 `valid == need.size()` 时，说明 `T` 中所有字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该开始收缩窗口了，以便得到「最小覆盖子串」。

移动 `left` 收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。

### 567. 字符串的排列

给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` 的排列。如果是，返回 `true `；否则，返回 `false `。

```php
输入：s1 = "ab" s2 = "eidbaooo"
输出：true
输入：s1= "ab" s2 = "eidboaoo"
输出：false
```

注意哦，输入的 `s1` 是可以包含重复字符的，所以这个题难度不小。

这种题目，是明显的滑动窗口算法，**相当给你一个 `S` 和一个 `T`，请问你 `S` 中是否存在一个子串，包含 `T` 中所有字符且不包含其他字符**？

对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：

1、本题移动 `left` 缩小窗口的时机是窗口大小大于 `t.size()` 时，应为排列嘛，显然长度应该是一样的。

2、当发现 `valid == need.size()` 时，就说明窗口中就是一个合法的排列，所以立即返回 `true`。

至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。

```php
class Solution {
public:
    // 判断 s2 中是否存在 s1 的排列
    bool checkInclusion(string s1, string s2) {
        unordered_map<char, int> need, window;
        for(char c : s1){
            need[c]++;
        }
        int left = 0, right = 0, valid = 0;
        while(right < s2.size()){
            char c = s2[right];
            right++;
            if(need.count(c)){
                window[c]++;
                if(window[c] == need[c]) valid++;
            }
            // 判断左侧窗口是否要收缩
            while(right - left >= s1.size()){
                // 判断是否找到了合法的子串
                if(valid == need.size()) return true;
                char d = s2[left];
                left++;
                if(need.count(d)){
                    if(window[d] == need[d]) valid--;
                    window[d]--;
                }
            }
        }
        // 未找到符合条件的子串
        return false;
    }
};
```

### 438. 找到字符串中所有字母异位词

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p`的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

```php
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
```

所谓的**字母异位词**就是**排列**，相当于输入一个串 `S`，一个串 `T`，找到 `S` 中所有 `T` 的排列，返回它们的起始索引。跟寻找字符串的排列一样，只是找到一个合法异位词（排列）之后将起始索引加入 `res` 即可。

```php
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        unordered_map<char, int> need, window;
        for(char c : p) need[c]++;
        int left = 0, right = 0, valid = 0;
        vector<int> res;
        while(right < s.size()){
            char c = s[right];
            right++;
            if(need.count(c)){
                window[c]++;
                if(window[c] == need[c]) valid++;
            }
            // 判断左侧窗口是否要收缩
            while(right - left >= p.size()){
                // 当窗口符合条件时，把起始索引加入 res
                if(valid == need.size()) res.push_back(left);
                char d = s[left];
                left++;
                if(need.count(d)){
                    if(need[d] == window[d]) valid--;
                    window[d]--;
                }
            }
        }
        return res;
    }
};
```

## 二维数组遍历

### 48. 旋转图像

给定一个 `n × n` 的二维矩阵 matrix 表示一个图像。请你将图像**顺时针**旋转 90 度。你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205211142216.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

旋转二维矩阵的难点在于将「行」变成「列」，将「列」变成「行」，而只有按照对角线的对称操作是可以轻松完成这一点的，对称操作之后就很容易发现规律了。

我们可以先将 `n x n` 矩阵 `matrix` 按照左上到右下的对角线进行镜像对称：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205211151127.png" alt="image-20220521115152062" style="zoom:80%;" /></div>

然后再对矩阵的每一行进行反转：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205211153864.png" alt="image-20220521115345798" style="zoom:80%;" /></div>

发现结果就是 `matrix` 顺时针旋转 90 度的结果：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205211155575.png" alt="image-20220521115523512" style="zoom:80%;" /></div>

```php
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for(int i = 0; i < n; i++){
            for(int j = 0; j < i; j++){
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        for(int i = 0; i < n; i++){
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
```


**那如何将矩阵逆时针旋转 90 度呢**？

思路是类似的，只要通过另一条对角线镜像对称矩阵，然后再反转每一行，就得到了逆时针旋转矩阵的结果：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205211156783.png" alt="image-20220521115657715" style="zoom:80%;" /></div>

```php
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n - i; j++){
                swap(matrix[i][j], matrix[n - j - 1][n - i - 1]);
            }
        }
        for(int i = 0; i < n; i++){
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
```

### 54. 螺旋矩阵

给你一个 `m `行 `n` 列的矩阵 matrix ，请按照 **顺时针**螺旋顺序 ，返回矩阵中的所有元素。

<div align=center><img src="https://s1.ax1x.com/2022/05/21/Oj35qK.jpg" alt="Oj35qK.jpg" style="zoom:70%;" /></div>

```php
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界。

<div align=center><img src="https://s1.ax1x.com/2022/05/21/OjGnXt.png" style="zoom:40%;" /></div>

随着螺旋遍历，相应的边界会收缩，直到螺旋遍历完整个数组：

<div align=center><img src="https://s1.ax1x.com/2022/05/21/OjJ1Dx.png" style="zoom:40%;" /></div>

```php
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        int upper = 0, lower = m - 1, left = 0, right = n - 1;
        vector<int> res;
        // res.size() == m * n 则遍历完整个数组
        while(res.size() < m * n){
            // 在顶部从左向右遍历
            if(upper <= lower){
                for(int j = left; j <= right; j++){
                    res.push_back(matrix[upper][j]);
                }
                // 上边界下移
                upper++;
            }
            if(left <= right){
                // 在右侧从上向下遍历
                for(int i = upper; i <= lower; i++){
                    res.push_back(matrix[i][right]);
                }
                // 右边界左移
                right--;
            }
            if(upper <= lower){
                // 在底部从右向左遍历
                for(int j = right; j >= left; j--){
                    res.push_back(matrix[lower][j]);
                }
                // 下边界上移
                lower--;
            }
            if(left <= right){
                // 在左侧从下向上遍历
                for(int i = lower; i >= upper; i--){
                    res.push_back(matrix[i][left]);
                }
                // 左边界右移
                left++;
            }
        }
        return res;
    }
};
```

### 59. 螺旋矩阵II

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

<div align=center><img src="https://s1.ax1x.com/2022/05/21/Oj35qK.jpg" alt="Oj35qK.jpg" style="zoom:70%;" /></div>

```php
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

和上一道题类似的思路：

```php
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n));
        int upper = 0, lower = n - 1, left = 0, right = n - 1;
        int num = 1;
        while(num <= n * n){
            if(upper <= lower){
                for(int j = left; j <= right; j++){
                    res[upper][j] = num++;
                }
                upper++;
            }
            if(left <= right){
                for(int i = upper; i <= lower; i++){
                    res[i][right] = num++;
                }
                right--;
            }
            if(upper <= lower){
                for(int j = right; j >= left; j--){
                    res[lower][j] = num++;
                }
                lower--;
            }
            if(left <= right){
                for(int i = lower; i >= upper; i--){
                    res[i][left] = num++;
                }
                left++;
            }
        }
        return res;
    }
};
```













## 344. 反转字符串

## 5. 最长回文子串










## 前缀和数组

### 303. 区域和检索-数组不可变

### 304. 二维区域和检索-矩阵不可变

## 差分数组

### 370. 区间加法

### 1109. 航班预订统计
### 1094. 拼车



## 528.  按权重随机选择	

## 875. 爱吃香蕉的珂珂
## 1011. 在D天内送达包裹的能力
## 410. 分割数组的最大值

## 870. 优势洗牌	

## 380. O(1)时间插入、删除和获取随机元素
## 710. 黑名单中的随机数

## 316. 去除重复字母
## 1081. 不同字符的最小子序列

## 844. 比较含退格的字符串
## 977. 有序数组的平方



# 动态规划







# 设计数据结构

## 二叉堆实现优先级队列

二叉堆（Binary Heap）没什么神秘，性质比二叉搜索树 BST 还简单。其主要操作就两个，`sink`（下沉）和 `swim`（上浮），用以维护二叉堆的性质。其主要应用有两个，首先是一种排序方法「**堆排序**」，第二是一种很有用的数据结构「**优先级队列**」。

二叉堆在逻辑上其实是一种**特殊的二叉树**（完全二叉树），只不过**存储在数组里**。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针：

```php
// 父节点的索引
int parent(int root) {
    return root / 2;
}
// 左孩子的索引
int left(int root) {
    return root * 2;
}
// 右孩子的索引
int right(int root) {
    return root * 2 + 1;
}
```

比如 `arr` 是一个字符数组，注意数组的第一个索引 0 空着不用：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301605385.png" alt="image-20220430160517323" style="zoom:60%;" /></div>

因为这棵二叉树是「**完全二叉树**」，所以把 `arr[1]` 作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。

二叉堆还分为**最大堆**和**最小堆**。**最大堆的性质是：每个节点都大于等于它的两个子节点**。类似的，**最小堆的性质是：每个节点都小于等于它的子节点**。

对于一个最大堆，根据其性质，显然堆顶，也就是 `arr[1]` 一定是所有元素中最大的元素。

**优先级队列**这种数据结构有一个很有用的功能，**插入或者删除元素的时候，元素会自动排序**，底层的原理就是**二叉堆**的操作。

数据结构的功能无非增删查改，优先级队列有两个主要 API，分别是 `insert` 插入一个元素和 `delMax` 删除最大元素（如果底层用最小堆，那么就是 `delMin`）。

有关上浮、下沉以及插入删除操作的具体实现详见：[二叉堆详解实现优先级队列 :: labuladong的算法小抄](https://labuladong.github.io/algo/2/21/63/)





# 字符串

## 468. 验证IP地址

给定一个字符串 `queryIP`。如果是有效的 IPv4 地址，返回 "IPv4" ；如果是有效的 IPv6 地址，返回 "IPv6" ；如果不是上述类型的 IP 地址，返回 "Neither" 。

有效的IPv4地址 是 “`x1.x2.x3.x4`” 形式的IP地址。 其中 0 <= xi <= 255 且 xi 不能包含 前导零。例如: “192.168.1.1” 、 “192.168.1.0” 为有效IPv4地址， “192.168.01.1” 为无效IPv4地址; “192.168.1.00” 、 “192.168@1.1” 为无效IPv4地址。

一个有效的IPv6地址 是一个格式为“x1:x2:x3:x4:x5:x6:x7:x8” 的IP地址，其中: 1 <= xi.length <= 4；xi 是一个 十六进制字符串 ，可以包含数字、小写英文字母( 'a' 到 'f' )和大写英文字母( 'A' 到 'F' )；在 xi 中允许前导零。

**示例：**

```php
输入：queryIP = "172.16.254.1"
输出："IPv4"
解释：有效的 IPv4 地址，返回 "IPv4"
```



牛客top101上有


















# 参考资料

[labuladong 的算法小抄 :: labuladong的算法小抄](https://labuladong.github.io/algo/)

[代码随想录 (programmercarl.com)](https://programmercarl.com/)

[题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台 (leetcode-cn.com)](https://leetcode-cn.com/problemset/all/)













