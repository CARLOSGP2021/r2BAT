# 🔥算法刷题

# 一、二叉树

## 解题方法

1️⃣ 遇到二叉树的题目，如何去思考？或者说有没有思考的框架呢？

- **是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

- **是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「**分解问题**」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

2️⃣ 如何正确地理解**前中后序遍历**呢？

**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：

- 前序位置的代码在刚刚进入一个二叉树节点的时候执行；
- 后序位置的代码在将要离开一个二叉树节点的时候执行；
- 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204170940278.png" alt="image-20220417094016966" style="zoom:50%;" /></div>

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204170942506.png" alt="image-20220417094235414" style="zoom:60%;" /></div>

3️⃣前序位置和后序位置的代码有什么区别？后序位置有什么特殊之处？

前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到**子树**通过函数返回值传递回来的数据。

🔥总结：二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，**你只需要单独思考每一个节点应该做什么**，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

## 1、最大/小深度、最大直径

### 104、求二叉树最大深度

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数，叶子节点是指没有子节点的节点。

**示例：** 
给定二叉树`[3,9,20,null,null,15,7]`，

```php
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3。

**解法一**：递归遍历二叉树，回溯算法思路

遍历一遍二叉树，用一个外部变量记录**每个节点**所在的深度，取最大值就可以得到最大深度。

```php
class Solution {
public:
    int depth = 0;
    int res = 0;
    int maxDepth(TreeNode* root) {
        traverse(root);
        return res;
    }
    //遍历二叉树
    void traverse(TreeNode* root){
		if(root == nullptr){
            return;
        }
        //前序遍历位置
        depth++;
        //遍历过程中记录最大深度
        res = max(depth, res);
        traverse(root->left);
        traverse(root->right);
        //后序遍历位置
        depth--;
    }
};
```

**解法二**：分解成子树问题，动态规划思路

```php
class Solution {
public:
    // 定义：输入一个节点，返回以该节点为根的二叉树的最大深度
    int maxDepth(TreeNode* root) {
		if(root == nullptr){
            return 0;
        }
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        // 根据左右子树的最大深度推出原二叉树的最大深度
        return max(leftDepth, rightDepth) + 1;
    }
};
```

**解法三**：层序遍历

```php
class Solution {
public:
    int maxDepth(TreeNode* root) {
		int depth = 0;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth++;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

求二叉树的最大深度可以延伸到求二叉树的直径：

### 543、二叉树直径

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**
给定二叉树

```php
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

每一条二叉树的「**直径**」长度，就是一个节点的左右子树的**最大深度之和**。把计算「直径」的逻辑放在**后序位置**，准确说应该是放在 `maxDepth` 的后序位置，因为 `maxDepth` 的后序位置是知道左右子树的最大深度的。

```php
class Solution {
public:
    int maxDiameter = 0;
    int diameterOfBinaryTree(TreeNode* root) {
		maxDepth(root);
        return maxDiameter;       
    }
    
    //定义：输入一个节点，返回以该节点为根节点的二叉树的深度
    int maxDepth(TreeNode* root){
		if(root == nullptr){
            return 0;
        }
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        // 后序位置，顺便计算最大直径
        maxDiameter = max(leftDepth + rightDepth, maxDiameter);
        return max(leftDepth, rightDepth) + 1;
    }
};
```

### 111、二叉树的最小深度

给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**示例**：给定二叉树`[3，9，20，null，null，15，7]`：

```php
      3
     / \
    9  20
       / \     
      15  7    
```

返回它的最小深度2。

**解法一**：分解成子树问题，动态规划思想

```php
class Solution {
public:
    //定义：输入一个节点，返回以该节点为根节点的二叉树的最小深度
    int minDepth(TreeNode* root) {
		if(!root) {
            return 0;
        }
        int leftDepth = minDepth(root->left);
        int rightDepth = minDepth(root->right);
        return min(leftDepth, rightDepth) + 1;        
    }    
};
```

❓**上面的算法对吗？为什么？**

❎错误！这个代码就犯了此图中的误区：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171128504.png" alt="111.二叉树的最小深度" style="zoom:50%;" /></div>

如果这么求的话，**没有左孩子的分支会算为最短深度**。

所以，如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度；

反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度；

最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。

✅**正确的解法一**：分解成子树问题，动态规划思想

```php
class Solution {
public:
    int minDepth(TreeNode* root) {
		if(!root){
            return 0;
        }
        int leftDepth = minDepth(root->left);
        int rightDepth = minDepth(root->right);
        if(!root->left){
            return rightDepth + 1;
        }
        if(!root->right){
            return leftDepth + 1;
        }
        return min(leftDepth, rightDepth) + 1;
    }
};
```

**解法二**：层序遍历

```php
class Solution {
public:
    int minDepth(TreeNode* root) {
		int depth = 0;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth++;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(!node->left && !node->right) return depth;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

## 2、翻转二叉树

**226、翻转二叉树**

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171844420.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**解法一**：递归遍历，回溯算法的思想

遍历二叉树的每个节点，每个节点的左、右子树交换位置。

```php
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
		traverse(root);
        return root;
    }
    // 二叉树遍历函数
    void traverse(TreeNode* root){
        if(!root){
            return;
        }
        // 每一个节点需要做的事就是交换它的左右子节点
        TreeNode* tmp = root->left;
        root->left = root->right;
        root->right = tmp;
        // 遍历框架，去遍历左右子树的节点
        traverse(root->left);
        traverse(root->right);
    }
};
```

**解法二**：分解为子树的问题，动态规划思想

用 `invertTree(x.left)` 先把 `x` 的左子树翻转，再用 `invertTree(x.right)` 把 `x` 的右子树翻转，最后把 `x` 的左右子树交换，这恰好完成了以 `x` 为根的整棵二叉树的翻转，即完成了 `invertTree(x)` 的定义。

```php
class Solution {
public:
    //定义：输入一个节点，将以该节点为根节点的二叉树进行翻转，返回其根节点
    TreeNode* invertTree(TreeNode* root) {
		if(!root) {
            return root;
        }
        // 利用函数定义，先翻转左右子树
        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);
        // 然后交换左右子节点
		root->left = right;
        root->right = left;
        return root;
    }    
};
```

**解法三**：层序遍历

```php
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();              // 中
            st.pop();
            swap(node->left, node->right);
            if(node->right) st.push(node->right);   // 右
            if(node->left) st.push(node->left);     // 左
        }
        return root;
    }
};
```

## 3、二叉树展开为链表

**114、二叉树展开为链表**

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 前序遍历 顺序相同。

**示例 ：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171905704.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**解法一**：递归遍历

对整棵树进行前序遍历，一边遍历一边构造出一条「链表」。

```php
class Solution {
public:
    // 虚拟头节点，res->right 就是结果
    TreeNode* res = new TreeNode(-1);
    // 用来构建链表的指针
    TreeNode* p = res;
    TreeNode* flatten(TreeNode* root) {
        traverse(root);
        return res->right;
    }
    
    void traverse(TreeNode* root){
		if(!root) return;
        p = new TreeNode(root->val);
        p = p->right;
        traverse(root->left);
        traverse(root->right);
    }
};
```

但是注意 `flatten` 函数的签名，返回类型为 `void`，也就是说题目希望我们在原地把二叉树拉平成链表。

这样一来，没办法通过简单的二叉树遍历来解决这道题了。

**解法二**：分解成子树的问题

对于一个节点 `x`，可以执行以下流程：

1、先利用 `flatten(x.left)` 和 `flatten(x.right)` 将 `x` 的左右子树拉平。

2、将 `x` 的右子树接到左子树下方，然后将整个左子树作为右子树。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171948600.png" alt="image-20220417194832538" style="zoom:50%;" /></div>

这样，以 `x` 为根的整棵二叉树就被拉平了，恰好完成了 `flatten(x)` 的定义。

```php
class Solution {
public:
    //定义：输入一个节点，将以该节点为根节点的二叉树展开成单链表
    void flatten(TreeNode* root) {
		if(!root) return;
        // 利用定义，把左右子树拉平
        flatten(root->left);
        flatten(root->right);
        // 1、左右子树已经被拉平成一条链表
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        // 2、将左子树作为右子树
        root->left =  nullptr;
        root->right = left;
        // 3、将原先的右子树接到当前右子树的末端
        TreeNode* p = root;
        // 注意这里的条件是 p->right，而不是 p ，即有右孩子则移动指针
        while(p->right){
            p = p->right;
        }
        p->right = right;
    }
};
```

## 4、填充每个节点的下一个右侧节点指针

**116、填充每个节点的下一个右侧节点指针**

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```php
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

**示例 1：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171958858.png" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
```

这道题若使用**常规的**遍历二叉树的话，只能将一个节点的左子树指向右子树，**不同节点的子树之间无法建立联系**，所以要改变遍历的方式。传统的 `traverse` 函数是遍历二叉树的所有节点，但现在我们想遍历的其实是两个相邻节点之间的「**空隙**」，所以可以在二叉树的基础上进行抽象，把图中的每一个方框看做一个节点：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204172004189.png" alt="img" style="zoom:30%;" /></div>

**解法一**：递归遍历二叉树

**这样，一棵二叉树被抽象成了一棵三叉树，三叉树上的每个节点就是原先二叉树的两个相邻节点**。

现在，我们只要实现一个 `traverse` 函数来遍历这棵三叉树，每个「三叉树节点」需要做的事就是把自己内部的两个二叉树节点穿起来。这样，`traverse` 函数遍历整棵「三叉树」，将所有相邻节的二叉树节点都连接起来，也就避免了我们之前出现的问题，把这道题完美解决。

```php
class Solution {
public:
    Node* connect(Node* root) {
        if(!root) return root;
        traverse(root->left, root->right);
        return root;
    }
    // 三叉树遍历框架
    void traverse(Node* node1, Node* node2){
        if(!node1 || !node2){
            return;
        }
        node1->next = node2;
        traverse(node1->left, node1->right);
        traverse(node2->left, node2->right);
        traverse(node1->right, node2->left);
    }
};
```

**解法二**：层序遍历

在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204182056966.png" alt="填充每个节点的下一个右侧节点指针.drawio.png" style="zoom:70%;" /></div>

核心代码逻辑为：

- 遍历到每一层的第一个节点时，用pre记录该节点，然后节点出队，node记录pre；

- 向后每遍历一个节点，用node记录该节点，然后节点出队，**pre指向node**，pre指针向后移动一位；

- 该层最后一个节点指向nullptr；

```php
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if (root != NULL) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            Node* nodePre;
            Node* node;
            for (int i = 0; i < size; i++) {
                if (i == 0) {
                    pre = que.front(); // 取出一层的头结点
                    que.pop();
                    node = pre;
                } else {
                    node = que.front();
                    que.pop();
                    pre->next = node; // 本层前一个节点next指向本节点
                    pre = pre->next;
                }
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            nodePre->next = NULL; // 本层最后一个节点指向NULL
        }
        return root;
    }
};
```

## 5、寻找重复的子树

**652、寻找重复的子树**

给定一棵二叉树 root，返回所有重复的子树。

对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。

如果两棵树具有相同的结构和相同的结点值，则它们是重复的。

**示例**：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204172024286.jpeg" alt="img" style="zoom:50%;" /></div>

```php
输入：root = [1,2,3,4,null,2,4,null,null,4]
输出：[[2,4],[4]]
```

如何知道以某个节点为根的子树是不是重复的，是否应该加入结果列表中，需要知道什么信息呢？

**你需要知道以下两点**：

1、以我为根的这棵二叉树（子树）长啥样？——**后序遍历**

2、以其他节点为根的子树都长啥样？——利用哈希表存起来做比较

现在，明确了要用后序遍历，那应该怎么描述一棵二叉树的模样呢？二叉树的前序/中序/后序遍历结果可以描述二叉树的结构。所以，可以通过**拼接字符串**的方式把二叉树**序列化**。

```php
class Solution {
public:
    unordered_map<string, int> map;
    vector<TreeNode*> res;
    
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
		traverse(root);
        return r
    }
    //定义：输入一个节点，将以该节点为根节点的二叉树序列化，返回序列化后的字符串
    string traverse(TreeNode* root){
		if(!root) return "#";
        string left = traverse(root->left);
        string right = traverse(root->right);
        // 后序位置获取二叉树序列化后的字符串
        string str = left + "," + right + "," + to_string(root->val);
        if(map[str] == 1){
            res.push_back(root);
        }
        map[str]++;
        return str;
    }
};
```

## 6、构造二叉树

😶‍🌫️二叉树的构造问题一般都是使用「**分解问题**」的思路：**构造整棵树 = 根节点 + 构造左子树 + 构造右子树**。

### 654、构造最大二叉树

给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 `nums` 构建的**最大二叉树**。

**示例**：

```php
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
               6
             /  \
            3    5
             \   /      
              2 0   
               \
                1
```

首先遍历数组把找到最大值 `maxVal`，从而把根节点 `root` 构造出来，然后对 `maxVal` 左边的数组和右边的数组进行递归构建，作为 `root` 的左、右子树。

```php
//定义二叉树
struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x):val(x), left(nullptr), right(nullptr){}
}

class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
		return build(nums, 0, nums.size() - 1);
    }
    
    //定义：输入数组和区间左右端点，返回构造的最大二叉树的根节点
    TreeNode* build(vector<int>& nums, int lo, int hi){
        if(lo > hi){
            return nullptr;
        }
        // 找到数组中的最大值和对应的索引
        // 注意不能写成 int rootVal = 0;
        int rootVal = INT32_MIN;
        int index = 0;
        for(int i = lo; i <= hi; i++){
			if(rootVal < nums[i]){
                rootVal = nums[i];
                index = i;
            }
        }
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(nums, lo, index - 1);
        root->right = build(nums, index + 1, hi);
        return root;
    }
};
```

### 105、从前序与中序遍历序列构造二叉树

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

```php
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171505952.jpeg" alt="img" style="zoom: 67%;" /></div>

前序遍历`preorder` 和 中序遍历`inorder` 数组中的元素分布有如下特点：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171510562.png" alt="image-20220417151011413" style="zoom:80%;" /></div>

找到根节点是很简单的，前序遍历的第一个值 `preorder[0]` 就是根节点的值。关键在于如何通过根节点的值，将 `preorder` 和 `postorder` 数组划分成两半，构造根节点的左右子树？

**暴力**方法是利用for循环遍历整个数组找出`index`，但是通过 for 循环遍历的方式去确定 `index` 效率不算高，可以进一步优化：采用**哈利表**的查到 `rootVal` 对应的 `index`，数组元素无序且不重复，故采用 `unordered_map`来实现，底层由**哈希表**实现。

本道题的一大**难点**在于如何确定左右数组对应的起始索引和终止索引，这个可以通过左子树的节点数推导出来，假设左子树的节点数为 `leftSize`，那么 `preorder` 数组上的索引情况是这样的：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171511724.png" alt="image-20220417151152530" style="zoom:60%;" /></div>

做这种题目一定要画示意图，选择闭区间，若索引填错了，就会引起栈溢出的错误。

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
		int size = inorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[inorder[i]] = i;
        }
        return build(preorder, 0, size - 1, inorder, 0, size - 1);
    }
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd, 
                    vector<int>& inorder, int inStart, int inEnd){
    	if(preStart > preEnd){
            return nullptr;
        }
        //根节点的值
        int rootVal = preorder[preStart];
        //利用哈希表查询到 rootVal 在 inorder 中的索引 index
        int index = map[rootVal];
        
        int leftSize = index - inStart;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(preorder, preStart + 1, preStart + leftSize, 
                          inorder, inStart, index - 1);
    	root->right = build(preorder, preStart + leftSize + 1, preEnd,
                           inorder, index + 1, inEnd);
    	return root;
    }
};
```

### 106、从中序与后序遍历序列构造二叉树

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。

```php
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
```

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171505952.jpeg" alt="img" style="zoom: 67%;" /></div>

 `postoder` 和 `inorder` 对应的状态如下：

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171615448.png" alt="image-20220417161545340" style="zoom:60%;" /></div>

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
		int size = inorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[inorder[i]] = i;
        }
        return build(inorder, 0, size - 1, postorder, 0, size - 1);
    }
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& inorder, int inStart, int inEnd, 
                    vector<int>& postorder, int postStart, int postEnd){
    	if(postStart > postEnd){
            return nullptr;
        }
        //根节点的值
        int rootVal = postorder[postEnd];
        //利用哈希表查询到 rootVal 在 inorder 中的索引 index
        int index = map[rootVal];
        
        int leftSize = index - inStart;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(inorder, inStart, index - 1, 
                          postorder, postStart, postStart + leftSize - 1);
    	root->right = build(inorder, index + 1, inEnd,
                           postorder, postStart + leftSize, postEnd - 1);
    	return root;
    }
};
```

### 889、根据前序和后序遍历构造二叉树

给定两个整数数组，`preorder` 和 `postorder` ，其中 `preorder` 是一个具有 **无重复** 值的二叉树的前序遍历，`postorder` 是同一棵树的后序遍历，重构并返回二叉树。

如果存在多个答案，您可以返回其中 **任何** 一个。

```php
输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
输出：[1,2,3,4,5,6,7]
```

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171628354.jpeg" alt="img" style="zoom:60%;" /></div>

这道题和前两道题有一个本质的区别：

**通过前序中序，或者后序中序遍历结果可以确定一棵原始二叉树，但是通过前序后序遍历结果无法确定原始二叉树**。这道题，你可以确定根节点，但是无法确切的知道左右子树有哪些节点，以下是一种构造方法：

1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值。

2、然后把前序遍历结果的第二个元素作为左子树的根节点的值。

3、在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可。

假设前序遍历的第二个元素是左子树的根节点，但实际上左子树有可能是空指针，那么这个元素就应该是右子树的根节点。由于这里无法确切进行判断，所以导致了最终答案的不唯一。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171639321.png" alt="image-20220417163947215" style="zoom:70%;" /></div>

```php
class Solution {
public:
    unordered_map<int, int> map;
    
    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {
		int size = postorder.size();
        //遍历数组构造哈希表
        for(int i = 0; i < size; i++){
            map[postorder[i]] = i;
        }
        return build(preorder, 0, size - 1, postorder, 0, size - 1);
    }
    
    //定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd, 
                    vector<int>& postorder, int postStart, int postEnd){
    	if(postStart > postEnd){
            return nullptr;
        }
        if(postStart == postEnd){
            return new TreeNode(postorder[postStart]);
        }
        //根节点的值
        int rootVal = preorder[preStart];
        int leftRootVal = preorder[preStart + 1];
        //利用哈希表查询到左子树根节点 leftRoot 在 postorder 中的索引 index
        int index = map[leftRootVal];
        
        int leftSize = index - postStart + 1;
        
        TreeNode* root = new TreeNode(rootVal);
        root->left = build(preorder, preStart + 1, preStart + leftSize, 
                          postorder, postStart, index);
    	root->right = build(preorder, preStart + leftSize + 1, preEnd,
                           postorder, index + 1, postEnd - 1);
    	return root;
    }
};
```

## 7、层序遍历

### 102、二叉树的层序遍历

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181828285.png" alt="102.二叉树的层序遍历" style="zoom:50%;" /></div>

需要借用一个辅助数据结构即**队列**来实现，队列**先进先出**，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。

while循环用来从上到下遍历二叉树的每一层，for循环用来从左到右遍历每一层当中的节点。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181834096.png" alt="image-20220418183400018" style="zoom:50%;" /></div>

```php
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

### 107、二叉树的层次遍历II

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181838870.png" alt="107.二叉树的层次遍历II" style="zoom:55%;" /></div>

相对于102.二叉树的层序遍历，就是最后把`result`数组反转一下就可以了。

```php
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        reverse(result.begin(), result.end()); // 在这里反转一下数组即可
        return result;
    }
};
```

### 515、在每个树行中找最大值

给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204190917513.png" alt="515.在每个树行中找最大值" style="zoom:60%;" /></div>

**解法一**：递归遍历二叉树

我们先来思考这样一个问题：如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？

`traverse`遍历函数的参数当中只包含`TreeNode* root `可以吗？**不行！**还要加上节点所在的层数`level`，因为在递归遍历的过程中，遍历左子树接着遍历右子树，层数leve并不是一直增加，同一层的节点level是一样的，所以不能定义全局变量，而是要放在`traverse`函数参数当中维护。

**如果要在遍历二叉树的过程中获取每个节点所在的层数，则要在`traverse`遍历函数的参数当中添加层数`level`。**

```php
// 定义：二叉树遍历函数，输入一个节点和该节点所在的层数
void traverse(TreeNode root, int level) {
    if (root == null) {
        return;
    }
    // 前序位置
    printf("节点 %s 在第 %d 层", root, level);
    //注意如下代码中的 level + 1
    traverse(root.left, level + 1);
    traverse(root.right, level + 1);
}

// 人为设定根节点位于第1层
traverse(root, 1);
```

回到本题当中，本质上是一个求节点最大值的问题，但问题是**如何保证参与比大小求最值的节点来自于同一层呢**？

🥳在遍历二叉树的过程中获取每一个节点所在的层数，比较层数就可以了呀，也就是说**这是一个涉及二叉树层数的问题，要在`traverse`遍历函数的参数当中添加层数`level`。**

假设二叉树的层数从第0层开始算，res数组所以默认从0开始：

- 假设数组遍历到二叉树第2层某节点，而res数组当中只有**2**个元素（已获取前两层的最大值），即`level == res.size()`，表示res数组当中无该层任何节点，**将该节点添加到res数组中**；

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191022409.png" alt="image-20220419102205366" style="zoom:60%;" /></div>

- 假设数组遍历到二叉树第2层某节点，而res数组当中只有**3**个元素（已获取前三层的最大值），表示该层已经有节点被访问了，则**比大小取最值**；

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191022406.png" alt="image-20220419102248364" style="zoom:60%;" /></div>

所以也就是说，核心代码逻辑要使用`if`语句分以上两种情况讨论。

```php
class Solution {
public:
	vector<int> res;
    void traverse(TreeNode* root,int level){
        if(root == NULL){
            return;
        }
        if(level == res.size()){//每层第一个节点
            res.push_back(root->val);
        } else{					//每层第一个节点之外的节点
            res[level] = max(res[level], root->val);
        } 
        traverse(root->left, level + 1);
        traverse(root->right, level + 1);
    }
    vector<int> largestValues(TreeNode* root) {
        //二叉树层数从第0层开始算
        traverse(root,0);
        return res;
    }
};
```

**解法二**：层序遍历

层序遍历，取每一层的最大值。

- while循环开始遍历每一层时，创建最大值`maxValue`；
- for循环遍历该层每一个节点，顺便更新`maxValue`；
- 退出for循环，该层所有节点遍历完成，`maxValue`放入结果数据`result`中；

```php
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<int> result;
        while (!que.empty()) {
            int size = que.size();
            int maxValue = INT_MIN; // 取每一层的最大值
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                maxValue = node->val > maxValue ? node->val : maxValue;
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(maxValue); // 把最大值放进数组
        }
        return result;
    }
};
```

### 199、二叉树的右视图

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191815468.png" alt="199.二叉树的右视图" style="zoom:55%;" /></div>

**解法一**：递归遍历

要找到每一层最右边的节点，涉及**二叉树节点所在层数**的问题，还是使用[515、在每个树行中找最大值](# 515、在每个树行中找最大值)中的遍历框架。

**注意**：由于本题是要找每层最右侧节点，所以**先遍历右子树再遍历左子树**，这样每层遍历时首先访问到的就是要求的节点。

```php
class Solution {
public:
    vector<int> res;

    vector<int> rightSideView(TreeNode* root) {
        traverse(root, 0);
        return res;
    }

    void traverse(TreeNode* root, int level){
        if(!root) return;
		//这一层还没有记录值，说明 root 就是右侧视图的第一个节点
        if(res.size() == level){
            res.push_back(root->val);
        }
		// 注意，这里反过来，先遍历右子树再遍历左子树
        // 这样，首先遍历的一定是右侧节点
        traverse(root->right, level + 1);
        traverse(root->left, level + 1);
    }
};
```

那如果是要求二叉树的**左视图**呢，那就**先遍历左子树再遍历右子树**呗，又AC了一题😜。

**解法二**：层序遍历

```php
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
		queue<TreeNode*> que;
        vector<int> res;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(i == (size - 1)){
                    res.push_back(node->val);
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return res;
    }
};
```

### 637、二叉树的层平均值

给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。

**示例 ：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201555469.jpeg" alt="img" style="zoom:60%;" /></div>

```php
输入：root = [3,9,20,null,null,15,7]
输出：[3.00000,14.50000,11.00000]
```

层序遍历轻松完成，**注意**：先求一层所有节点的和，最后再作除法。


```php
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> res;
        queue<TreeNode*> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            // 记录当前层所有节点之和
            double sum = 0;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                sum += node->val;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            // 记录当前行的平均值
            res.push_back(sum / size);
        }
        return res;
    }
};
```

# 8、 二叉树是否对称/相等

[101、对称二叉树](# 101、对称二叉树)和[100、相同的树](# 100、相同的树)结合起来看，两道题方法和代码上非常相似。

### 101、对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201633364.png" alt="101. 对称二叉树" style="zoom:60%;" /></div>

**解法一**：分解成子树问题

对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了**其实我们要比较的是两颗树（这两颗树是根节点的左右子树）**，所以在递归遍历的过程中，也是要同时遍历两棵树。

正是因为要遍历两棵树而且要**比较内侧和外侧节点**，所以准确的来说是一个树的遍历顺序是**左右中**，一个树的遍历顺序是**右左中**，只有内侧和外侧节点分别对应相等，这两棵树才是对称的。

**返回条件**：

- 左节点为空，右节点不为空，不对称，return false；
- 左不为空，右为空，不对称 return false；
- 左右都为空，对称，返回true；

- 左右都不为空，比较节点数值，不相同就return false；

代码如下：

```php
if (left == NULL && right != NULL) return false;
else if (left != NULL && right == NULL) return false;
else if (left == NULL && right == NULL) return true;
else if (left->val != right->val) return false;
```

```php
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
		return compare(root->left, root->right);
    }
    //定义：输入左、右节点，返回分别以这两节点为根节点的二叉树是否对称
    bool compare(TreeNode* left, TreeNode* right){
        // 注意这里终止条件的代码
        if(!left || !right) return left == right;
        if(left->val != right->val) return false;
        bool outside = compare(left->left, right->right);	//外侧节点比较
        bool inside = compare(left->right, right->left);	//内侧节点比较
        return outside && inside;	//左右子节点需要对称相同
	}
};
```

代码简化为：

```php
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
		return compare(root->left, root->right);
    }
    //定义：输入左、右节点，返回分别以这两节点为根节点的二叉树是否对称
    bool compare(TreeNode* left, TreeNode* right){
        // 该对节点是否对称
        if(!left || !right) return left == right;
        if(left->val != right->val) return false;
        // 其他节点是否对称
        return compare(left->left, right->right) && compare(left->right, right->left);
	}
};
```

**解法二**：迭代法，不是层序遍历，这里我们可以使用**队列**来比较两个树（根节点的左右子树）是否相互翻转。

把左右两个子树要比较的元素顺序放进一个容器，然后**成对**的取出来进行比较，那么其实使用**栈**也是可以的。

```php
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        
        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }
            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```

### 100、相同的树

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201830207.jpeg" alt="img" style="zoom:60%;" /></div>

```php
输入：p = [1,2,3], q = [1,2,3]
输出：true
```

解法一：分解成子树问题

```php
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p || !q) return p == q;
        if(p->val != q->val) return false;
        bool left = isSameTree(p->left, q->left);	//比较左子树
        bool right = isSameTree(p->right, q->right);//比较右子树
        return left && right;
    }
};
```

代码简化为：

```php
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // 判断一对节点是否相同
        if(!p || !q) return p == q;
        if(p->val != q->val) return false;
        // 判断其他节点是否相同
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

**解法二**：迭代法

```php
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        queue<TreeNode*> que;
        que.push(p);
        que.push(q);
        //注意不能加上写成如下代码，否则会报错
        //if(p) que.push(p);   
        //if(q) que.push(q);  
        while (!que.empty()) {  // 接下来就要判断这两颗树是否相等
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是相等的
                continue;
            }
            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   
            que.push(rightNode->left); 
            que.push(leftNode->right);  
            que.push(rightNode->right); 
        }
        return true;
    }
};
```

**注意**：

```php
que.push(p);
que.push(q);
```

不能写为：

```
if(p) que.push(p);   
if(q) que.push(q);  
```

否则会报错：

```php
执行出错信息：
Line 15: Char 74: runtime error: member access within misaligned address 0xbebebebebebebebe for type 'TreeNode', which requires 8 byte alignment (solution.cpp)
0xbebebebebebebebe: note: pointer points here
<memory cannot be printed>
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:74
最后执行的输入：
[]
[0]
```

加上`if`判断后，若输入当中有为空的，则无法加入到队列当中，影响后序的代码逻辑运行。

### 572、另一个树的子树

给你两棵二叉树 `root` 和 `subRoot` ，检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。

二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点，`tree` 也可以看做它自身的一棵子树。

**示例：**

<div align=center><img src="https://cdn.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201953856.jpeg" alt="img" style="zoom:50%;" /></div>

```
输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
```

遍历以 `root` 为根的这棵二叉树的所有节点，用 [100、相同的树](# 100、相同的树) 中的 `isSameTree` 函数判断以该节点为根的子树是否和以 `subRoot` 为根的那棵树相同。

```php
class Solution {
public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
		if(!root) return root == subRoot;
        // 判断以 root 为根的二叉树是否和 subRoot 相同
        if(isSameTree(root, subRoot)) return true;
        // 去左右子树中判断是否有和 subRoot 相同的子树
        return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);
    }
    // 定义：输入两个节点，判断以两个节点为根节点的二叉树是否一样，返回结果
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // 判断一对节点是否相同
        if(!p || !q) return p == q;
        if(p->val != q->val) return false;
        // 判断其他节点是否相同
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```












# 参考资料

[labuladong 的算法小抄 :: labuladong的算法小抄](https://labuladong.github.io/algo/)

[代码随想录 (programmercarl.com)](https://programmercarl.com/)













